{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"build/","title":"Build Applications","text":"<p>To build applications on Ceramic, use a Ceramic-powered database.</p>"},{"location":"build/#featured-databases","title":"Featured Databases","text":""},{"location":"build/#composedb-a-graph-db-for-web3-apps","title":"ComposeDB: A Graph DB for Web3 Apps \u2192","text":"<p>ComposeDB is the latest and greatest way to build apps with composable data on Ceramic's data layer. It is a decentralized, verifiable graph database that supports both Javascript and GraphQL.</p>"},{"location":"build/#legacy-databases","title":"Legacy Databases","text":""},{"location":"build/#idx-selfid","title":"IDX &amp; Self.ID \u2192","text":"<p>IDX, a key-value store DB, is a legacy alternative to ComposeDB. Self.ID is a framework that made it easier to use IDX. These used to be recommended databases for building apps on Ceramic, but they have since been replaced by ComposeDB.</p>"},{"location":"build/#build-a-new-database","title":"Build a new Database","text":"<p>If the database solutions above don't suit your needs, you can always build a new database powered by Ceramic by using the Ceramic client. Clients are a lower-level way to connect to the Ceramic network; they come without much pre-configuration, so you'll need to put at least a few different pieces together yourself.</p>"},{"location":"build/#additional-notes","title":"Additional Notes","text":""},{"location":"build/#system-requirements","title":"System Requirements","text":"<ul> <li>Ceramic clients and tools using them are designed for environments supporting ECMAScript 11<sup>th</sup> edition, commonly referred to as ES2020.</li> <li>Most packages are exposed as ECMAScript Modules (ESM), which are supported by most modern browsers and recent versions of Node.</li> <li>We recommend Node v16 (LTS), as it is the version used for tests in most Ceramic packages.</li> </ul>"},{"location":"build/share/","title":"Share your project","text":"<p>Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work:</p> <ul> <li>Add the <code>ceramic</code> topic to your project on Github</li> <li>Add your project to the Awesome Ceramic page on Github</li> </ul>"},{"location":"build/the-ceramic-stack/","title":"The Ceramic stack","text":"<p>The Ceramic application development stack consists of a few key components which are listed below, in order from highest-level frameworks to lowest-level network APIs.</p>"},{"location":"build/the-ceramic-stack/#1-frameworks","title":"1. Frameworks","text":"<p>Frameworks abstract away much of the complexity and configuration of the underlying stack, providing developers with a simple entrypoint into Ceramic development. In order to achieve simplicity, frameworks tend to be opinionated about how and what you build on the network.</p> <p>The most popular framework for Ceramic is the Self.ID SDK, a bundle that includes everything you need to build applications with composable, user-centric Web3 data.</p>"},{"location":"build/the-ceramic-stack/#2-middleware","title":"2. Middleware","text":"<p>Middleware is a generic name for all kinds of development tools that are not a part of the core Ceramic protocol, but provide developers with additional functionality and convenience.</p> <p>The most popular middleware for Ceramic is Glaze suite, which provides a set of libraries that developers can use alongside a Ceramic client when building applications.</p>"},{"location":"build/the-ceramic-stack/#3-data-models","title":"3. Data models","text":"<p>Data models are collections of one or more streams, specified by their schemas and relationships, that define a single data structure on Ceramic. Data models form the basis of composability on Ceramic. When multiple applications reuse the same data model, they can reuse the same data. Typically, data models are used to represent an application feature such as a social graph or a user profile.</p> <p>The most popular data models for Ceramic can be found in the Data Models Registry \u2192, an open registry of Ceramic data models created by the community.</p>"},{"location":"build/the-ceramic-stack/#4-streams","title":"4. Streams","text":"<p>Streams are individual instances of state on the Ceramic network. Every stream that is created on Ceramic must specify its streamcode, which is a script that contains the processing logic used to transform a stream's current state into the next state upon receipt of a new transaction. In general, you can think of streamcode as reusable state processing logic and streams as the individual states it generates.</p> <p>Today Ceramic supports two types of streams: tile documents which store mutable JSON documents with schema validation, and CAIP-10 links which store a link between a Web3 wallet account and a Ceramic account.</p>"},{"location":"build/the-ceramic-stack/#5-accounts","title":"5. Accounts","text":"<p>Accounts are user entities on Ceramic that can own streams and submit transactions to those streams. Ceramic accounts conform to the standard decentralized identifier (DID) specification, as outlined by the Decentralized Identity Foundation (DIF). DIDs are useful as they serve to unbundle Ceramic accounts from any single Web3 wallet address or public key, allowing users to control the same Ceramic account from one or more Web3 wallet accounts, and in the process providing an abstraction to enable truly cross-chain accounts.</p> <p>The most popular account client is the DID JSON-RPC client, which provides a standard account API and must be used alongside a Ceramic client in order to enable authenticated accounts to perform transactions on the network. The DID client currently supports three different account types: PKH DID, will allows you to use a Web3 wallet adress as a Ceramic account, 3ID DID, which allows controlling a Ceramic account from multiple Web3 wallet addresses, and Key DID, which can only be controlled by a single key.</p>"},{"location":"build/the-ceramic-stack/#6-clients","title":"6. Clients","text":"<p>Clients libraries allow your application to connect to a Ceramic node. Different clients may choose to implement different high-level, language-specific developer APIs. Before submitting requests to a Ceramic node, clients translate those API calls into the standard Ceramic HTTP API, which it uses to actually communicate with a Ceramic node.</p> <p>The most popular client on Ceramic is the JS HTTP client, allowing developers to connect their application to Ceramic using JavaScript.</p>"},{"location":"build/the-ceramic-stack/#7-network-apis","title":"7. Network APIs","text":"<p>The Ceramic HTTP API is the lowest-level interface for Ceramic. It is used under the hood by every client and node to communicate. Unless application developers have a specific need to use HTTP, most never need to interact with this API directly, instead accessing it via more developer-friendly client APIs. Protocol developers wishing to write a client in a new language, however, would need to use this specification.</p> <p>Learn more about the Ceramic HTTP API.</p>"},{"location":"build/troubleshooting/","title":"Troubleshooting","text":""},{"location":"build/troubleshooting/#known-issues","title":"Known Issues","text":"<p>If you encounter an issue, see if it's already known with a recommended work around or currently under investigation in this document. Leave feedback or notes in the comment if something is unclear or out of date.</p>"},{"location":"build/troubleshooting/#developer-chat","title":"Developer Chat","text":"<p>For developer questions, chat, and support, join us on the Ceramic Forum .</p>"},{"location":"build/troubleshooting/#github-issues","title":"Github Issues","text":"<p>For specific bugs, issues, and feature requests, create a Github issue  on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem.</p>"},{"location":"build/troubleshooting/#twitter","title":"Twitter","text":"<p>For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .</p>"},{"location":"build/cli/api/","title":"CLI API","text":"<p>This page describes CLI commands for interacting with Ceramic.</p> <p>Depreciation Notice:</p> <p>Interactions with Streams and TileDocuments have been moved to our Glaze CLI. If you encounter any errors with the commands below please retry using the Glaze CLI first.</p>"},{"location":"build/cli/api/#requirements","title":"Requirements","text":"<p>You should have already installed the CLI.</p>"},{"location":"build/cli/api/#write-apis","title":"Write APIs","text":""},{"location":"build/cli/api/#create-a-stream","title":"Create a stream","text":"<p>Use the <code>create</code> command to create a new stream. In the example below we create a stream that uses the TileDocument StreamType. Note that TileDocument is the only StreamType that can currently be created by the Ceramic CLI.</p> <pre><code>ceramic create tile --content '{ \"Foo\": \"Bar\" }'\n</code></pre> <p>The first line of your output will be the StreamID of your stream. Below the StreamID, you will see it's content.</p> <p>Create options:</p> <p>Run <code>ceramic create -h</code> to see all available create options. Some common options:</p> <ul> <li><code>--content</code>: set the content of the stream</li> <li><code>--controllers</code>: set the controller of the stream</li> <li><code>--schema</code>: set the schema of the TileDocument</li> </ul>"},{"location":"build/cli/api/#update-a-stream","title":"Update a stream","text":"<p>Use the <code>update</code> command to update a stream. You will need to provide a StreamID. Your DID must be the controller of the stream in order to update it. Note that TileDocument is the only StreamType that can currently be updated by the CLI.</p> <pre><code>ceramic update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --content '{\n    \"Foo\": \"Baz\"\n  }'\n</code></pre> <p>Update options:</p> <p>Run <code>ceramic update -h</code> to see all available update options. Some common options:</p> <ul> <li><code>--content</code>: update the content of the stream</li> <li><code>--controllers</code>: update the controller of the stream</li> <li><code>--schema</code>: update the schema of the TileDocument</li> </ul>"},{"location":"build/cli/api/#query-apis","title":"Query APIs","text":""},{"location":"build/cli/api/#query-a-streams-current-state","title":"Query a stream's current state","text":"<p>Use the <code>show</code> command to query the current state of a stream. You will need to provide a StreamID.</p> <pre><code>ceramic show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre>"},{"location":"build/cli/api/#query-a-streams-entire-state","title":"Query a stream's entire state","text":"<p>Use the <code>state</code> command to query the entire state of a stream. You will need to provide a StreamID.</p> <pre><code>ceramic state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre>"},{"location":"build/cli/api/#next-steps","title":"Next steps","text":"<p>If you haven't already, try putting these CLI commands to use in the Quick Start guide.</p>"},{"location":"build/cli/installation/","title":"Launch a local Ceramic node","text":"<p>The Ceramic command line interface provides an easy way to start a JS Ceramic node in a local Node.js environment. This is a great way to get started developing with Ceramic before moving to a cloud-hosted node for production use cases.</p>"},{"location":"build/cli/installation/#prerequisites","title":"Prerequisites","text":"<p>Installing the CLI requires a console, Node.js v16, and npm v6. Make sure to have these installed on your machine.</p> <p>While npm v7 is not officially supported, you may still be able to get it to work. You will need to install the <code>node-pre-gyp</code> package globally. This is required until <code>node-webrtc</code> which IPFS depends on is upgraded.</p> <pre><code>npm install -g node-pre-gyp\n</code></pre> <p>Depreciation Notice:</p> <p>Interactions with Streams and TileDocuments have been moved to our Glaze CLI. If you encounter any errors with the commands below please retry using the Glaze CLI first.</p>"},{"location":"build/cli/installation/#installation-and-usage","title":"Installation and usage","text":""},{"location":"build/cli/installation/#install-the-ceramic-cli","title":"Install the Ceramic CLI","text":"<p>Open your console and install the CLI using npm:</p> <pre><code>npm install -g @ceramicnetwork/cli\n</code></pre>"},{"location":"build/cli/installation/#launch-the-ceramic-node","title":"Launch the Ceramic node","text":"<p>Use the <code>ceramic daemon</code> command to start a local JS Ceramic node connected to the Clay Testnet at <code>https://localhost:7007</code>.</p> <pre><code>ceramic daemon\n</code></pre>"},{"location":"build/cli/installation/#configure-your-network","title":"Configure your network","text":"<p>(Optional) By default, the JS CLI starts a node on the Clay Testnet. If you would like to use a different network, you can specify this using the <code>--network</code> option. View available networks. Note, the CLI can not be used with Mainnet.</p>"},{"location":"build/cli/installation/#configure-a-node-url","title":"Configure a node URL","text":"<p>(Optional) It is possible to use the CLI with a remote Ceramic node over HTTP, instead of a local node. To do this, use the <code>config set</code> command to set the <code>ceramicHost</code> variable to the URL of the node you wish to use.</p> <pre><code>ceramic config set ceramicHost 'https://yourceramicnode.com'\n</code></pre>"},{"location":"build/cli/quick-start/","title":"Ceramic Quickstart","text":"<p>A simple introduction to Ceramic concepts. Learn the basics by using the Ceramic CLI.</p>"},{"location":"build/cli/quick-start/#setup","title":"Setup","text":""},{"location":"build/cli/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Ceramic requires Node.js v16 and npm v6.</p> <p>While npm v7 is not officially supported, you may still be able to get it to work. You will need to install the <code>node-pre-gyp</code> package globally. This is required until <code>node-webrtc</code> which IPFS depends on is upgraded.</p> <pre><code>npm install -g node-pre-gyp\n</code></pre>"},{"location":"build/cli/quick-start/#install-ceramic","title":"Install Ceramic","text":"<p>Open your console and install the CLIs using npm:</p> <pre><code>npm install --global @ceramicnetwork/cli @glazed/cli\n</code></pre> <ul> <li>The Ceramic CLI will now be accessible as <code>ceramic</code> and the Glaze CLI as <code>glaze</code>.</li> <li>Run <code>ceramic help</code> and <code>glaze help</code> to list the available commands.</li> </ul>"},{"location":"build/cli/quick-start/#launch-ceramic","title":"Launch Ceramic","text":"<p>Start a local Ceramic node connected to the Clay Testnet at <code>https://localhost:7007</code>:</p> <pre><code>ceramic daemon\n</code></pre>"},{"location":"build/cli/quick-start/#create-an-account","title":"Create an account","text":"<p>Ceramic transactions must be signed by an account (DID). The Glaze CLI can create a DID for you, after generating a 32-byte random seed:</p> <pre><code>glaze did:create\n</code></pre> <p>Your output should look something like this, with <code>...</code> used for brevity:</p> <pre><code>\u2714 Created DID did:key:z6Mk... with seed ab...f0\n</code></pre> <p>The seed can then be used when running other commands:</p> <pre><code>glaze [command] --key=ab...f0\nDID_KEY=ab...f0 glaze [command]\n</code></pre> <p>Note: when entering --key, it should be your encoded seed, not the did:key itself.</p>"},{"location":"build/cli/quick-start/#streams","title":"Streams","text":"<p>Ceramic usage depends on the particular types of streams you are interacting with, as they each have their own APIs. For this example the Glaze CLI interacts with tile documents, streams that store mutable JSON.</p>"},{"location":"build/cli/quick-start/#create","title":"Create","text":"<p>Create a new tile document using your account:</p> CommandOutput <pre><code>glaze tile:create --key ab...f0 --content '{\"Foo\":\"Bar\"}'\n</code></pre> <pre><code>Created stream kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa.\n{\nstreamID: 'kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa',\n  content: { Foo: 'Bar' }\n}\n</code></pre> <p>The StreamID is the unique ID of our stream. Your StreamID will be different since you created it with your account.</p> More options <ul> <li><code>--metadata</code>: set the metadata of the stream</li> <li>Run <code>glaze tile:create -h</code> to see all available options</li> </ul>"},{"location":"build/cli/quick-start/#query","title":"Query","text":"<p>Load the current state of a tile document using <code>tile:show</code> with a StreamID:</p> CommandOutput <pre><code>glaze tile:show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre> <p>You should use your StreamID instead of the StreamID included here.</p> <pre><code>Retrieved details of stream kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n{ Foo: 'Bar' }\n</code></pre> <p>Load the entire state of a stream using <code>stream:state</code> with a StreamID:</p> CommandOutput before anchorOutput after anchor <pre><code>glaze stream:state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre> <p>You should use your StreamID instead of the StreamID included here.</p> <pre><code>{\n\"type\": 0,\n  \"content\": {\n\"Foo\": \"Bar\"\n},\n  \"metadata\": {\n\"unique\": \"E4qPslUd0qo98TZX\",\n    \"schema\": null,\n    \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n  \"signature\": 2,\n  \"anchorStatus\": \"PENDING\",\n  \"log\": [\n{\n\"cid\": \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\",\n      \"type\": 0\n}\n],\n  \"anchorScheduledFor\": \"1/24/2021, 11:45:00 AM\"\n}\n</code></pre> <p>Here we can see various information about the stream such as content, controllers, and schema. In your output you should see your local DID as the controller, instead of the DID we show here. You will also see a different randomly-generated \"unique\" string for any TileDocument that was created without the <code>--deterministic</code> flag.  We can also see the current anchorStatus of our stream, and that it has been scheduled to be anchored at 11:45 on the 24<sup>th</sup> of January 2021. Once this anchor is finalized, the state of the stream will automatically be updated with a new entry in the log and anchorStatus will be set to <code>ANCHORED</code>.</p> <pre><code>{\n\"type\": 0,\n  \"content\": {\n\"Foo\": \"Bar\"\n},\n  \"metadata\": {\n\"unique\": \"E4qPslUd0qo98TZX\",\n    \"schema\": null,\n    \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n  \"signature\": 2,\n  \"anchorStatus\": \"ANCHORED\",\n  \"log\": [\n{\n\"cid\": \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\",\n      \"type\": 0\n},\n    {\n\"cid\": \"bafyreig6hostufw42cmz2cnn7hpvb6pau67a2n2syhzej7orqxfymdayyq\",\n      \"type\": 2\n}\n],\n  \"anchorScheduledFor\": null,\n  \"anchorProof\": {\n\"root\": \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\",\n    \"txHash\": \"bagjqcgza4xgkpjodtqtgyu2fx6rdr6fb6mhevd5hy4253tl6pjlssidpwaha\",\n    \"chainId\": \"eip155:3\",\n    \"blockNumber\": 9527752,\n    \"blockTimestamp\": 1611485094\n}\n}\n</code></pre> <p>This output was seen after the anchor has been created. The stream state has now shifted anchorStatus to <code>ANCHORED</code>. You can also see that the log contains one more entry.</p>"},{"location":"build/cli/quick-start/#update","title":"Update","text":"<p>Use <code>tile:update</code> to update a tile document. Note that your DID must be assigned as the controller (author) of the stream to have permission to update it.</p> CommandOutput <pre><code>glaze tile:update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --key ab...f0 --content '{\"Foo\":\"Baz\"}'\n</code></pre> <p>You should use your StreamID instead of the StreamID included here.</p> <pre><code>Updated stream\n{\n\"streamID\": \"kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\",\n  \"content\": {\n\"Foo\": \"Baz\"\n}\n}\n</code></pre> More options <p>You can change content and metadata using the CLI. Run <code>glaze tile:update -h</code> for more information.</p>"},{"location":"build/cli/quick-start/#schemas","title":"Schemas","text":""},{"location":"build/cli/quick-start/#creating-a-schema","title":"Creating a Schema","text":"<p>Tile documents can enforce that their content adheres to a schema. The schemas themselves are actually also stored in tile documents where the content is json-schema. </p> <p>Let's create a schema that requires a <code>title</code> and <code>message</code>:</p> CommandOutput <pre><code>glaze tile:create --key ab...f0 --content '{\n   \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n   \"title\": \"Reward\",\n   \"type\": \"object\",\n   \"properties\": {\n     \"title\": {\"type\": \"string\"},\n     \"message\": {\"type\": \"string\"}\n   },\n   \"required\": [\n     \"message\",\n     \"title\"\n   ]\n }'\n</code></pre> <pre><code>Created stream kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb.\n{\nstreamID: 'kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb',\n  content: {\ntype: 'object',\n    title: 'Reward',\n    '$schema': 'http://json-schema.org/draft-07/schema#',\n    required: [ 'message', 'title' ],\n    properties: { title: { type: 'string' }, message: { type: 'string' } }\n}\n}\n</code></pre>"},{"location":"build/cli/quick-start/#selecting-a-version","title":"Selecting a Version","text":"<p>First, use the <code>stream:commits</code> command to list the commits contained in the schema stream. Find the specific commit (version) that you want to use.</p> CommandOutput <pre><code>glaze stream:commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb\n</code></pre> <p>You should use your StreamID for the stream containing the json-schema you want to enforce, instead of the StreamID included here.</p> <pre><code>Stream commits loaded.\n[\n\"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\"\n]\n</code></pre> <p>If a stream contains multiple commits and you're not sure which one you want, use the <code>tile:show</code> command to show the content of the stream at the given commit.</p>"},{"location":"build/cli/quick-start/#using-the-schema","title":"Using the Schema","text":"<p>When creating a tile document that uses this schema, we need to use the commitID instead of the StreamID to enforce that we are using a specific version of the schema, since the schema stream is mutable and can be updated. To create a stream that conforms to your schema, use the <code>tile:create</code> command and pass the <code>--metadata</code> option along with your commitID:</p> CommandOutput <pre><code>glaze tile:create --key ab...f0 --content '{\n    \"title\": \"My first document with schema\",\n    \"message\": \"Hello World\"\n  }' --metadata '{\"schema\":\"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\"}'\n</code></pre> <p>You should use your commitID instead of the commitID included here.</p> <pre><code>Created stream kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj.\n{\nstreamID: 'kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj',\n  content: { title: 'My first document with schema', message: 'Hello World' }\n}\n</code></pre>"},{"location":"build/cli/quick-start/#confirmation","title":"Confirmation","text":"<p>Let's view the tile document we just created using the <code>stream:state</code> command from above. We will see that the schema is correctly set in the metadata.</p> CommandOutput <pre><code>glaze stream:state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn\n</code></pre> <p>You should use your StreamID instead of the StreamID included here.</p> <pre><code>Successfully queried stream kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn\n{\n\"type\": 0,\n  \"content\": {\n\"title\": \"My first document with schema\",\n    \"message\": \"Hello World\"\n},\n  \"metadata\": {\n\"unique\": \"GR5tBtHdaw608esV\",\n    \"schema\": \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\",\n    \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n  \"signature\": 2,\n  \"anchorStatus\": \"PENDING\",\n  \"log\": [\n{\n\"cid\": \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\",\n      \"type\": 0\n}\n],\n  \"anchorScheduledFor\": \"1/13/2021, 1:45:00 PM\"\n}\n</code></pre>"},{"location":"build/cli/quick-start/#next-steps","title":"Next Steps","text":"<p>Congratulations on completing the Ceramic Quickstart tutorial! </p> <ul> <li>Complete the ComposeDB Quickstart to try a Ceramic-powered graph database</li> <li>Visit **Next Steps ** for more options</li> </ul>"},{"location":"build/clients/","title":"Clients","text":""},{"location":"build/clients/#types-of-clients","title":"Types of clients","text":""},{"location":"build/clients/#ceramic-clients","title":"Ceramic clients","text":"<p>Ceramic clients are libraries that allow your application to communicate with a Ceramic node. Different clients may choose to implement different high-level, language-specific developer APIs. Before submitting requests to a Ceramic node, clients translate those API calls into the standard Ceramic HTTP API, which it uses to actually communicate with a Ceramic node.</p>"},{"location":"build/clients/#account-clients","title":"Account clients","text":"<p>Account clients are libraries that allow your application to recognize users, authenticate, and perform other account-related functionality such as signing transactions and encrypting data.</p>"},{"location":"build/clients/#available-clients","title":"Available clients","text":"<p>When building with Ceramic clients instead of using a framework, be sure to install both a Ceramic client and an account client.</p>"},{"location":"build/clients/#js-ceramic-http-client","title":"JS Ceramic HTTP Client \u2192","text":"<p>The Ceramic JS HTTP client is a Ceramic client that can be used in browsers and Node.js environments to connect your application to a Ceramic node. It is actively maintained by 3Box Labs and supports the latest Ceramic features. This is the recommended Ceramic client to build with for most applications.</p>"},{"location":"build/clients/#did-json-rpc-client","title":"DID JSON-RPC Client \u2192","text":"<p>The DID JSON-RPC Client is an account client that provides a simple JS API for interacting with Ceramic accounts. It is actively maintained by 3Box Labs and supports all account types.</p>"},{"location":"build/frameworks/","title":"Frameworks","text":"<p>Frameworks make it easy to build applications on Ceramic by abstracting away much of the complexity and configuration of the underlying Ceramic stack, providing developers with a simple entrypoint into Ceramic development. If you're new to Ceramic, or even if you're experienced, this is the place to start.</p>"},{"location":"build/frameworks/#available-frameworks","title":"Available frameworks","text":""},{"location":"build/frameworks/#selfid-sdk","title":"Self.ID SDK \u2192","text":"<p>Self.ID is a framework for building Ceramic applications with composable, user-centric data. In addition to including a full Ceramic setup for a variety of development environments, Self.ID allows users to authenticate with their existing blockchain wallets and also includes some of the most popular data models giving you out of the box composability with data on the network to bootstrap your application.</p>"},{"location":"build/http/api/","title":"Ceramic HTTP API","text":"<p>The Ceramic HTTP API is the standard lowest-level communication protocol between clients and nodes on the Ceramic network. It allows client applications to manually make REST HTTP requests to a remote Ceramic node to send transactons, retrieve data, and \"pin\" data to make it available.</p> <p>If you are building an application, you will usually interact with Ceramic using a client API, such as the JS HTTP Client, or a framework such as the Self.ID SDK, which includes the JS HTTP client by default.</p>"},{"location":"build/http/api/#when-to-use-the-http-api","title":"When to use the HTTP API","text":"<p>The HTTP API is useful if you have a special use case where you directly want to make manual HTTP requests, or you want to implement an HTTP client in a new language.</p> <p>Gateway mode</p> <p>Some HTTP API methods will not be available if the Ceramic node you are using runs in gateway mode. This option disables writes, which is useful when exposing your node to the internet. API methods that are disabled when running in gateway mode will be clearly marked.</p>"},{"location":"build/http/api/#streams-api","title":"Streams API","text":"<p>The <code>stream</code> endpoint is used to create new streams and load streams from the node using a StreamID or genesis content.</p>"},{"location":"build/http/api/#loading-a-stream","title":"Loading a stream","text":"<p>Load the state of a stream given its StreamID.</p> Request <pre><code>GET /api/v0/streams/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the StreamID of the stream that is being requested.</p> <p>=== \"Response\" The response body contains the following fields:</p> <pre><code>- `streamId` - the StreamID of the requested stream as string\n- `state` - the state of the requested stream as [StreamState](https://developers.ceramic.network/reference/typescript/interfaces/_ceramicnetwork_common.streamstate-1.html){:target=\"_blank\"}\n</code></pre>"},{"location":"build/http/api/#example","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/streams/kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm\n</code></pre> <pre><code>{\n\"streamId\": \"kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm\",\n  \"state\": {\n\"type\": 0,\n    \"content\": {\n\"Ceramic\": \"pottery\"\n},\n    \"metadata\": {\n\"schema\": null,\n      \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [{\n\"cid\": \"bagcqceramof2xi7kh6qblirzkbc7yulcjcticlcob6uvdrx3bexgks37ilva\",\n      \"type\": 0\n}],\n    \"anchorScheduledFor\": \"12/15/2020, 2:45:00 PM\"\n}\n}\n</code></pre>"},{"location":"build/http/api/#creating-a-stream","title":"Creating a Stream","text":"<p> Disabled in gateway mode</p> <p>Create a new stream, or load a stream from its genesis content. The genesis content may be signed (e.g. DagJWS for the TileDocument StreamType), or unsigned in some cases.</p> RequestResponse <pre><code>POST /api/v0/streams\n</code></pre> <p>The response body contains the following fields:</p> <ul> <li><code>streamId</code> - the StreamID of the requested stream as string</li> <li><code>state</code> - the state of the requested stream as StreamState</li> </ul>"},{"location":"build/http/api/#request-body-fields","title":"Request body fields:","text":"<ul> <li><code>type</code> - the type code of the StreamType to use (e.g. <code>0</code> for TileDocuments). Type codes for the supported stream types can be found in this table.</li> <li><code>genesis</code> - the genesis content of the stream (will differ per StreamType)</li> <li><code>opts</code> - options for the stream creation, CreateOpts (optional)</li> </ul>"},{"location":"build/http/api/#example_1","title":"Example","text":"<p>This example creates a <code>TileDocument</code> from an unsigned genesis commit. Note that if the content is defined for a <code>TileDocument</code> genesis commit, it needs to be signed.</p> RequestResponse <pre><code>curl http://localhost:7007/api/v0/streams -X POST -d '{\n    \"type\": 0,\n    \"genesis\": {\n      \"header\": {\n        \"family\": \"test\",\n        \"controllers\": [\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"]\n      }\n    }\n  }' -H \"Content-Type: application/json\"\n</code></pre> <pre><code>{\n\"streamId\": \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\",\n  \"state\": {\n\"type\": 0,\n    \"content\": {},\n    \"metadata\": {\n\"family\": \"test\",\n      \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n    \"signature\": 0,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n{\n\"cid\": \"bafyreihtdxfb6cpcvomm2c2elm3re2onqaix6frq4nbg45eaqszh5mifre\",\n        \"type\": 0\n}\n],\n    \"anchorScheduledFor\": \"12/15/2020, 3:00:00 PM\"\n}\n}\n</code></pre>"},{"location":"build/http/api/#multiqueries-api","title":"Multiqueries API","text":"<p>The <code>multiqueries</code> endpoint enables querying multiple streams at once, as well as querying streams which are linked.</p>"},{"location":"build/http/api/#querying-multiple-streams","title":"Querying multiple streams","text":"<p>This endpoint allows you to query multiple StreamIDs. Along with each StreamID an array of paths can be passed. If any of the paths within the stream structure contains a Ceramic StreamID url (<code>ceramic://&lt;StreamID&gt;</code>), this linked stream will also be returned as part of the response.</p> RequestResponse <pre><code>POST /api/v0/multiqueries\n</code></pre> <p>The response body contains a map from StreamID strings to StreamState objects.</p>"},{"location":"build/http/api/#request-body-fields_1","title":"Request body fields:","text":"<ul> <li><code>queries</code> - an array of MultiQuery objects</li> </ul>"},{"location":"build/http/api/#example_2","title":"Example","text":"<p>First let's create three streams to query using the ceramic cli:</p> Request1Response1Request2Response2Request3Response3 <pre><code>ceramic create tile --content '{ \"Document\": \"A\" }'\n</code></pre> <pre><code>StreamID(kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc)\n{\n\"Document\": \"A\"\n}\n</code></pre> <pre><code>ceramic create tile --content '{ \"Document\": \"B\" }'\n</code></pre> <pre><code>StreamID(kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0)\n{\n\"Document\": \"B\"\n}\n</code></pre> <pre><code>ceramic create tile --content '{\n    \"Document\": \"C\",\n    \"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\"\n}'\n</code></pre> <pre><code>StreamID(kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl)\n{\n\"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\",\n  \"Document\": \"C\"\n}\n</code></pre> <p>Now let's query them though the multiqueries endpoint:</p> RequestResponse <pre><code>curl http://localhost:7007/api/v0/multiqueries -X POST -d '{\n  \"queries\": [{\n    \"streamId\": \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\",\n    \"paths\": [\"link\"]\n  }, {\n    \"streamId\": \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\",\n    \"paths\": []\n  }]\n}' -H \"Content-Type: application/json\"\n</code></pre> <pre><code>{\n\"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\": {\n\"type\": 0,\n    \"content\": {\n\"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\",\n      \"Document\": \"C\"\n},\n    \"metadata\": {\n\"schema\": null,\n      \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n{\n\"cid\": \"bagcqcera5nx45nccxvjjyxsq3so5po77kpqzbfsydy6yflnkt6p5tnjvhbkq\",\n        \"type\": 0\n}\n],\n    \"anchorScheduledFor\": \"12/30/2020, 1:45:00 PM\"\n},\n  \"kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\": {\n\"type\": 0,\n    \"content\": {\n\"Document\": \"A\"\n},\n    \"metadata\": {\n\"schema\": null,\n      \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n{\n\"cid\": \"bagcqcerawq5h7otlkdwuai7vhogqhs2aeaauwbu2aqclrh4iyu5h54qqogma\",\n        \"type\": 0\n}\n],\n    \"anchorScheduledFor\": \"12/30/2020, 1:45:00 PM\"\n},\n  \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\": {\n\"type\": 0,\n    \"content\": {\n\"Document\": \"B\"\n},\n    \"metadata\": {\n\"schema\": null,\n      \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n{\n\"cid\": \"bagcqceranecdjzw4xheudgkr2amjkntpktci2xv44d7v4hbft3ndpptid6ka\",\n        \"type\": 0\n}\n],\n    \"anchorScheduledFor\": \"12/30/2020, 1:45:00 PM\"\n}\n}\n</code></pre>"},{"location":"build/http/api/#commits-api","title":"Commits API","text":"<p>The <code>commits</code> endpoint provides lower level access to the data structure of a Ceramic stream. It is also the enpoint that is used in order to update a stream, by adding a new commit.</p>"},{"location":"build/http/api/#getting-all-commits-in-a-stream","title":"Getting all commits in a stream","text":"<p>By calling GET on the commits endpoint along with a StreamID gives you access to all of the commits of the given stream. This is useful if you want to inspect the stream history, or apply all of the commits to a Ceramic node that is not connected to the network.</p> RequestResponse <pre><code>GET /api/v0/commits/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p> <ul> <li><code>streamId</code> - the StreamID of the requested stream, string</li> <li><code>commits</code> - an array of commit objects</li> </ul>"},{"location":"build/http/api/#example_3","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/commits/kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\n</code></pre> <pre><code>{\n\"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\",\n  \"commits\": [\n{\n\"cid\": \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\",\n      \"value\": {\n\"jws\": {\n\"payload\": \"AXESIAsUBpZMnue1yQ0BgXsjOFyN0cHq6AgspXnI7qGB54ux\",\n          \"signatures\": [\n{\n\"signature\": \"16tBnfkXQU0yo-RZvfjWhm7pP-hIxJ5m-FIMHlCrRkpjbleoEcaC80Xt7qs_WZOlOCexznjow9aX4aZe51cYCQ\",\n              \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\"\n}\n],\n          \"link\": \"bafyreialcqdjmte64624sdibqf5sgoc4rxi4d2xibawkk6oi52qydz4lwe\"\n},\n        \"linkedBlock\": \"o2RkYXRhoWV0aXRsZXFNeSBmaXJzdCBEb2N1bWVudGZoZWFkZXKiZnNjaGVtYfZrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SGZ1bmlxdWVwenh0b1A5blphdVgxcEE0OQ\"\n}\n},\n    {\n\"cid\": \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\",\n      \"value\": {\n\"jws\": {\n\"payload\": \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\",\n          \"signatures\": [\n{\n\"signature\": \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\",\n              \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\"\n}\n],\n          \"link\": \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\"\n},\n        \"linkedBlock\": \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\"\n}\n}\n]\n}\n</code></pre>"},{"location":"build/http/api/#applying-a-new-commit-to-stream","title":"Applying a new commit to stream","text":"<p> Disabled in gateway mode</p> <p>In order to modify a stream we apply a commit to its log. This commit usually contains a signature over a json-patch diff describing a modification to the stream contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification. Different stream types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDocument.</p> RequestResponse <pre><code>POST /api/v0/commits\n</code></pre> <ul> <li><code>streamId</code> - the StreamID of the stream that was modified</li> <li><code>state</code> - the new state of the stream that was modified, StreamState</li> </ul>"},{"location":"build/http/api/#request-body-fields_2","title":"Request body fields:","text":"<ul> <li><code>streamId</code> - the StreamID of the stream to apply the commit to, string</li> <li><code>commit</code> - the content of the commit to apply (will differ per streamtype)</li> <li><code>opts</code> - options for the stream update UpdateOpts (optional)</li> </ul>"},{"location":"build/http/api/#example_4","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/commits -X POST -d '{\n  \"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\",\n  \"commit\": {\n    \"jws\": {\n      \"payload\": \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\",\n      \"signatures\": [\n        {\n          \"signature\": \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\",\n          \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\"\n        }\n      ],\n      \"link\": \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\"\n    },\n    \"linkedBlock\": \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\"\n  }\n}' -H \"Content-Type: application/json\"\n</code></pre> <pre><code>{\n\"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\",\n  \"state\": {\n\"type\": 0,\n    \"content\": {\n\"title\": \"My first Document\"\n},\n    \"metadata\": {\n\"schema\": null,\n      \"controllers\": [\n\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n]\n},\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n{\n\"cid\": \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\",\n        \"type\": 0\n},\n      {\n\"cid\": \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\",\n        \"type\": 1\n}\n],\n    \"anchorScheduledFor\": \"12/30/2020, 1:15:00 PM\",\n    \"next\": {\n\"content\": {\n\"title\": \"My first Document\",\n        \"more\": 234\n},\n      \"metadata\": {\n\"schema\": null,\n        \"controllers\": []\n}\n}\n}\n}\n</code></pre>"},{"location":"build/http/api/#pins-api","title":"Pins API","text":"<p>The <code>pins</code> api endpoint can be used to manipulate the pinset. The pinset is all of the streams that a node maintains the state of. Any stream opened by the node that is not pinned will eventually be garbage collected from the node.</p>"},{"location":"build/http/api/#adding-to-pinset","title":"Adding to pinset","text":"<p> Disabled in gateway mode</p> <p>This method adds the stream with the given StreamID to the pinset.</p> RequestResponse <pre><code>POST /api/v0/pins/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p> <p>If the operation was sucessful the response will be a 200 OK.</p> <ul> <li><code>streamId</code> - the StreamID of the stream which was pinned, string</li> </ul>"},{"location":"build/http/api/#example_5","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X POST\n</code></pre> <pre><code>{\n\"streamId\": \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\"\n}\n</code></pre>"},{"location":"build/http/api/#removing-from-pinset","title":"Removing from pinset","text":"<p> Disabled in gateway mode</p> <p>This method removes the stream with the given StreamID from the pinset.</p> RequestResponse <pre><code>DELETE /api/v0/pins/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p> <p>If the operation was sucessful the response will be a 200 OK.</p> <ul> <li><code>streamId</code> - the StreamID of the stream which was unpinned, string</li> </ul>"},{"location":"build/http/api/#example_6","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X DELETE\n</code></pre> <pre><code>{\n\"streamId\": \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\"\n}\n</code></pre>"},{"location":"build/http/api/#listing-streams-in-pinset","title":"Listing streams in pinset","text":"<p>Calling this method allows you to list all of the streams that are in the pinset on this node.</p> RequestResponse <pre><code>GET /api/v0/pins\n</code></pre> <ul> <li><code>pinnedStreamIds</code> - an array of StreamID strings that are in the pinset</li> </ul>"},{"location":"build/http/api/#example_7","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/pins\n</code></pre> <pre><code>{\n\"pinnedStreamIds\": [\n\"k2t6wyfsu4pfwqaju0w9nmi53zo6f5bcier7vc951x4b9rydv6t8q4pvzd5w3l\",\n    \"k2t6wyfsu4pfxon8reod8xcyka9bujeg7acpz8hgh0jsyc7p2b334izdyzsdp7\",\n    \"k2t6wyfsu4pfxqseec01fnqywmn8l93p4g2chzyx3sod3hpyovurye9hskcegs\",\n    \"k2t6wyfsu4pfya9y0ega1vnokf0g5qaus69basy52oxg50y3l35vm9rqbb88t3\"\n]\n}\n</code></pre>"},{"location":"build/http/api/#checking-inclusion-in-pinset","title":"Checking inclusion in pinset","text":"<p>This method is used to check if a particular stream is in the pinset.</p> RequestResponse <pre><code>GET /api/v0/pins/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p> <ul> <li><code>pinnedStreamIds</code> - an array containing the specified StreamID string if that stream is pinned, or an empty array if that stream is not pinned</li> </ul>"},{"location":"build/http/api/#example_8","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\n</code></pre> <pre><code>{\n\"pinnedStreamIds\": [\"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\"]\n}\n</code></pre>"},{"location":"build/http/api/#node-info-apis","title":"Node Info APIs","text":"<p>The methods under the <code>/node</code> path provides more information about this particular node.</p>"},{"location":"build/http/api/#supported-blockchains-for-anchoring","title":"Supported blockchains for anchoring","text":"<p>Get all of the CAIP-2 chainIds supported by this node.</p> RequestResponse <pre><code>GET /api/v0/node/chains\n</code></pre> <p>The response body contains the following fields:</p> <ul> <li><code>supportedChains</code> - and array with CAIP-2 formatted chainIds</li> </ul>"},{"location":"build/http/api/#example_9","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/node/chains\n</code></pre> <pre><code>{\n\"supportedChains\": [\"eip155:3\"]\n}\n</code></pre>"},{"location":"build/http/api/#health-check","title":"Health check","text":"<p>Check the health of the node and the machine it's running on. Run <code>ceramic daemon -h</code> for more details on how this can be configured.</p> RequestResponse <pre><code>GET /api/v0/node/healthcheck\n</code></pre> <p>Either a <code>200</code> response with the text <code>Alive!</code>, or a <code>503</code> with the text <code>Insufficient resources</code>.</p>"},{"location":"build/http/api/#example_10","title":"Example","text":"RequestResponse <pre><code>curl http://localhost:7007/api/v0/node/healthcheck\n</code></pre> <pre><code>Alive!\n</code></pre>"},{"location":"build/http/api/#node-status","title":"Node status","text":"<p>The node status endpoint exposes information about the node's status.</p> <p> Admin DID required</p> <p>Access to this endpoint is restricted to admin DIDs, the request headers need to contain a signature for the request. The recommended way to interact with this endpoint is using the CLI with the <code>ceramic status</code> command.</p> RequestResponse <pre><code>GET /api/v0/admin/status\n</code></pre> <p>Either a <code>200</code> response with the JSON payload, or a server error.</p>"},{"location":"build/http/api/#example_11","title":"Example","text":"CommandResponse <pre><code>ceramic status\n</code></pre> <pre><code>{\n\"runId\": \"7647439f-44fa-4aff-b3c8-b7e16015c52e\",\n\"uptimeMs\": 27638,\n\"network\": \"inmemory\",\n\"anchor\": {\n\"anchorServiceUrl\": \"&lt;inmemory&gt;\",\n\"ethereumRpcEndpoint\": null,\n\"chainId\": \"inmemory:12345\"\n},\n\"ipfs\": {\n\"peerId\": \"12D3KooWRzv8fM4oV6jRj8nsg8kxo3Z9u26vVXLaUKiLbuoV3Vtp\",\n\"addresses\": [\n\"/ip4/127.0.0.1/tcp/4011/p2p/12D3KooWRzv8fM4oV6jRj8nsg8kxo3Z9u26vVXLaUKiLbuoV3Vtp\",\n\"/ip4/192.168.0.101/tcp/4011/p2p/12D3KooWRzv8fM4oV6jRj8nsg8kxo3Z9u26vVXLaUKiLbuoV3Vtp\"\n]\n},\n\"composeDB\": {\n\"indexedModels\": []\n}\n}\n</code></pre>"},{"location":"build/javascript/authentication/","title":"Authentication","text":"<p>This guide will help you set up authentication so your users can perform writes. Authentication is not needed if you are only querying streams.</p>"},{"location":"build/javascript/authentication/#requirements","title":"Requirements","text":"<p>Authentication requires having installed a Ceramic client. Your client should include the DID Resolver(s) for the DID method(s) you will use for authentication.</p>"},{"location":"build/javascript/authentication/#1-choose-a-did-method","title":"1. Choose a DID method","text":"<p>The first step in adding authentication to your project is choosing which DID method to use for authentication.</p> <p>PKH DID Method: A DID method that natively supports blockchain accounts, default usage with did-session allows capabality and session usage.</p> <p>3ID DID Method: A powerful DID method that supports multiple keys, key rotations, and revocations</p> <p>Key DID Method: A lightweight DID method that only supports one key and cannot handle rotations</p> <p>NFT DID Method: A lightweight DID method with permissions that change based on on-chain NFT asset ownership</p> <p>Safe DID Method coming soon: A lightweight DID method with permissions that change based on on-chain Gnosis Safe contract permissions</p> <p>It is recommended that most applications use the PKH DID Method with DID Session.</p>"},{"location":"build/javascript/authentication/#2-install-a-did-provider","title":"2. Install a DID Provider","text":"<p>After choosing a DID method, install a DID provider for that method.</p>"},{"location":"build/javascript/authentication/#pkh-did-providers","title":"PKH DID Providers","text":""},{"location":"build/javascript/authentication/#did-session","title":"DID Session","text":"<p>DID Session is the most popular DID Provider for Ceramic web apps. DID-Session allows developers to use capabilities to permission and manage sessions for a users blockchain account (PKH DID). Sessions allow users to only sign with their blockchain wallets once and then continue to sign Ceramic transactions in their browser for the duration of the session. </p> <p> Installation</p> <p>Recommended for most browser applications.</p>"},{"location":"build/javascript/authentication/#3id-did-providers","title":"3ID DID Providers","text":""},{"location":"build/javascript/authentication/#3id-connect","title":"3ID Connect","text":"<p>3ID Connect SDK allows users to authenticate a 3ID DID using their existing blockchain wallets without needing to install any additional software. Developers do not need to worry about DID key management for their users. For most use cases it is now suggested to use did-session over 3id-connect. </p> <p> Installation</p>"},{"location":"build/javascript/authentication/#3id-did-provider","title":"3ID DID Provider","text":"<p>3ID DID Provider is a low-level JavaScript 3ID DID Provider. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret.</p> <p> Installation</p>"},{"location":"build/javascript/authentication/#key-did-providers","title":"Key DID Providers","text":""},{"location":"build/javascript/authentication/#key-did-provider-ed25519","title":"Key DID Provider Ed25519","text":"<p>Key DID Provider Ed25519 is a low-level JavaScript Key DID Provider for use with <code>Ed25519</code> key pairs. Your application is responsible for key managemet, and users need to authenticate with a DID seed.</p> <p> Installation</p>"},{"location":"build/javascript/http/","title":"Installing the JS HTTP Client","text":"<p>This guide descibes how to install the JS HTTP Client so your JavaScript application can perform writes, queries, or pins on a remote Ceramic node during runtime.</p>"},{"location":"build/javascript/http/#requirements","title":"Requirements","text":"<p>Installing the JS HTTP Client requires a console, Node.js v16, and npm v8. Make sure to have these installed on your machine.</p>"},{"location":"build/javascript/http/#1-install-the-http-client","title":"1. Install the HTTP client","text":"<p>Open your console and install the JS HTTP Client using npm.</p> <pre><code>npm install @ceramicnetwork/http-client\n</code></pre>"},{"location":"build/javascript/http/#2-import-the-http-client","title":"2. Import the HTTP client","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\n</code></pre>"},{"location":"build/javascript/http/#3-configure-your-node-url","title":"3. Configure your node URL","text":"<pre><code>const API_URL = 'https://yourceramicnode.com'\n</code></pre> <p>Available options for your node setup:</p> <ul> <li>Commercial node providers: Discover paid node providers</li> <li>Host your own node: Learn how to setup and host your own node</li> <li>localhost: You may want to use the JS HTTP Client with a Ceramic node running on your local machine for development and testing. To achieve this, first start a local daemon by installing the CLI. Once the CLI is installed, you can pass <code>https://localhost:7007</code> to the HTTP client. This setup will allow you to read streams from other nodes connected on the Ceramic network as well as to publish writes from your local node to the rest of the network.</li> </ul>"},{"location":"build/javascript/http/#4-create-a-ceramic-instance","title":"4. Create a Ceramic instance","text":"<pre><code>const ceramic = new CeramicClient(API_URL)\n</code></pre>"},{"location":"build/javascript/http/#5-import-did-resolvers","title":"5. Import DID resolvers","text":"<p>Import the DID resolvers for all DID methods that will need to authenticate to perform writes using this HTTP Client. If your HTTP Client will only perform queries, then jump ahead to the queries page.</p> <pre><code>import KeyDidResolver from 'key-did-resolver'\nimport ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'\n</code></pre>"},{"location":"build/javascript/http/#6-create-a-did-instance","title":"6. Create a DID instance","text":"<p>Create a DID instance which wraps an instance of a DID resolver that includes all individual DID resolvers from the previous step. It should also include a DID Provider for the DID Method you are using for authentication.</p> <pre><code>import { DID } from 'dids'\nconst resolver = {\n...KeyDidResolver.getResolver(),\n...ThreeIdResolver.getResolver(ceramic),\n}\nconst did = new DID({ resolver })\n</code></pre>"},{"location":"build/javascript/http/#7-set-did-instance-on-http-client","title":"7. Set DID instance on HTTP client","text":"<pre><code>ceramic.did = did\n</code></pre>"},{"location":"build/javascript/http/#examples","title":"Examples","text":"<p>Once you have completed installing and configuring the HTTP Client, your project's setup should look something like this.</p>"},{"location":"build/javascript/http/#write-and-read","title":"Write and read","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport KeyDidResolver from 'key-did-resolver'\nimport ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'\nimport { DID } from 'dids'\nconst API_URL = 'https://yourceramicnode.com'\nconst ceramic = new CeramicClient(API_URL)\nconst resolver = {\n...KeyDidResolver.getResolver(),\n...ThreeIdResolver.getResolver(ceramic),\n}\nconst did = new DID({ resolver })\nceramic.did = did\n</code></pre>"},{"location":"build/javascript/http/#read-only","title":"Read-only","text":"<pre><code>import CeramicClient from '@ceramicnetwork/http-client'\nconst API_URL = 'https://yourceramicnode.com'\nconst ceramic = new CeramicClient(API_URL)\n</code></pre>"},{"location":"build/javascript/http/#next-steps","title":"Next steps","text":"<p>If your application needs to perform writes, proceed to setting up authentication. If your app only needs to perform queries, then jump ahead to queries.</p>"},{"location":"build/javascript/installation/","title":"Choose a JS client","text":"<p>This page describes the Ceramic clients available to use in your JavaScript project. After choosing either the JS HTTP Client or the JS Core Client, follow its installation instructions.  </p>"},{"location":"build/javascript/installation/#js-http-client","title":"JS HTTP Client","text":"<p>The JS HTTP Client is a lightweight way of interacting with Ceramic. It allows your JavaScript application to connect to a remote Ceramic node over HTTP to read, write, and pin streams. The main decision to make when using the JS HTTP Client is which remote Ceramic node to use.</p> <p> Installation</p> <p>The JS HTTP client is recommended when building most applications.</p>"},{"location":"build/javascript/installation/#considerations","title":"Considerations","text":"<p>Improved performance: When using the JS HTTP Client, stream processing and validation happens on a remote Ceramic node running on a server, which usually results in improved performance compared to running the full protocol with the JS Core Client.</p> <p>Predictable data availability: Streams created using the JS HTTP Client can be pinned and made available on a remote Ceramic node which has high uptime and predictable data availability guarantees.</p> <p>Some trust in a remote node: Stream processing and state validation happens on a remote node which the JS HTTP Client trusts. However, it is important to note that user's keys always live client-side and all updates are signed on the JS HTTP Client and then sent to the HTTP endpoint for processing.</p> <p>Swap for the JS Core Client at anytime: The JS HTTP Client and the JS Core Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup.</p>"},{"location":"build/javascript/installation/#js-core-client","title":"JS Core Client","text":"<p>The JS Core Client allows you to run the full Ceramic protocol (client and node) directly in JavaScript environments such as in your tests or in node.js. Most applications instead use the JS HTTP Client.</p>"},{"location":"build/javascript/installation/#considerations_1","title":"Considerations","text":"<p>Maximal security and decentralization: The Ceramic Core client does not have trusted relationships with any external nodes. With Ceramic Core, streams that are written, queried, or pinned are verified in the local environment which is great if you need maximal security and decentralization in your application.</p> <p>Transitory data availability: Streams created with Ceramic Core will only be available on the network as long as this node remains online. For more resilient data availability you can always replicate and pin streams on secondary long-running nodes, or instead use the JS HTTP Client which relies on a remote node more likely to always be online.</p> <p>Setup complexity: You will need to configure an IPFS node which supports the dag-jose data format and ensure connectivity to the rest of the Ceramic network.</p> <p>Swap for JS HTTP Client at any time: The JS Core Client and the JS HTTP Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup.</p>"},{"location":"build/javascript/pinning/","title":"Pinning","text":"<p>Pinning allows you to persist and make streams available on a Ceramic node beyond a single session. This guide demonstrates how to add and remove streams from your node's pinset, and how to list the streams currently in the pinset. In order to interact with a pinset, you must have installed a Ceramic client.</p>"},{"location":"build/javascript/pinning/#overview","title":"Overview","text":"<p>By default Ceramic will garbage collect any stream that has been written or queried on your node after some period of time. In order to prevent the loss of streams due to garbage collection, you need to explicitly pin the streams that you wish to persist. Pinning instructs the node to keep them around in persistent storage until they are explicitly unpinned. To learn more about Ceramic's data persistence and availability model, see Data Availability.</p>"},{"location":"build/javascript/pinning/#pin-a-stream-while-creating-it","title":"Pin a stream while creating it","text":"<p>Most StreamTypes will allow you to request that a Stream be pinned at the same time that you create the Stream. An example using the TileDocument Streamtype is below:</p> <p><pre><code>await TileDocument.create(ceramic, content, null, { pin: true })\n</code></pre>  API reference</p>"},{"location":"build/javascript/pinning/#add-to-pinset","title":"Add to pinset","text":"<p>Use the <code>pin.add()</code> method to add an existing stream to your permanent pinset.</p> <pre><code>const streamId = 'kjzl6cwe1jw14...'\nawait ceramic.pin.add(streamId)\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/pinning/#remove-from-pinset","title":"Remove from pinset","text":"<p>Use the <code>pin.rm()</code> method to remove a stream from your permanent pinset.</p> <pre><code>const streamId = 'kjzl6cwe1jw14...'\nawait ceramic.pin.rm(streamId)\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/pinning/#list-streams-in-pinset","title":"List streams in pinset","text":"<p>Use the <code>pin.ls()</code> method to list streams currently in your permanent pinset.</p> <pre><code>const streamIds = await ceramic.pin.ls()\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/queries/","title":"Queries","text":"<p>This guide demonstrates how to query streams during runtime using the JS HTTP and JS Core clients.</p>"},{"location":"build/javascript/queries/#requirements","title":"Requirements","text":"<p>You need to have an installed client to perform queries during runtime.</p>"},{"location":"build/javascript/queries/#query-a-stream","title":"Query a stream","text":"<p>Use the <code>loadStream()</code> method to load a single stream using its StreamID.</p> <pre><code>const streamId = 'kjzl6cwe1jw14...'\nconst stream = await ceramic.loadStream(streamId)\n</code></pre> <p>Loading the proper stream type</p> <p>When using the Typescript APIs, <code>loadStream</code> by default returns an object of type <code>Stream</code>, which will not have any methods available to perform updates, or any other streamtype-specific methods or accessors.  To be able to perform updates, as well as to access streamtype-specific data or functionality, you need to specialize the <code>loadStream</code> method on the StreamType of the Stream being loaded. For example, to load a <code>TileDocument</code>, you would say <code>await ceramic.loadStream&lt;TileDocument&gt;(streamId)</code></p> <p> API reference</p>"},{"location":"build/javascript/queries/#query-a-stream-at-a-specific-commit","title":"Query a stream at a specific commit","text":"<p>If you want to see the contents of a stream as of a specific point in time, it's possible to pass a CommitID instead of a StreamID to the <code>loadStream()</code> method described above. This will cause the Stream to be loaded at the specified commit, rather than the current commit as loaded from the network. When loading with a CommitID, the returned Stream object will be marked as readonly and cannot be used to perform updates. If you wish to perform updates, load a new instance of the Stream using its StreamID.</p>"},{"location":"build/javascript/queries/#query-multiple-streams","title":"Query multiple streams","text":"<p>Use the <code>multiQuery()</code> method to load multiple streams at once. The returned object is a map from StreamIDs to stream instances.</p> <pre><code>const queries = [\n{\nstreamId: 'kjzl6cwe1jw...14',\n},\n{\nstreamId: 'kjzl6cwe1jw...15',\n},\n]\nconst streamMap = await ceramic.multiQuery(queries)\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/queries/#query-a-stream-using-paths","title":"Query a stream using paths","text":"<p>Use the <code>multiQuery()</code> method to load one or more streams using known paths from a root stream to its linked streams.</p> <p>Imagine a stream <code>kjzl6cwe1jw...14</code> whose content contains the StreamIDs of two other streams. These StreamIDs exist at various levels within a nested JSON structure.</p> <pre><code>{\na: 'kjzl6cwe1jw...15',\nb: {\nc: 'kjzl6cwe1jw...16'\n}\n}\n</code></pre> <p>In the stream above, the path from root stream <code>kjzl6cwe1jw...14</code> to linked stream <code>kjzl6cwe1jw...15</code> is <code>/a</code> and the path to linked stream <code>kjzl6cwe1jw...16</code> is <code>/b/c</code>. Using the StreamID of the root stream and the paths outlined here, we use <code>multiQuery()</code> to query all three streams at once without needing to explicitly know the StreamIDs of the two linked streams.</p> <p>The <code>multiQuery()</code> below will return a map with all three streams.</p> <pre><code>const queries = [{\nstreamId: 'kjzl6cwe1jw...14'\npaths: ['/a', '/b/c']\n}]\nconst streamMap = await ceramic.multiQuery(queries)\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/queries/#helper-methods","title":"Helper methods","text":"<p>To get specific information about the stream that you created or loaded you can use the accessors on the <code>Stream</code> class. Below are some examples.</p> <p> API reference</p>"},{"location":"build/javascript/queries/#get-streamid","title":"Get StreamID","text":"<p>Use the <code>stream.id</code> property to get the unique <code>StreamID</code> for this stream.</p> <pre><code>const streamId = stream.id\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/queries/#get-latest-commit","title":"Get latest commit","text":"<p>Use the <code>stream.commitId</code> property to get latest CommitID of a stream.</p> <pre><code>const commitId = stream.commitId\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/queries/#get-all-anchor-commits","title":"Get all anchor commits","text":"<p>Use the <code>stream.anchorCommitIds</code> property to get all CommitIDs which are anchor commits for this stream.</p> <pre><code>const anchorCommits = stream.anchorCommitIds\n</code></pre> <p> API reference</p>"},{"location":"build/javascript/quick-start/","title":"Quickstart","text":"<p>Learn the basics by setting up and interacting with the Ceramic Javascript Client.</p> <p>Want an even faster way to try Ceramic? Visit the Playground Demo App to test the full stack of Ceramic components in the browser.</p>"},{"location":"build/javascript/quick-start/#1-install-the-client","title":"1. Install the Client","text":"<p>Authentication</p> <p> If you're using this quickstart anywhere but the Ceramic Playground you'll need to authenticate your Ceramic instance. This is a process that's dependent on your setup so we recommend taking a look at our authentication section to ensure you don't have any issues following along.</p> <p>Visit the Ceramic Client page for instructions on how to quickly install the Client.</p>"},{"location":"build/javascript/quick-start/#2-create-a-stream","title":"2. Create a stream","text":"<p>Creating streams is dependent on the StreamType. More details can be found in our StreamTypes Overview. A basic sample using the TileDocument StreamType can be found below.</p> CommandOutput <pre><code>import { TileDocument } from '@ceramicnetwork/stream-tile'\n\nconst doc = await TileDocument.create(ceramic, {hello: 'world'})\n\nconsole.log(doc.content)\n\nconst streamId = doc.id.toString()\n</code></pre> <pre><code>{\nhello: 'world'\n}\n</code></pre>"},{"location":"build/javascript/quick-start/#3-query-a-stream","title":"3. Query a stream","text":"<p>Use the <code>load()</code> function to query the current state of a stream. You will need to provide it's StreamID.</p> CommandOutput <pre><code>const streamId = \"kjzl...g8qa\"\nconst doc = await TileDocument.load(ceramic, streamId)\n\nconsole.log(doc.content)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"build/javascript/quick-start/#4-update-a-stream","title":"4. Update a stream","text":"<p>Use the <code>update</code> command to update a stream. your DID must be in the controller of the stream in order to update it.</p> Command <pre><code>const streamId = \"kjzl...g8qa\"\nconst doc = await TileDocument.load(ceramic, streamId)\n\nawait doc.update(newContent, newMeta)\n</code></pre> <p>In the following example we update a TileDocuments' content while also giving it a tag.</p> Command <pre><code>const streamId = \"kjzl...g8qa\"\nconst doc = await TileDocument.load(ceramic, streamId)\n\nawait doc.update({foo: 'baz'}, {tags: ['baz']})\n</code></pre>"},{"location":"build/javascript/quick-start/#5-create-a-schema","title":"5. Create a schema","text":"<p>TileDocuments can enforce that their contents adhere to a specified schema. The schemas themselves are TileDocuments where the content is a json-schema. For example we can create a schema that requires a TileDocument to have a title and a message.</p> Command <pre><code>const schema = {\n\"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\"title\": \"Reward\",\n\"type\": \"object\",\n\"properties\": {\n\"title\": { \"type\": \"string\" },\n\"message\": { \"type\": \"string\" }\n},\n\"required\": [\n\"message\",\n\"title\"\n]\n}\nconst metadata = {\ncontrollers: [ceramic.did.id] // this will set yourself as the controller of the schema\n}\nconst rewardSchema = await TileDocument.create(ceramic, schema, metadata)\n</code></pre>"},{"location":"build/javascript/quick-start/#6-create-a-tiledocument-stream-that-uses-a-schema","title":"6. Create a TileDocument stream that uses a schema","text":"<p>First, use the <code>rewardSchema.commitId.toString()</code> to get the current CommitID of the schema stream. When creating a TileDocument that uses this schema you need to use a CommitID instead of the StreamID. This is to enforce that we are using a specific version of the schema since the schema stream is mutable and can be updated.</p> Command <pre><code>  const reward = await TileDocument.create(ceramic, {\ntitle: 'Hello',\nmessage: 'world!'\n}, {\ncontrollers: [ceramic.did.id],\nfamily: 'Rewards',\nschema: rewardSchema.commitId.toString(),\n})\n</code></pre>"},{"location":"build/javascript/quick-start/#7-inspect-the-state-of-the-stream-you-created","title":"7. Inspect the state of the stream you created","text":"<p>Use <code>reward.state</code> to query the state of the TileDocument we just created. We can see that the schema is set to the correct CommitID.</p> CommandOutput <pre><code>  console.log(reward.state)\n</code></pre> <pre><code>{\nanchorStatus: 1,\ncontent: {\nmessage: \"world!\",\ntitle: \"Hello\"\n},\nmetadata:{\ncontrollers: [\n\"did:3:kjzl...mr5y\",\n]\nfamily: \"Rewards\"\nschema: \"k3y5...50jk\"\nunique: \"/mNCNLFt+1a0nqgL\"\n}\n}\n</code></pre>"},{"location":"build/javascript/quick-start/#thats-it","title":"That's it!","text":"<p>Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project or take a look at Self.ID, a framework for interacting with Streams.</p>"},{"location":"build/javascript/writes/","title":"Writes","text":"<p>Writes are interactions that write to streams, such as creating new streams or updating existing streams. You need an installed client and an authenticated user to perform writes.</p>"},{"location":"build/javascript/writes/#usage","title":"Usage","text":"<p>Write operations are StreamType specific. The APIs for performing writes are contained within the various Stream implementations. See StreamTypes for information on how to perform writes for each of the supported StreamTypes.</p>"},{"location":"build/middleware/","title":"Middleware","text":"<p>Middleware is a generic name for all kinds of development tools that are not a part of the core Ceramic clients, but provide developers with additional functionality and convenience. Middleware requires separately installing a Ceramic client, so they are lower-level than frameworks.</p>"},{"location":"build/middleware/#available-middleware","title":"Available middleware","text":""},{"location":"build/middleware/#glaze-suite","title":"Glaze suite \u2192","text":"<p>Glaze suite includes a collection of data model management tools, runtime tools for account-based storage and retrieval, and client-side tools for caching data from the network.</p>"},{"location":"docs/advanced/indexing/","title":"Indexing Ceramic","text":"<pre><code>- Indexes:\n  - Indexing Patterns: index.md\n  - Indexing Strategies: index.md\n  - Account-centric indexing:\n  - Application-Centric Indexing: index.md\n  - Network-Wide Indexing: index.md\n</code></pre>"},{"location":"docs/advanced/privacy-and-access-control/","title":"Privacy and Access Control","text":""},{"location":"docs/advanced/storage-and-backup/","title":"Storage and Backup","text":"<ul> <li>Caching: index.md</li> <li>Hosting: index.md</li> <li>Archiving: index.md</li> <li>FAQ Ceramic Storage: index.md</li> </ul>"},{"location":"docs/advanced/standards/","title":"Ceramic Development Standards","text":""},{"location":"docs/advanced/standards/#standards-overview","title":"Standards Overview","text":"<p>The Ethereum community has adopted many standards that help keep projects (such as Ethereum clients and wallets) interoperable across implementations, and ensure smart contracts and dapps remain composable.</p> <p>Typically standards are introduced as Ethereum Improvement Proposals (EIPs), which are discussed by community members through a standard process.</p> <ul> <li>Introduction to EIPs</li> <li>List of EIPs</li> <li>EIP github repo</li> <li>EIP discussion board</li> <li>Ethereum Governance Overview March 31, 2019 - Boris Mann</li> <li>Ethereum Protocol Development Governance and Network Upgrade Coordination March 23, 2020 - Hudson Jameson</li> <li>Playlist of all Ethereum Core Dev Meetings (YouTube Playlist)</li> </ul>"},{"location":"docs/advanced/standards/#types-of-standards","title":"Types of standards","text":"<p>Certain EIPs relate to application-level standards (e.g. a standard smart-contract format), which are introduced as Ethereum Requests for Comment (ERC). Many ERCs are critical standards used widely across the Ethereum ecosystem.</p> <ul> <li>List of ERCs</li> </ul>"},{"location":"docs/advanced/standards/#stream-program-standards","title":"Stream program standards","text":"<ul> <li>ERC-20 - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>ERC-721 - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>ERC-777 - A token standard improving over ERC-20.</li> <li>ERC-1155 - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>"},{"location":"docs/advanced/standards/#application-standards","title":"Application standards","text":"<ul> <li>ERC-20 - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>ERC-721 - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>ERC-777 - A token standard improving over ERC-20.</li> <li>ERC-1155 - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>"},{"location":"docs/advanced/standards/#data-model-standards","title":"Data model standards","text":"<ul> <li>ERC-20 - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>ERC-721 - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>ERC-777 - A token standard improving over ERC-20.</li> <li>ERC-1155 - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>"},{"location":"docs/advanced/standards/#account-standards","title":"Account standards","text":"<ul> <li>3ID DID - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>PKH DID - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>KEY DID - A token standard improving over ERC-20.</li> <li>NFT DID - A token standard which can contain both fungible and non-fungible assets.</li> <li>Safe DID - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>"},{"location":"docs/advanced/standards/#further-reading","title":"Further reading","text":"<p>Know of a community resource that helped you? Edit this page and add it!</p>"},{"location":"docs/advanced/standards/accounts/","title":"Ceramic Accounts","text":"<p>Ceramic uses the Decentralized Identifier (DID) standard for user accounts. Decentralized identifiers provide an abstraction from individual cryptographic accounts, such as blockchain accounts, enabling cross-chain interoperability and multi-account to identity support.</p>"},{"location":"docs/advanced/standards/accounts/#supported-account-types","title":"Supported account types","text":"<p>Below find the decentralized identifier (DID) standards currently supported as user accounts on Ceramic:</p> NAME DESCRIPTION Status DID PKH (CIP-79) A Ceramic account that natively supports blockchain accounts, default usage with did-session allows capabality and session usage \u2705 Production Key DID A Ceramic account that can only be associated with one wallet, which can never be changed \u2705 Production 3ID DID (CIP-79) A Ceramic-native account that supports mutations in the DID Document, enabling the association of multiple wallets to the account \u26d4\ufe0f Deprecated NFT DID (CIP-94) A Ceramic account that can be controlled by the current owner of a given NFT (non-fungible token) \u26a0\ufe0f Experimental Safe DID (CIP-101) A Ceramic account that can be controlled by the current members of a Gnosis Safe smart contract \u26a0\ufe0f Experimental"},{"location":"docs/advanced/standards/accounts/#building-with-accounts","title":"Building with accounts","text":"<p>In order for users to perform transactions on Ceramic they need an account. Your application can control which accounts it supports.</p> <ul> <li>When building with a Ceramic client, you should install and configure the DID JSON-RPC client, which will instruct you how to add support for various account types.</li> <li>When building with a framework such as the Self.ID SDK, you don't need to worry about accounts, it will use DID PKH with DID Session.</li> </ul>"},{"location":"docs/advanced/standards/accounts/3id-did/","title":"3ID DID Accounts","text":"<p>\u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f The 3ID DID Method has been deprecated. Please use DID PKH using DID Session! \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f</p> <p>The 3ID DID Method (CIP-79) is a Ceramic-native account which can be used to authenticate to Ceramic to perform transactions on streams. </p>"},{"location":"docs/advanced/standards/accounts/3id-did/#what-is-a-3id-account","title":"What is a 3ID account?","text":"<p>3ID DID is a powerful DID method that supports multiple keys, key rotations, and revocations. The 3ID DID Method is on the W3C's official DID method registry and is fully compliant with decentralized identity standards.</p> <ul> <li>Multiple keys, secure rotations: The DID Document for the 3ID DID Method is implemented using a Ceramic Tile Document, making it fully mutable and able to support the secure addition and removal (rotation) of keys. This enables 3ID DIDs to handle multiple keys simultaneously and to remove keys when needed.</li> <li>Support for blockchain wallets: When 3ID DIDs are used in conjunction with the Identity Index protocol (CIP-11) (using the 3ID Keychain definition (CIP-20)), a 3ID DID can be controlled from a user's existing blockchain wallets. This functionality is implemented by 3ID Connect.</li> <li>Aggregated identities: 3ID DIDs can serve as a cross-chain identifier which can be controlled by all of a user's blockchain and Web3 accounts from any L1 or L2 protocol. This provides a way to unify a user's identity across all other platforms.</li> <li>Great for end users: Due to all of the reasons above.</li> </ul>"},{"location":"docs/advanced/standards/accounts/3id-did/#specification","title":"Specification","text":"<p>3ID DIDs are fully implemented on top of Ceramic. For the full specification, see 3ID DID Method (CIP-79).</p>"},{"location":"docs/advanced/standards/accounts/3id-did/#account-identifier","title":"Account identifier","text":"<pre><code>did:3:&lt;StreamID of the TileDocument storing the DID Document&gt;\n</code></pre>"},{"location":"docs/advanced/standards/accounts/3id-did/#did-document","title":"DID Document","text":"<p>3ID offers a mutable DID document which can be used to securely set, remove, and rotate keys. This DID document is stored as a stream on Ceramic using the TileDocument StreamType.</p>"},{"location":"docs/advanced/standards/accounts/3id-did/#building-with-3id-did","title":"Building with 3ID DID","text":"<p>To use 3ID DIDs for user accounts in your project, install one of the 3ID DID Providers below:</p>"},{"location":"docs/advanced/standards/accounts/3id-did/#install-3id-connect","title":"Install 3ID Connect \u2192","text":"<p>Recommended. 3ID Connect is the most popular 3ID DID Provider for Ceramic web apps. The 3ID Connect SDK allows users to control their 3ID DID from their existing blockchain wallets without needing to install any additional wallet software. Developers do not need to worry about DID key management for their users.</p>"},{"location":"docs/advanced/standards/accounts/3id-did/#install-3id-did-provider","title":"Install 3ID DID Provider \u2192","text":"<p>A low-level JavaScript 3ID DID Provider. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret.</p>"},{"location":"docs/advanced/standards/accounts/3id-did/#install-did-resolver","title":"Install DID Resolver \u2192","text":"<p>3ID DID Resolver is a JavaScript DID resolver for the 3ID DID Method. It uses Ceramic to resolve DID documents.</p>"},{"location":"docs/advanced/standards/accounts/3id-did/#additional-reading","title":"Additional reading","text":"<ul> <li>3ID DID Method specification</li> <li>W3C DID specification</li> <li>TileDocument StreamType</li> </ul>"},{"location":"docs/advanced/standards/accounts/key-did/","title":"Key DID Accounts","text":"<p>The Key DID Method is an account which can be used to authenticate to Ceramic to perform transactions on streams. </p>"},{"location":"docs/advanced/standards/accounts/key-did/#what-is-a-key-account","title":"What is a Key account?","text":"<p>The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. Key DID is on the W3C's official DID method registry and is fully compliant with decentralized identity standards. Carefully read the considerations below before deciding to use the Key DID Method in your project.</p> <ul> <li>One key only: The DID Document for a Key DID is explicitly tied to a single crypto key. It can not support multiple keys in the DID document nor can it support key rotation, which means only one key can ever control the DID and it can never be changed in case it is compromised.</li> <li>For advanced users: For the reasons above, the Key DID Method is only suitable for advanced users who will only want to ever use one keypair to control their DID, and who have strong key security practices - such as a developer - and so generally will not be appropriate for identities for non-technical end users.</li> </ul>"},{"location":"docs/advanced/standards/accounts/key-did/#specification","title":"Specification","text":"<p>For the full specification, see Key DID Method specification \u2192.</p>"},{"location":"docs/advanced/standards/accounts/key-did/#account-identifier","title":"Account identifier","text":"<p>The DID string for the Key DID Method simply encodes the public key. Example Key DID identifier:</p> <pre><code>did:key:&lt;public-key&gt;\n</code></pre>"},{"location":"docs/advanced/standards/accounts/key-did/#did-document","title":"DID Document","text":"<p>Key DID offers an immutable DID document that is statically generated from any cryptographic key pair. The DID document is not actually stored anywhere since it can always be regenerated from the key pair.</p>"},{"location":"docs/advanced/standards/accounts/key-did/#building-with-key-did","title":"Building with Key DID","text":"<p>To use Key DIDs for user accounts in your project, install one of the Key DID Providers below:</p>"},{"location":"docs/advanced/standards/accounts/key-did/#install-key-did-provider-ed25519","title":"Install Key DID Provider Ed25519 \u2192","text":"<p>A low-level JavaScript Key DID Provider for use with Ed25519 key pairs. Your application is responsible for key managemet, and users need to authenticate with a DID seed.</p>"},{"location":"docs/advanced/standards/accounts/key-did/#install-key-did-resolver","title":"Install Key DID Resolver \u2192","text":"<p>The Key DID Resolver is a JavaScript DID resolver for the Key DID Method.</p>"},{"location":"docs/advanced/standards/accounts/key-did/#additional-reading","title":"Additional reading","text":"<ul> <li>W3C DID specification</li> <li>did:key specification</li> </ul>"},{"location":"docs/advanced/standards/accounts/nft-did/","title":"NFT DID Accounts","text":"<p>The NFT DID Method (CIP-94) is an account that can perform transactions on streams. NFT DID accounts are controlled by the current owner of an NFT (non-fungible token). NFT DIDs are still very experimental, so use at your own risk.</p>"},{"location":"docs/advanced/standards/accounts/nft-did/#nft-did-is-experimental-and-not-recommended-for-production-use","title":"\u26a0\ufe0f NFT DID is experimental and not recommended for production use.","text":"<p>The current implementation requires the current holder of an NFT with a corresponding did:nft to trust all previous holders of the NFT not to override the content of Ceramic streams controlled by the did:nft</p> <p>Please reach out on our forum to provide feedback or get help. </p>"},{"location":"docs/advanced/standards/accounts/nft-did/#what-is-an-nft-account","title":"What is an NFT account?","text":"<p>The NFT DID Method turns every NFT into an account capable of controlling streams on Ceramic. Write permissions for streams whose controller is set to an NFT DID are restricted to the DID account of the blockchain account that currently owns the NFT. When the NFT changes ownership on-chain, so do the Ceramic write permissions. NFT DID is on the W3C's official DID method registry and is fully compliant with decentralized identity standards.</p>"},{"location":"docs/advanced/standards/accounts/nft-did/#example-use-cases-for-nft-accounts","title":"Example use cases for NFT accounts","text":"<ul> <li>Extensible, mutable NFT metadata \u2013 NFTs currently have fixed metadata that is created when the token is minted. But what if we want an NFT to be able to collect data over time? With NFT DID, an NFT owner can annotate an NFT with additional information that is modified over time, such as a social graph for the NFT, a story behind the artefact, owner-restricted content, or, for example, carbon offsetting certificate.</li> </ul>"},{"location":"docs/advanced/standards/accounts/nft-did/#how-to-use-nft-accounts","title":"How to use NFT accounts","text":""},{"location":"docs/advanced/standards/accounts/nft-did/#installation","title":"Installation","text":"<p>To use an NFT for dynamic stream access control, include the nft-did-resolver in your Ceramic node. </p>"},{"location":"docs/advanced/standards/accounts/nft-did/#usage","title":"Usage","text":"<p>To create an NFT-controlled stream, set your stream controller to <code>did:nft:...</code> when creating it. Here's an example that creates a Tile Document controlled by an NFT:</p> <pre><code>const didNFT =\n\"did:nft:eip155:4_erc721:0xe2a6a2da2408e1c944c045162852ef2056e235ab_1\";\nconst tile = await TileDocument.create(ceramic, {foo: \"blah\"}, {controllers: [didNFT]})\n</code></pre> <ul> <li>The address of the NFT must be lowercase</li> <li>The <code>didNFT</code> string is a DID URI that references ERC721 token <code>1</code> on contract <code>0xe2a6a2da2408e1c944c045162852ef2056e235ab</code> deployed to Rinkeby (<code>eip155:4</code>). This should reference your NFT.</li> <li>We provide a helper function <code>createNftDidUrl</code> to create such a string:</li> </ul> <pre><code>import { createNftDidUrl } from 'nft-did-resolver'\n// \"did:nft:eip155:4_erc721:0xe2a6a2da2408e1c944c045162852ef2056e235ab_1\"\nconst didNFT = createNftDidUrl({\nchainId: 'eip155:1',\nnamespace: 'erc721',\ncontract: '0x1234567891234567891234567891234596351156',\ntokenId: '1',\n})\n</code></pre> <p>Now the Tile Document we have just created can only be controlled by the NFT's current owner.</p>"},{"location":"docs/advanced/standards/accounts/nft-did/#how-it-works","title":"How it works","text":"<p>When resolving an NFT DID account, Ceramic and the did-nft-resolver perform the following steps:</p> <ol> <li>Query a blockchain for the NFT's owner(s) using a subgraph on The Graph protocol. </li> <li>For each owner, find a corresponding CAIP-10 Link (CIP-7), which provides a link from blockchain account to Ceramic account. This determines who can write to the stream.</li> <li>When a transaction is sent to the stream owned by the NFT,  verify the Ceramic account that signed the message is linked to the blockchain account that is a current owner.</li> </ol> <p></p> <p>Note: If you wish to build with NFT accounts, you need to ensure your users can generate CAIP-10 Links to connect their blockchain account(s) to their Ceramic account. If you're using 3ID Connect, this is handled automatically by the wallet when signing in.</p> <p>Ensure 3ID Connect is on the same Ceramic network as your application. If those networks are different it will create a mismatch in Ceramic acounts that are linked to the same blockchain account (on testnet <code>0xethereum</code>\u2192DID-A, on devnet for the same account <code>0xethereum</code>\u2192DID-B).  Please make sure that the DID from a CAIP-10 Link  from your app corresponds to the DID you get from 3ID Connect.</p>"},{"location":"docs/advanced/standards/accounts/nft-did/#current-limitations","title":"Current limitations","text":"<ul> <li>Only ERC-721 and ERC-1155 tokens are supported at this time.</li> <li>Only Ethereum Rinkeby, Etherem mainnet, and Polygon networks are supported by default. If you need other networks, see the nft-did-resolver README, and update network parameters and configuration of your Ceramic node. Notable, this config needs three additional subgraphs: for blocks, for ERC-721 and ERC-1155 tokens, and a \"skew\", which is a typical block time.</li> </ul> <p>Data from a subgraph might lag behing the current state found on the blockchain network. For example, if Etherscan reports the latest block number as 1000, a subgraph might still index block number 995. This could result in an error like <code>\"invalid_jws: not a valid verificationMethod for issuer\"</code>. If this occurs, make sure to repeat the transaction after some time, enough for the subgraph to catch up with the blockchain. In general, it is best practice to accommodate for this delay in your application.</p>"},{"location":"docs/advanced/standards/accounts/nft-did/#specification","title":"Specification","text":"<p>Read the NFT DID Method (CIP-94) Specification for the full specificatoin.</p>"},{"location":"docs/advanced/standards/accounts/pkh-did/","title":"PKH DID Accounts","text":"<p>A Ceramic account that natively supports blockchain accounts. Default usage with did-session allows capabality and session usage, unlocking a powerful auth model with blockchain accounts. </p>"},{"location":"docs/advanced/standards/accounts/pkh-did/#what-is-a-pkh-did-account","title":"What is a PKH DID account?","text":"<p>A PKH DID account allows interoperability between blockchain accounts and DIDs, allowing a user to directly use their blockchain account as a DID based account to sign, authorize and authenticate. A PKH DID account is entirely controlled by the relating blockchain account, key rotations, changes, deactivation, etc are not supported. </p>"},{"location":"docs/advanced/standards/accounts/pkh-did/#specification","title":"Specification","text":"<p>For the full specification, see PKH DID Method specification \u2192.</p>"},{"location":"docs/advanced/standards/accounts/pkh-did/#account-identifier","title":"Account identifier","text":"<pre><code>did:pkh:&lt;CAIP-10&gt;\n\n//With CAIP-10 expansion\ndid:pkh:&lt;chain_id&gt;:&lt;account_adress&gt;\n</code></pre>"},{"location":"docs/advanced/standards/accounts/pkh-did/#did-document","title":"DID Document","text":"<p>PKH DID documents are deterministically generated from their relating blockchain/CAIP-10 account. </p>"},{"location":"docs/advanced/standards/accounts/pkh-did/#building-with-pkh-did","title":"Building with PKH DID","text":"<p>To use PKH DIDs for user accounts in your project, install one of the PKH DID Providers below:</p>"},{"location":"docs/advanced/standards/accounts/pkh-did/#install-did-session","title":"Install DID Session \u2192","text":"<p>Recommended. DID-Session is the most popular DID Provider for Ceramic web apps. DID-Session allows developers to use capabilities to permission and manage sessions for a users blockchain account (PKH DID). Sessions allow users to only sign with their blockchain wallets once and then continue to sign Ceramic transactions in their browser for the duration of the session. If you're using the Self.ID SDK, you don't need to worry about installing DID Session, it already includes it.</p>"},{"location":"docs/advanced/standards/accounts/pkh-did/#install-did-resolver","title":"Install DID Resolver \u2192","text":"<p>PKH DID Resolver is a JavaScript DID resolver for the PKH DID Method.</p>"},{"location":"docs/advanced/standards/accounts/pkh-did/#additional-reading","title":"Additional reading","text":"<ul> <li>CAIP-10 Account Specification</li> </ul>"},{"location":"docs/advanced/standards/accounts/safe-did/","title":"Gnosis Safe DID Accounts","text":"<p>The Gnosis Safe DID Method (CIP-101) is an account that can perform transactions on streams. Safe DID accounts are controlled by the current members of a Gnosis Safe smart contract. Safe DID is on the W3C's official DID method registry and is fully compliant with decentralized identity standards, however they are still highly experimental, so use at your own risk.</p>"},{"location":"docs/advanced/standards/accounts/safe-did/#safe-did-is-experimental-and-not-recommended-for-production-use","title":"\u26a0\ufe0f Safe DID is experimental and not recommended for production use.","text":"<p>The current implementation requires the current members of a Gnosis Safe with a corresponding did:safe to trust all current and previous members of the Gnosis Safe not to override the content of Ceramic streams controlled by the did:safe.</p> <p>Please reach out on our forum to provide feedback or get help. </p>"},{"location":"docs/advanced/standards/accounts/safe-did/#what-is-a-safe-account","title":"What is a Safe account?","text":"<p>The Safe DID Method turns every Gnosis Safe contract into a Ceramic account capable of sending transactions to streams on Ceramic. It is similar in design and usage to the NFT DID account method. </p> <p>Write permissions for streams whose controller is set to a Safe DID are restricted to the DIDs of the blockchain accounts that control the Gnosis Safe contract. When Gnosis Safe controller permissions change on-chain, so do the write permissions to streams owned by the Safe. </p>"},{"location":"docs/advanced/standards/accounts/safe-did/#specification","title":"Specification","text":"<p>Read the Safe DID Method (CIP-101) Specification for the full specification.</p> <p>This page is a stub. We're working on adding more content to help you build with Safe DIDs.</p>"},{"location":"docs/advanced/standards/application-protocols/","title":"Application protocol standards","text":""},{"location":"docs/advanced/standards/application-protocols/identity-index/","title":"Account-Based Stream Index","text":"<p>CIP-11 \"Identity Index\" (commonly called \"IDX\") is a decentralized identity protocol which make it easy for developers to build applications with user-controlled streams for storing data, as well as to discover and make use of user data created on third-party applications. Building with IDX allows users to control their identities and data in a manner independent from any single application, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application.</p> <p>This page mentions that IDX is intended for storing \"user\" data as that is its primary use case. However IDX can be used for storing data for other types of subjects represented by DIDs such as businesses, organizations, applications, assets (NFTs), or devices (IoT).</p>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#overview","title":"Overview","text":"<p>DID-compatibility: IDX does not provide DIDs, but relies on them for decentralized, platform-agnostic identifiers. IDX can work with any DID method that is supported in Ceramic. Various DID methods, such as 3ID, support linking to and authenticating with many different blockchain accounts (see 3ID Keychain (CIP-20)). This allows DIDs to serve as a universal, cross-chain and platform-agnostic identifier for users.</p> <p>Stream-based storage: Store data for your users or your application in user-controlled streams on Ceramic. Data in streams can be stored in cleartext or encrypted. IDX-created streams enjoy all the benefits of mutability, persistence, replication, and availability provided by the Ceramic network.</p> <p>Identity hubs: Whenever a user stores data in a new stream via IDX, its streamID is automatically registered in their index, which is a separate stream that serves as a single catalog of references to all their data. The index enables all data associations for the user to exist in one place, which in turn enables any application to discover all data about the user by simply querying their index.</p> <p>Public, semantic data descriptions: All data stored via IDX is semantically described and organized in the user's index, allowing multiple applications to make use of the same data based on schemas and metadata instead of which application the user was using when they first created the data.</p> <p>Cross-application data portability: The combination of DIDs, streams, hubs, and semantic data descriptions allows user data to be stored in an application-agnostic manner and can be used across different applications or interfaces. No application maintains \"special permissions\" since users are in full control.</p> <p>Standard interfaces: IDX provides standardized read/write APIs for interacting with all data so applications aren't ever forced to integrate one-off APIs.</p> <p>Built on open standards: IDX builds on open standards for decentralized identity shepherded by the Ceramic community via CIPs, and other related identity communities such as W3C and the Decentralized Identity Foundation (DIF).</p>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#protocol-design","title":"Protocol design","text":"<p>Dive into the design and architecture of the IDX protocol, which is implemented by DID DataStore.</p> <p></p>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#index","title":"Index","text":"<p>The index is a stream controlled by the user's DID which stores entries consisting of definition (represented by a streamID) to record (represented by a streamID) mappings. Every DID has only one global index and its entries represent the entire catalog of data that belongs to the user. An index is similar to a row in a user table, and enables the decentralized association and discovery of streams that belong to a user.</p> <p>Example:</p> <pre><code>{\n\"kyz123...456\": \"ceramic://kyz789...012\",\n\"kyz345...678\": \"ceramic://kyz901...234\",\n\"kyz567...890\": \"ceramic://kyz123...456\",\n\"kyz789...012\": \"ceramic://kyz345...678\"\n}\n</code></pre>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#definitions","title":"Definitions","text":"<p>Definitions are streams created by application developers that store metadata which describes the stream used for data storage. Definitions allow records to be semantically described and queried using their metadata or schema and are similar to a column in a user table. The streamID of the definition is a key in the index.</p> <p>Example:</p> <pre><code>{\nname: 'Basic Profile',\ndescription: 'A simple basic profile.',\nschema: 'ceramic://kyz123...456'\n}\n</code></pre>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#schemas","title":"Schemas","text":"<p>Schemas are streams created by application developers that store a JSON schema. They specify the data schema of a record. Schemas are identified by the streamID of the stream that stores the schema, which is included in the definition as seen above.</p>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#records","title":"Records","text":"<p>Records are streams that store information for a DID. They can directly store content, or they can store foreign key references to external datastores outside of Ceramic. A record is similar to a cell in a user table. The streamID of the record is a value in the index.</p> <p>Example:</p> <pre><code>{\nname: 'Alan Turing',\ndescription: 'I make computers beep good.',\nemoji: '\ud83d\udcbb'\n}\n</code></pre>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#how-it-works","title":"How it works","text":""},{"location":"docs/advanced/standards/application-protocols/identity-index/#storing-data-with-idx","title":"Storing data with IDX","text":"<ol> <li>Application developer creates stream that contains a JSON schema.</li> <li>Application developer creates a stream that contains a definition and includes the StreamID of the stream containing the schema.</li> <li>User creates a record (a stream) that conforms to the definition as they interact with an application.</li> <li>IDX automatically adds the definition streamID and the record streamID as an entry in the user's index.</li> </ol>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#reading-data-from-idx","title":"Reading data from IDX","text":"<ol> <li>Application queries a user's index by passing the user's DID and the streamID of a definition. Before performing this action, an application can query the user's entire index to see which definitions they have.</li> <li>Application gets back the record that corresponds to the definition.</li> </ol>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#use-cases","title":"Use-cases","text":"<p>Authentication secrets: 3ID Connect uses IDX to create a DID-controlled stream which stores encrypted authentication secrets that allows a 3ID DID to be authenticated with various blockchain wallets. To achieve this, the 3ID Connect team has created the 3ID Keychain definition (CIP-20).</p> <p>Profile information: DNS.xyz uses IDX to create a DID-controlled stream which stores basic profile information for the DID. To achieve this, the DNS.xyz team uses the Basic Profile definition (CIP-19).</p> <p>Web2 social account links: Self.ID uses IDX to create a DID-controlled stream which stores a list of Web2 accounts controlled by the same user that owns the DID, along with verifiable claims which prove this ownership. To achieve this, the Self.ID team has created the Also Known As (AKA) definition (CIP-23).</p> <p>Web3 Crypto account links: 3ID Connect uses IDX to create a DID-controlled stream which stores a list of streamIDs for CAIP10Links that publicly prove the owner of this DID also owns various accounts on Web3/blockchain platforms. To achieve this, the 3ID Connect team has created the Crypto Accounts definition (CIP-21).</p>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#implementations","title":"Implementations","text":"<ul> <li>The DID DataStore library is a low-level implementation of the IDX protocol for runtime interactions.</li> <li>The Self.ID SDK uses the DID DataStore library to provide runtime support for the IDX protocol, with additional features.</li> </ul>"},{"location":"docs/advanced/standards/application-protocols/identity-index/#learn-more","title":"Learn more","text":"<ul> <li>Full Identity Index (IDX) protocol specification (CIP-11)</li> </ul>"},{"location":"docs/advanced/standards/data-models/","title":"Data models","text":"<p>Data models are collections of one or more streams, specified by their schemas and definitions, that comprise a single higher-order data structure on Ceramic. Typically, data models are used to represent an application feature such as blog posts, a social graph, or a user profile. Most Ceramic applications are built with more than one data model.</p> <p>Data models are open standards created by the community that form the basis of data composability on Ceramic. When multiple applications reuse the same data model, they get access to the same data.</p>"},{"location":"docs/advanced/standards/data-models/#building-with-data-models","title":"Building with data models","text":""},{"location":"docs/advanced/standards/data-models/#data-models-registry","title":"Data Models Registry \u2192","text":"<p>The Data Models Registry is home to the data models that developers wish to make available for reuse. We recommend starting there to discover which data models are available to use when building. Using data models from the registry promotes data composability by giving your application access to existing data on the network and helps avoid unnecessarily creating new data models.</p>"},{"location":"docs/advanced/standards/data-models/#creating-new-data-models","title":"Creating new data models","text":"<p>If none of the data models in the Data Models Registry suit your needs, you can create new data models using one of the methods below. After creating your data models, we recommend submitting them to the registry to enable reuse by others.</p> <ul> <li>Manually create data models using the Glaze CLI</li> <li>Programmatically create data models using Glaze DevTools</li> </ul>"},{"location":"docs/advanced/standards/data-models/cip-19/","title":"CIP-19 Basic Profile","text":""},{"location":"docs/advanced/standards/data-models/data-model-universe/","title":"Data Models Registry","text":"<p>The Data Models Registry \u2192 is home to all of the data models that have been created by other developers in the Ceramic community which you can reuse when building your application. Using data models from the registry promotes data composability by giving your application access to existing data on the network and helps avoid unnecessarily creating new data models.</p>"},{"location":"docs/advanced/standards/data-models/data-model-universe/#available-data-models","title":"Available data models","text":"<p>Visit the Data Models Registry \u2192 for a full list of available data models. Although we cannot list every data model in the registry, here is a sampling of what can be found there:</p> Data model Description Maintainer <code>identity-profile-basic</code> Stores a user's profile 3Box Labs <code>identity-accounts-web</code> Stores verifiable credentials that link a user's Web2 accounts to their Ceramic account 3Box Labs <code>identity-accounts-crypto</code> Stores a list of CAIP-10 Links that link a user's Web3 accounts to their Ceramic account 3Box Labs <code>social-connections</code> Stores a user's social graph CyberConnect"},{"location":"docs/advanced/standards/data-models/data-model-universe/#adding-your-models-to-the-registry","title":"Adding your models to the registry","text":"<p>If none of the data models in the Data Models Registry suit your needs, you can create new data models using the Glaze CLI or the Glaze DevTools library. After creating your data models, you can submit them to the registry!</p>"},{"location":"docs/advanced/standards/stream-programs/","title":"Streams","text":"<p>Streams are individual instances of state on the Ceramic network. Every stream is mutable and can only be modified when it receives a transaction signed by the account that owns it.</p>"},{"location":"docs/advanced/standards/stream-programs/#how-streams-work","title":"How streams work","text":""},{"location":"docs/advanced/standards/stream-programs/#stream-identifiers","title":"Stream identifiers","text":"<p>Every stream is identified by its <code>streamID</code>, which is its unique address on the Ceramic network. When applications load a stream from the network using its streamID, its current state is returned. Alternative, applications can load a previous version of a stream's state by using the <code>commitID</code> of the specific version wanted.</p>"},{"location":"docs/advanced/standards/stream-programs/#streamcode","title":"Streamcode","text":"<p>Every stream that is created on Ceramic must reference a <code>streamcode</code> in its metadata, which is a script that contains the processing logic used to transform a stream's current state into the next state upon receipt of a new transaction. In general, you can think of streamcode as reusable state processing logic and streams as the individual states it generates.</p> <p>Today Ceramic supports two types of streams: tile documents which store mutable JSON documents with schema validation, and CAIP-10 links which store a link between a Web3 wallet account and a Ceramic account.</p>"},{"location":"docs/advanced/standards/stream-programs/#metadata","title":"Metadata","text":"<p>Every stream can specify a few metadata properties:</p> Metadata property Required? Description <code>streamtype</code> Yes The streamcode used by the stream <code>controller</code> Yes The Ceramic account (DID) that can modify the stream <code>schema</code> No The schema for the stream <code>family</code> No Used to associate collections of streams <code>tags</code> No Used to create subgroupings of streams"},{"location":"docs/advanced/standards/stream-programs/#content","title":"Content","text":"<p>The type of content that a stream can store is determined by its streamcode.</p>"},{"location":"docs/advanced/standards/stream-programs/#building-with-streams","title":"Building with streams","text":""},{"location":"docs/advanced/standards/stream-programs/#store-json-content","title":"Store JSON content \u2192","text":"<p>Tile Document (CIP-8) is streamcode that stores a mutable JSON document with schema validation, providing similar functionality as a NoSQL document.</p>"},{"location":"docs/advanced/standards/stream-programs/#store-blockchain-account-links","title":"Store blockchain account links \u2192","text":"<p>CAIP-10 Link (CIP-7) is streamcode that stores a link between a Web3 wallet account and a Ceramic account.</p>"},{"location":"docs/advanced/standards/stream-programs/#new-streamcode","title":"New streamcode","text":"<p>Ceramic does not yet suport the arbitrary creation of new streamcode. If you'd like to create new streamcode to support additional use cases for streams, reach out on the Ceramic Discord.</p>"},{"location":"docs/advanced/standards/stream-programs/caip10-link/","title":"CAIP-10 Link (CIP-7)","text":"<p>CAIP-10 Link (CIP-7) is streamcode that stores a link between a Web3 wallet account and a Ceramic account.</p>"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#about-caip-10-link","title":"About CAIP-10 Link","text":""},{"location":"docs/advanced/standards/stream-programs/caip10-link/#features","title":"Features","text":"<ul> <li>Chain-agnostic \u2013 CAIP-10 Link leverages the Chain Agnostic Improvement Proposal (CAIP) 10 standard to represent blockchain accounts from a variety of blockchain networks</li> <li>One-way links \u2013 Links are one way only: from a blockchain account to a Ceramic account (DID). It is not possible to go from a Ceramic account to a blockchain account using only CAIP-10 Links. However, this can be achieved by using the <code>identity-accounts-crypto</code> data model which stores a list of CAIP-10 links owned by a Ceramic account.</li> <li>Multi-account \u2013 A Ceramic account (DID) can have an unlimited number of CAIP-10 Links that publicly bind it to many different addresses on many different L1 and L2 blockchain networks.</li> </ul>"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#structure","title":"Structure","text":"<ul> <li>Content \u2013 The content of a CAIP-10 Link can only store the <code>string</code> value of a Ceramic account (DID) or <code>null</code> if no DID is linked. Internally, the commits in the CAIP-10 Link contain a signed link proof.</li> <li>Metadata \u2013 The metadata of a CAIP-10 Link is defined by the standard and is not editable by consumers. It contains the blockchain account (CAIP-10 string) as the only entry in <code>controllers</code> and adds the chainID as in <code>family</code>.</li> </ul>"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#getting-started-with-caip-10-links","title":"Getting started with CAIP-10 Links","text":""},{"location":"docs/advanced/standards/stream-programs/caip10-link/#available-implementations","title":"Available implementations","text":"<p>Visit the JavaScript CAIP-10 Link implementation to create and load CAIP-10 Links within your application. Alternatively if you use 3ID Connect for authentication, which comes standard in most Ceramic frameworks such as Self.ID SDK, then it will take care of creating CAIP-10 links for users for you.</p>"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#further-reading","title":"Further reading","text":"<p>Read the CAIP-10 Link (CIP-7) standard for more information about the standard.</p>"},{"location":"docs/advanced/standards/stream-programs/tile-document/","title":"Tile Document (CIP-8)","text":"<p>Tile Document (CIP-8) is streamcode that stores a mutable JSON document with schema validation, providing similar functionality as a NoSQL document.</p>"},{"location":"docs/advanced/standards/stream-programs/tile-document/#about-tile-documents","title":"About Tile Documents","text":""},{"location":"docs/advanced/standards/stream-programs/tile-document/#features","title":"Features","text":"<ul> <li>Mutable JSON Storage \u2013 TileDocuments are used for storing JSON data. Every TileDocument stream is structured as a single log of commits, where each commit only contains the diff from the previous version. </li> <li>JSON Schema \u2013 Optionally, TileDocuments may specify a JSON schema in metadata and all commits must adhere to the schema.</li> <li>Blockchain-based timestamps \u2013 TileDocuments rely on anchor commits for providing immutable timestamps for the genesis commit and subsequent signed commits in the stream. </li> <li>Conflict resolution \u2013 In the case of conflicting versions, the branch with the earliest recorded anchor commit will be respected as the canonical branch.</li> <li>Authentication \u2013 TileDocuments rely on DIDs for authentication. Only the DID assigned as the controller of the stream are allowed to perform writes.</li> <li>Performance \u2013 As more updates are made to a single tile, the underlying DAG grows linearly, and so does sync times when fetching the stream over the network. However, when loading a tile from a node that already has it present, responses are very quick.</li> </ul>"},{"location":"docs/advanced/standards/stream-programs/tile-document/#current-limitations","title":"Current limitations","text":"<ul> <li>Only allows single controller</li> <li>No indexing, but metadata will be used, follow conventions</li> <li>Growing log, not adapted to frequent updates</li> </ul>"},{"location":"docs/advanced/standards/stream-programs/tile-document/#getting-started-with-tile-documents","title":"Getting started with Tile Documents","text":""},{"location":"docs/advanced/standards/stream-programs/tile-document/#available-implementations","title":"Available implementations","text":"<p>Visit the JavaScript TileDocument implementation to create and load TileDocuments within your application.</p>"},{"location":"docs/advanced/standards/stream-programs/tile-document/#tutorials","title":"Tutorials","text":"<p>This guide describes how to create, update, and query TileDocuments using the Ceramic JS HTTP Client and the Core Client. </p>"},{"location":"docs/advanced/standards/stream-programs/tile-document/#further-reading","title":"Further reading","text":"<p>Read the Tile Document (CIP-8) standard for more information about the standard.</p>"},{"location":"docs/ecosystem/community/","title":"Community","text":"<p>Connect, learn, and participate in the Ceramic community.</p>"},{"location":"docs/ecosystem/community/#chat-and-discussion","title":"Chat and Discussion","text":""},{"location":"docs/ecosystem/community/#forum","title":"Forum","text":"<p>Get help, ask questions, and discuss improvements</p>"},{"location":"docs/ecosystem/community/#discord","title":"Discord","text":"<p>Chat with other members of the community</p>"},{"location":"docs/ecosystem/community/#social-media","title":"Social Media","text":""},{"location":"docs/ecosystem/community/#twitter","title":"Twitter","text":"<p>Follow @ceramicnetwork for timely updates</p>"},{"location":"docs/ecosystem/community/#youtube","title":"YouTube","text":"<p>Subscribe to our YouTube channel to watch talks, tutorials, and events</p>"},{"location":"docs/ecosystem/community/#educational-resources","title":"Educational Resources","text":""},{"location":"docs/ecosystem/community/#blog","title":"Blog","text":"<p>Discover updates and educational content for developers</p>"},{"location":"docs/ecosystem/community/#events","title":"Events","text":"<p>We will be resuming community calls and reopening the community calendar in the coming weeks. In the meantime, you can find us at lots of Web3 events such as ETHDenver 2023.</p>"},{"location":"docs/ecosystem/community/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"docs/ecosystem/community/#ecosystem-grants","title":"Ecosystem Grants","text":"<p>If you\u2019re interested in a grant, reach out in the Ceramic Discord #bounties channel. All submissions are welcome.</p>"},{"location":"docs/ecosystem/community/#project-showcase","title":"Project Showcase","text":"<p>Add your project to the Ceramic ecosystem project directory to gain exposure and showoff what you've built. Apply here.</p>"},{"location":"docs/ecosystem/community/#employment-opportunities","title":"Employment Opportunities","text":"<p>If you want to work on Ceramic full-time, apply to work at 3Box Labs.</p>"},{"location":"docs/introduction/next-steps/","title":"Next Steps","text":""},{"location":"docs/introduction/next-steps/#continue-learning","title":"Continue Learning","text":"<ul> <li>Join the Forum to ask questions and get support</li> <li>Join the Discord to chat with the community</li> <li>Read the Ceramic Protocol specification</li> <li>Explore use cases and projects built on Ceramic</li> </ul>"},{"location":"docs/introduction/next-steps/#build-applications","title":"Build Applications","text":""},{"location":"docs/introduction/next-steps/#composedb-graph-db-for-web3-apps","title":"ComposeDB: Graph DB for Web3 Apps \u2192","text":"<p>ComposeDB is a decentralized graph database powered by Ceramic that enables you to build powerful Web3 applications using composable data, GraphQL, and reusable models. ComposeDB is the newest and most popular database built on Ceramic for building Web3 applications.</p>"},{"location":"docs/introduction/next-steps/#run-a-ceramic-node","title":"Run a Ceramic Node","text":"<p>Run a Ceramic node to provide data storage, compute, and bandwidth for your Ceramic application. Today there are no tokenized incentives for running a Ceramic node, but by running a node you can ensure the data for your app remains available while helping contribute to the network's decentralization.</p> <ul> <li>Run Ceramic in the cloud</li> <li>Run Ceramic locally</li> </ul>"},{"location":"explore/explorers/","title":"Explorers","text":"<p>Discover various explorers for the Ceramic Network.</p>"},{"location":"explore/explorers/#cerscan","title":"Cerscan","text":"<p>Cerscan is a community-contributed explorer indexing streams in real-time since June 12, 2022. It includes information on the app and schema of recent streams too. Cur</p>"},{"location":"explore/explorers/#userscan","title":"UserScan","text":"<p>UserScan is an open sourced community-contributed explorer.</p>"},{"location":"explore/explorers/#tiles","title":"Tiles","text":"<p>Tiles is a browser-based explorer where you can see a feed of all streams created on mainnet, and dive into the details of any particular stream.</p> <p></p> <p>Learn more about Tiles and their vision for enabling a world of open, shared data models in the Tiles Spotlight.</p>"},{"location":"explore/projects/","title":"Community projects","text":"<p>This page contains a list of community projects built on Ceramic.</p>"},{"location":"explore/projects/#featured-projects","title":"Featured projects","text":""},{"location":"explore/projects/#boardroom-coming-soon","title":"Boardroom (coming soon)","text":"<p>Governance forums: BoardRoom uses Ceramic, account-based stream indexing, and 3ID Connect to store proposals, comments, votes, and other user-generated content for their decentralized governance application.</p>"},{"location":"explore/projects/#geoweb","title":"GeoWeb","text":"<p>Mutable files for NFTs: GeoWeb is creating a fair and open augmented reality (AR) metaverse where digital land is represented by NFTs and content for the land is represented by one or more streams on Ceramic.</p> <p>Learn more about GeoWeb and how they're using Ceramic in the GeoWeb Spotlight.</p>"},{"location":"explore/projects/#metagame-coming-soon","title":"MetaGame (coming soon)","text":"<p>Multi-app user profiles: MetaGame uses Ceramic, account-based stream indexing, and 3ID Connect to store profile data for Ethereum users that can be consumed, added to, or extended by any app in the Web3 metaverse.</p>"},{"location":"explore/projects/#arcx-coming-soon","title":"ArcX (coming soon)","text":"<p>Decentralized document database: ArcX uses Ceramic to store mutable JSON documents, similar to a NoSQL document store.</p>"},{"location":"explore/projects/#daemonland-coming-soon","title":"Daemon.Land (coming soon)","text":"<p>Multi-app data: Developers on the Daemon.Land platform use Ceramic and account-based stream indexing to store user data, which makes it easy for users and their data to freely travel between different apps built with Daemon.Land.</p>"},{"location":"explore/projects/#rabbithole-coming-soon","title":"RabbitHole (coming soon)","text":"<p>Cross-chain identity and reputation: RabbitHole uses Ceramic, account-based stream indexing, and 3ID Connect to link multiple Web3 wallets and Web2 accounts to a unified, cross-chain DID. After calculating an aggregate reputation score for this DID, they issue and store a verifiable credential in the user's account-based index so it's usable on any other Web3 application.</p>"},{"location":"explore/projects/#the-convo-space-coming-soon","title":"The Convo Space (coming soon)","text":""},{"location":"explore/projects/#dnsxyz-coming-soon","title":"DNS.XYZ (coming soon)","text":"<p>Web3 profiles: DNS.XYZ uses Ceramic and account-based stream indexing to allow users to create and manage a universal multi-account profile for the Web3 metaverse.</p>"},{"location":"explore/projects/#fungyproof-coming-soon","title":"FungyProof (coming soon)","text":"<p>NFT grading and enrichments: FungyProof uses Ceramic to store a cross-chain, aggregate view of NFTs and their associated data including: grade/quality, digital cases, events/press, achievements, and more. NFT Owners can improve their NFTs by adding enrichments and modify the NFTs public profile to highlight the characteristics they choose.</p>"},{"location":"explore/projects/#more-projects","title":"More projects","text":"<p>See Awesome Ceramic for a list of community projects built on Ceramic.</p>"},{"location":"explore/sample-apps/","title":"Sample Apps","text":"<p>This page contains links to simple applications that give you a sense of what's possible with Ceramic.</p>"},{"location":"explore/sample-apps/#playground","title":"Playground","text":"<p>Playground is a minimal browser application that integrates the JS HTTP Client, 3ID Connect, and Glaze libraries.</p>"},{"location":"guides/","title":"Ceramic Development Guides","text":"<p>Guides that support development on Ceramic.</p>"},{"location":"guides/#ceramic-nodes","title":"Ceramic Nodes","text":"<ul> <li>Running Locally</li> <li>Running in the Cloud</li> </ul>"},{"location":"guides/#ceramic-clients","title":"Ceramic Clients","text":"<ul> <li>JavaScript Client</li> <li>Authentication</li> <li>Stream APIs</li> </ul>"},{"location":"guides/#additional-resources","title":"Additional Resources","text":"<ul> <li>Ceramic Forum</li> <li>Ceramic Blog</li> </ul>"},{"location":"learn/blog/","title":"Ceramic Blog","text":"<p>The Ceramic Blog contains news, announcements, videos, as well as helpful tutorials and resources for building with Ceramic. Check it out to get inspired for your next project.</p>"},{"location":"learn/blog/#featured-posts","title":"Featured posts","text":"<p>The next architecture for building Web3 data apps: We're replacing the popular IDX runtime with a more powerful set of tools for building applications on Ceramic including DID DataStore, DataModels, and Self.ID. </p> <p>What is Ceramic: Ceramic is a decentralized content computation network for a world of open source information.</p> <p>How to build a simple notes app with IDX: Learn how to build a simple note taking application where users own their data with IDX and React.</p> <p>How to store signed and encrypted data on IPFS: Learn how to store signed and encrypted data directly in IPFS using two new standards: dag-jose and EIP-2844.</p> <p>Trust minimized off-chain conviction voting: How to implement a conviction voting system using verifiable, off-chain data on Ceramic.</p>"},{"location":"learn/blog/#featured-videos","title":"Featured videos","text":"<p>Learn how to manage user data in a Web3 app with IDX: Learn how to manage user data for your Web3 application with IDX. This talk is a workshop from tthe ETHDenver 2021 hackathon.</p> <p>Standards for encrypted and mutable data on IPFS: Joel talks about new standards for signed, encrypted, mutable data on IPFS. This is a talk from the ETHDenver 2021 hackathon.</p> <p>The evolution of digital identity: Michael talks about the evolution of digital identity from servers, to key pairs, to DIDs and IDX. A presentation from the ETHDever 2021 hackathon.</p>"},{"location":"learn/comparisons/","title":"Comparisons","text":"<p>Ceramic compared to other popular infrastructure solutions.</p>"},{"location":"learn/comparisons/#overview","title":"Overview","text":"Ceramic L2s L1s Web2 DB UX \ud83d\udfe2 \ud83d\udd34 \ud83d\udd34 \ud83d\udfe2 Low Cost \ud83d\udfe2 \ud83d\udfe1 \ud83d\udd34 \ud83d\udfe2 Web Scale \ud83d\udfe2 \ud83d\udfe1 \ud83d\udd34 \ud83d\udfe1 Composability \ud83d\udfe2 \ud83d\udfe1 \ud83d\udfe2 \ud83d\udd34 Verifiability \ud83d\udfe2 \ud83d\udfe2 \ud83d\udfe2 \ud83d\udd34 Permissionless \ud83d\udfe2 \ud83d\udfe2 \ud83d\udfe2 \ud83d\udd34 Designed for... Decentralized data Decentralized finance Decentralized finance Centralized data"},{"location":"learn/features/","title":"Why Ceramic?","text":"<p>Ceramic's decentralized data network provides Web3 developers with a collection of features that make it possible to build scalable Web3 applications with composable data that can be reused and shared across applications.</p>"},{"location":"learn/features/#overview","title":"Overview","text":"<p>Ceramic compared to other popular Web3 infrastructure solutions.</p> Ceramic L2s L1s Web2 DB UX \ud83d\udfe2 \ud83d\udd34 \ud83d\udd34 \ud83d\udfe2 Low Cost \ud83d\udfe2 \ud83d\udfe1 \ud83d\udd34 \ud83d\udfe2 Web Scale \ud83d\udfe2 \ud83d\udfe1 \ud83d\udd34 \ud83d\udfe1 Composability \ud83d\udfe2 \ud83d\udfe1 \ud83d\udfe2 \ud83d\udd34 Verifiability \ud83d\udfe2 \ud83d\udfe2 \ud83d\udfe2 \ud83d\udd34 Permissionless \ud83d\udfe2 \ud83d\udfe2 \ud83d\udfe2 \ud83d\udd34 Designed for... Decentralized data Decentralized finance Decentralized finance Centralized data"},{"location":"learn/features/#key-benefits","title":"Key Benefits","text":""},{"location":"learn/features/#mutable-data-storage","title":"Mutable data storage","text":"<p>Ceramic provides developers with a set of standard, open APIs for storing, updating, and retrieving data from the network. This helps to break down data silos, enabling all data to be openly accessible. Additionally, all data mutations on Ceramic are cryptographically verifiable and can provide auditability throughout all historical versions of a piece of data that has changed over time.</p>"},{"location":"learn/features/#data-composability","title":"Data Composability","text":"<p>Data on Ceramic is structured and stored in data models, which can be easily reused by different applications to share data between them. Data models are created by developers in the community, and the ecosystem of data models is constantly expanding. Data models typically represent a single, logical application feature such as a user profile, a social graph, or a blog and developers typically combine multiple data models to create their application.</p>"},{"location":"learn/features/#developer-experience","title":"Developer Experience","text":"<p>Building composable applications with Web3 data on Ceramic is simple. Install Ceramic, browse the marketplace of data models, plug these models into your app, and automatically get access to all data stored on the network that conforms to those data models. The community is constantly creating new tooling that make it easier to build, and expand what's possible with composable data.</p>"},{"location":"learn/features/#sign-in-with-web3","title":"Sign in with Web3","text":"<p>Ceramic uses the decentralized identifier (DID) standard for user accounts, which are compatible with all blockchain wallets. When using Ceramic in your application, users can authenticate with the Web3 wallets they already have, and can even control the same Ceramic account from multiple different blockchain wallets (cross-chain) if they'd like. Data models are typically account-centric, meaning that every user is in control of their own data.</p>"},{"location":"learn/features/#decentralization","title":"Decentralization","text":"<p>The Ceramic network is decentralized and permissionless, allowing anyone in the world to spin up a node to provide storage, compute, and bandwidth resources to users and applications built on the network. Today there are no tokenized incentives for running Ceramic, but the community is exploring options.</p>"},{"location":"learn/features/#scalability","title":"Scalability","text":"<p>Ceramic's data network infrastructure is highly-scalable and can service use cases where high amounts of data throughput is needed. On Ceramic, every data object maintains its own state and nodes independently process stream transactions, allowing unbounded parallelization. This enables Ceramic to operate at worldwide data scale, which is orders of magnitude greater than the scale needed for decentralized finance.</p>"},{"location":"learn/glossary/","title":"Glossary of terms","text":"<p>This page contains a glossary of terms for Ceramic. Consider this list a work-in-progress; we will continue to update it until it's complete.</p>"},{"location":"learn/glossary/#core-concepts","title":"Core concepts","text":""},{"location":"learn/glossary/#streams","title":"Streams","text":"<p>Streams are DAG-based data structures for storing continuous, mutable streams of content on IPFS and tracking state in a completely decentralized, peer-to-peer way. When syncing or loading a stream from the network, you will always get back the current state.</p>"},{"location":"learn/glossary/#streamid","title":"StreamID","text":"<p>A StreamID is an immutable identifier for a stream. StreamIDs enable continuous streams of data to be referenced by a persistent identifier instead of by constantly-changing IPFS CIDs.</p>"},{"location":"learn/glossary/#streamtypes","title":"StreamTypes","text":"<p>StreamTypes are functions used for processing updates to streams. StreamTypes handle everything from defining the data structure of the stream, to what can be stored in its commits, its state transitition function, authentication requirements, and conflict resolution strategy. Every stream must specify a StreamType; and StreamTypes run on Ceramic nodes. Ceramic comes pre-installed with various StreamTypes, or you can code your own.</p>"},{"location":"learn/glossary/#commits","title":"Commits","text":"<p>Commits are individual IPFS records that make up a stream. Streams may contain one or more commits.</p>"},{"location":"learn/glossary/#genesis-commit","title":"Genesis commit","text":"<p>A genesis commit is the first commit in a stream. Genesis commits may be signed by a public key, or unsigned.</p>"},{"location":"learn/glossary/#signed-commit","title":"Signed commit","text":"<p>Signed commits are commits that update the state of a stream. All signed commits need to be cryptographically signed by a public key.</p>"},{"location":"learn/glossary/#anchor-commit","title":"Anchor commit","text":"<p>Anchor commits are commits that contain a blockchain timestamp, providing an immutable record of time and ordering to other commits in the stream, sometimes known as a proof-of-publication. Anchor commits are needed since vanilla merkle DAGs have no notion of absolute time needed to build consensus.</p>"},{"location":"learn/glossary/#commitid","title":"CommitID","text":"<p>A commitID is an immutable identifier for a specific commit in a stream.</p>"},{"location":"learn/glossary/#state","title":"State","text":"<p>State represents the state of a stream at various points in time. When a stream is loaded or queried from the network, the current state is returned.</p>"},{"location":"learn/glossary/#tip","title":"Tip","text":"<p>A tip is the CID for the most recent commit(s) of a stream.</p>"},{"location":"learn/glossary/#conflict-resolution-strategy","title":"Conflict resolution strategy","text":"<p>A conflict resolution strategy is logic defined by a StreamType that describes how the protocol should handle conflicting updates to a stream that uses this StreamType.</p>"},{"location":"learn/glossary/#controllers","title":"Controllers","text":"<p>Controllers are entities allowed to perform updates to a stream, by creating new signed commits. A given stream may have one controller only.</p>"},{"location":"learn/glossary/#stream-authentication","title":"Stream authentication","text":""},{"location":"learn/glossary/#authentication","title":"Authentication","text":"<p>Authentication allows a user to perform protected operations on a stream, such as creating genesis commits, signed commits, or decrypting data. Each StreamType implementation is able to specify its own authentication mechanism as long as the signatures can be resolved/validated by Ceramic, but most StreamTypes use DIDs.</p>"},{"location":"learn/glossary/#dids","title":"DIDs","text":"<p>DIDs is the W3C standard for decentralized identifiers. The DID specification outlines a standard URI scheme for creating a persistent decentralized identifier (DID) for a given subject as well as resolving metadata about that identifier via a DID document. DIDs are used as an authentication mechanism by most StreamTypes.</p>"},{"location":"learn/glossary/#did-methods","title":"DID methods","text":"<p>DID methods are implementations of the DID specification. DID methods must specify a name for the method in the form of a string (see below), a description of where the DID document is stored (or how it is statically generated), and a DID resolver which can return a DID document given a URI that conforms to that particular DID method. There are over 40 DID methods on the W3C's official DID registry. Ceramic can support any DID method if needed, and currently supports the PKH DID method, 3ID DID method and the Key DID method. DID URIs look like this:</p> <pre><code>did:&lt;method-name&gt;:&lt;method-specific-identifier&gt;\n</code></pre>"},{"location":"learn/glossary/#did-document","title":"DID document","text":"<p>DID documents are documents which contain metadata about a given DID. At a minimum they should contain cryptographic key material used for signature verification and encryption/decryption. They may be mutable where their keys and content can be changed/rotated (i.e. 3ID DID method) or statically generated where their contents cannot be manually changed (i.e. Key DID method).</p>"},{"location":"learn/glossary/#did-resolver","title":"DID resolver","text":"<p>DID resolvers are software libraries responsible for returning a DID document given a DID string. Each DID method has at least one resolver implementation. For all DID methods supported by Ceramic, the corresponding DID resolver must be included in a Ceramic node. Ceramic uses DID resolvers to verify stream transactions by comparing the signature on the transaction to the controller of the stream. For the transaction to be successfully processed, a public key corresponding to the transaction signature must be present in the DID Document of the DID listed as a controller.</p>"},{"location":"learn/glossary/#did-providers","title":"DID providers","text":"<p>DID providers are software libraries that expose a json-rpc interface which allows for the creation and usage of a DID that conforms to a particular DID method. Usually a DID provider is constructed using a seed that the user controls. When using Ceramic with streams that require DIDs for authentication, applications either need to integrate a DID provider library, which leaves the responsibility of key management up to the application, or a DID wallet, which is a more user-friendly experience.</p>"},{"location":"learn/glossary/#did-wallets","title":"DID wallets","text":"<p>DID wallets are software libraries or end-user applications that wrap DID providers with additional capabilities. DID Session is the most popular DID wallet SDK that allows users create, manage, and use a DID method with their existing blockchain wallets, and without needing to install any additional software.</p>"},{"location":"learn/glossary/#network","title":"Network","text":""},{"location":"learn/glossary/#clients","title":"Clients","text":"<p>Clients are software libraries that provide developer interfaces to a Ceramic node. Clients are responsible for authenticating users, providing StreamType-specific interfaces for generating genesis commits and signed commits, and providing generic, streamtype-agnostic interfaces for loading or querying streams. A list of Ceramic clients can be found here.</p>"},{"location":"learn/glossary/#nodes","title":"Nodes","text":"<p>Nodes are software libraries that provide core protocol functionality for the Ceramic network. Nodes are responsible for processing stream updates (in the form of signed commits from clients), storing state for the streams that it cares about, responding to queries, networking with other nodes, replicating streams across the network, and sending valid signed commits to an external anchor service for generating anchor commits.</p>"},{"location":"learn/glossary/#anchor-service","title":"Anchor service","text":"<p>A Ceramic Anchor Service (CAS) is a hosted \"layer-2\" solution for generating anchor commits for many different stream transactions in a scalable, low cost manner. Ceramic nodes are responsible for sending anchor requests containing a StreamID and a CommitID to a CAS, which then batches these transactions into a merkle tree, and includes the merkle root into a blockchain platform in a single transaction (currently Ethereum). After the transaction makes its way onto a blockchain, a Ceramic node creates an anchor commit which includes a reference to the blockchain transaction for every anchored stream. A CAS eliminates the need for each stream transaction to have its own corresponding blockchain transaction, which would be slower and more expensive.</p>"},{"location":"learn/glossary/#networks","title":"Networks","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over a dedicated libp2p topic. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another. Currently, Ceramic has three primary networks: mainnet, Clay Testnet, and dev unstable.</p>"},{"location":"learn/glossary/#mainnet","title":"Mainnet","text":"<p>Mainnet is the Ceramic network used for production deployments. For more information on mainnet, see the Networks page.</p>"},{"location":"learn/glossary/#clay-testnet","title":"Clay Testnet","text":"<p>Clay Testnet is a Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. For more information on Clay Testnet, see the Networks page.</p>"},{"location":"learn/glossary/#dev-unstable","title":"Dev Unstable","text":"<p>Dev Unstable is a Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the <code>develop</code> branch of js-ceramic. It should be considered unstable and highly experimental.</p>"},{"location":"learn/glossary/#underlying-technologies","title":"Underlying technologies","text":""},{"location":"learn/glossary/#ipfs","title":"IPFS","text":"<p>IPFS is the Interplanetary File System. Simply put, IPFS is a way to address static content using CIDs and to discover this content over a peer-to-peer network of nodes. Ceramic relies on IPFS for storing the commits that make up streams and discovering this data over the network.</p>"},{"location":"learn/glossary/#cid","title":"CID","text":"<p>A CID (content identifier) is an immutable identifier for a discrete piece of static content stored on IPFS. CIDs are essentially a hash of the content along with metadata that describes how the content is encoded. Ceramic streams consist of multiple CIDs, encoded using dag-jose (and other formats such as dag-cbor), and linked together using IPLD.</p>"},{"location":"learn/glossary/#ipld","title":"IPLD","text":"<p>IPLD (Interplanetary Linked Data) is the data structures layer of IPFS. It is used to link multiple CIDs together into higher-level linked-data structures. Ceramic uses IPLD to create the data structures for streams.</p>"},{"location":"learn/glossary/#dagjose","title":"DagJOSE","text":"<p>DagJOSE is a codec for IPLD which stores content in IPFS using IETF's JOSE (JSON object signing and encryption) format. With DagJOSE, each data object actually consists of two separate but linked CIDs. It supports both signed and encrypted objects. JWS is used for signed objects and it encodes the payload as a CID, which means that the actual payload is a separate IPLD object. JWE is used for encrypted objects, and it requires the ciphertext to be a CID in order to not leak the full cleartext. A separate inline CID is used to encode the entire cleartext. For more information refer to the DagJOSE spec.</p>"},{"location":"learn/glossary/#libp2p","title":"Libp2p","text":"<p>Libp2p is the peer-to-peer networking protocol that is used by Ceramic. It is included as part of the IPFS stack. Ceramic relies on libp2p for discovering data over the network and communicating between nodes. Libp2p is also used by other major decentralized platforms such as Ethereum (Eth2) and Polkadot.</p>"},{"location":"learn/glossary/#ethereum","title":"Ethereum","text":"<p>Ethereum is the world's leading public, permissionless smart contract blockchain platform. Ceramic uses Ethereum for generating the timestamps contained within anchor commits.</p>"},{"location":"learn/highlighted-projects/","title":"Highlighted projects","text":"<p>Whether you're building a new feature for your product or using Ceramic for your next hackathon entry, here's some successful projects, useful tools, and popular use-cases for Ceramic to get excited about!</p> <p>Note: We do our best to keep these links and list of projects as up-to-date as possible. If you see any issues with the content below, please drop by our Discord and let us know.</p>"},{"location":"learn/highlighted-projects/#ecosystem-support","title":"Ecosystem support","text":"<p>Plugins and tools to enhance Ceramic's underlying functionality.</p> Project Description Demo Code Repo Cerscan Explorer for the Ceramic Network testnet and mainnet. Built by the Orbis team. Example IdentityLink Services for issuing verifiable credentials that link a decentralized identifier (DID) to various social accounts including Twitter, Github, and Discord. Demo Github Lit Protocol  Lit Protocol facilitates gated access to encrypted content/data on Ceramic using tokens, NFTs, and blockchain identity as keys. Demo Github Self.ID SDK Self.ID is a framework that makes it easy to build on Ceramic with Ethereum-based authentication and composable, user-centric data storage and retrieval. Reference app Github Spruce Toolkit for decentralized identity, helping developers integrate everything they need to sign, share, and verify trusted information. Co-author of the Sign-In With Ethereum standard. Blog Post Github Tiles Explorer Tiles is a document browser and explorer that gives insight into all the real-time activity happening on Ceramic. No longer actively maintained. Github"},{"location":"learn/highlighted-projects/#apps-built-with-ceramic","title":"Apps built with Ceramic","text":"<p>Projects for popular use-cases built using Ceramic by valued partners, community members, and hackathon participants.</p>"},{"location":"learn/highlighted-projects/#user-profiles","title":"User Profiles","text":"<p>Decentralized universal profiles available for use throughout the web3 metaverse.</p> Project Description Demo Code Repo DAOHaus To help DAOs better understand who is participating in thier communities, DAOhaus is using Ceramic to create rich and robust member profiles. Blog Post Github DNS.xyz DNS.xyz uses Ceramic to allow users to create and manage a universal profile. Titter Titter is a prototype of a web3-native social application, using Ceramic for editable, self-sovereign user profiles. Demo Github"},{"location":"learn/highlighted-projects/#reputation","title":"Reputation","text":"<p>This includes any publicly veriable attestations for skills, credentials, and contribution scores.</p> Project Description Demo Code Repo C-Voxel C-Voxel is your visualized work history on web3 generated and stored on Ceramic. Github Deep Skills Deep Skills is a platform to help DAOs recruit &amp; coordinate workflows amongst team members, using Ceramic to store contributor credentials.) Hackathon Submission Github Gateway Gateway is a DAO discovery and contributor reputation platform, aiming to build the LinkedIn for Web3 storing employment credentials on Ceramic. User Demo Admin Demo Gitcoin Passport Gitcoin Passport allows users to prove their identity through a secure, decentralized UI which issues verifiable credentials stored on Ceramic. Demo Github Intuition An Identity System where users can \"stake\" claims about their identity, allowing the public to view and verify, resulting in an aggregate confidence score in the claim, using Ceramic to store credentials and social connections. Demo Github Krebit.id Krebit.id is an open identity verification protocol, DAO and marketplace for Web3 Verifiable Credential. Demo Github SuperSkills Lab Built in partnership with the Lego Foundation, SuperSkills Lab is a learning application for children, using Ceramic to issue credentials for earned skills. Blog Post"},{"location":"learn/highlighted-projects/#user-generated-content","title":"User-generated Content","text":"<p>Includes social media posts, comments, votes, blogs, and social graphs, to name a few.</p> Project Description Demo Code Repo convo.space Convo is a decentralized conversation protocol that separates social data from applications, creating a unified conversation layer that can work across applications by linking data to a user\u2019s unique decentralized identity. Blog Post Github CyberConnect CyberConnect is building the open social graph for Web3. Blog Post Github HashChat Protocol to enable wallet-to-wallet messages that are fully encrypted and disappearing. Hackathon Submission Github Headline Headline is a decentralized publishing platform built by Unlock Protocol where a creator\u2019s content is fully self-sovereign. Demo Link3 Link3 by CyberConnect is a verified and trusted way for projects to publish their info and links, with all content stored on Ceramic streams. Example Minds Minds is a web3 social network using Ceramic to store user profile data. Demo Github Orbis Club Orbis is a decentralized version of Twitter built on Ceramic, where user\u2019s posts are stored as Ceramic streams. Demo"},{"location":"learn/highlighted-projects/#dynamic-nfts","title":"Dynamic NFTs","text":"<p>NFTs backed by off-chain data storage with content that can change and evolve over time.</p> Project Description Demo Code Repo DoinGud DoinGud is building a cross-chain, interoperable NFT ecosystem focused on social impact initiatives, using Ceramic to store dynamic NFT content and metadata, attached to user identities. Blog Post FungyProof FungyProof Cases are used to grade NFTs on their technical soundness, using Ceramic for dynamically appending metadata to an NFT over time. Blog Post"},{"location":"learn/how-it-works/","title":"How it works","text":"<p>Ceramic decentralizes application databases, making data universally composable and reusable across applications. The network consists of three core parts: a highly-scalable, decentralized infrastructure for data availability and consensus, a marketplace of community-created data models, and a suite of standard APIs for storing, updating, and retrieving data from those models.</p>"},{"location":"learn/how-it-works/#core-components","title":"Core components","text":"<p>The Ceramic network consists of three core components:</p> <ol> <li>Scalable, decentralized data infrastructure</li> <li>Data models marketplace</li> <li>Open APIs for data storage, update, and retrieval</li> </ol>"},{"location":"learn/how-it-works/#scalable-decentralized-data-infrastructure","title":"Scalable, decentralized data infrastructure","text":"<p>The most foundational layer of Ceramic is its scalable, decentralized data network. The Ceramic network consists of a collection of permissionless nodes that work together to provide data availability for all states stored on the network, and work to come to consensus about those states every time there is a new transaction.</p> <p>However, unlike Layer 1 blockchains designed to keep track of state for financial applications such as tokens, Ceramic is specifically designed to keep track of state for high-throughput data applications such as decentralized social networks, decentralized identity, crypto gaming, reputation systems, etc. In this way, Ceramic acts as a global, highly-scalable decentralized database that every application in the world can build on.</p> <p>To achieve scale, Ceramic makes a few opinionated decisions on the data structure of its network. The most important is that in Ceramic, there is no notion of state that can be shared between accounts. Every piece of state is owned only by the account that created it, and no account can modify anyone else\u2019s states, though any account can link to a piece of state owned by another account.</p> <p>On Ceramic, every account has a collection of mutable data objects, called streams, that only they as the owner of those streams, can write to. The content stored in each stream is arbitrary, and can reference content in anyone else\u2019s stream. Note that this does not preclude compute. Developers can write functions, called streamcode, that define how these streams can be updated and what actions they perform upon each new update.</p> <p>This architecture untangles state between users, allowing the system to scale horizontally very cleanly. You can imagine that accounts 1 - 1,000,000 are replicated on one set of Ceramic nodes, and accounts 1,000,001 - 2,000,000 are replicated on another. Theoretically, the network can be sharded all the way down to each individual user if needed without breaking composability. In order to ensure state verifiability and composability between user shards, Ceramic relies on a merkle tree data structure that aggregates transactions across all users, allowing any account to verify the integrity of anyone else\u2019s streams at any time.</p>"},{"location":"learn/how-it-works/#data-models-marketplace","title":"Data models marketplace","text":"<p>The second core component of Ceramic is its vibrant ecosystem of open source data models created by the community, which serve to unlock cross-application data composability. Data models are a novel abstraction that unify how similar types of applications store and retrieve state from each individual user on the network. For example, you can imagine that every decentralized Twitter implementation would run on a few shared data models: one for each user\u2019s tweets, one for their social graph, one for their DMs, etc. By adopting the same underlying data models, applications are able to natively interoperate on the same data.</p> <p>You can compare Ceramic\u2019s use of data model standards to the use of token standards for financial ledgers. On Ethereum, for example, the introduction of the ERC-20 fungible token and ERC-721 non-fungible token standards have given rise to entire ecosystems of tokens and financial applications that natively interoperate. Ceramic brings this same concept to data.</p> <p>Ceramic takes a community-driven approach to creating these data models, allowing any developer to easily define, share, and reuse their models with other developers in the ecosystem. As more data models are created by the community, we will see a continuous expansion in the quantity and variety of applications that are built with composable data.</p> <p>Composability done this way also makes the developer experience better. Building an application on Ceramic looks like browsing a marketplace of data models, plugging them into your app, and automatically gaining access to all data on the network that\u2019s stored in these models. No longer will every single developer need to worry about bootstrapping their application with their own siloed users and data, making it easier than ever to go from idea to implementation.</p>"},{"location":"learn/how-it-works/#open-apis","title":"Open APIs","text":"<p>The final core component of Ceramic is its permissionless, open APIs for storing, modifying, and retrieving data from the network. By standardizing, generalizing, and opening these APIs up to every developer in the world, Ceramic enables developers to build on top of shared resources stored on the network without fear of centralization, censorship risk, or lock-in.</p>"},{"location":"learn/networks/","title":"Networks","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over dedicated libp2p topics. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another.</p>"},{"location":"learn/networks/#public-networks","title":"Public networks","text":"<p>Ceramic has three public networks that you can use when building applications: Mainnet, Clay Testnet, and Dev Unstable.</p>"},{"location":"learn/networks/#mainnet","title":"Mainnet","text":"<p>Mainnet is the main public network used for production deployments on Ceramic. Ceramic's mainnet nodes communicate over the dedicated <code>/ceramic/mainnet</code> libp2p topic and use Ethereum's mainnet blockchain (<code>EIP155:1</code>) for generating timestamps used in anchor commits for streams. Mainnet is currently running and anyone can openly query data from streams on mainnet. We are currently transitioning to a self-serve mainnet process by Dec 31, 2022 -- if you need access in the interim, reach out in the #share-your-project channel in Discord.</p>"},{"location":"learn/networks/#clay-testnet","title":"Clay Testnet","text":"<p>Clay Testnet is a public Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. While we aim to maintain a high level of quality on the Clay testnet that mirrors the expectations of Mainnet as closely as possible, ultimately the reliability, performance, and stability guarantees of the Clay network are lower than that of Mainnet. Because of this, the Clay network should not be used for applications in production. Clay nodes communicate over the dedicated <code>/ceramic/testnet-clay</code> libp2p topic and use Gnosis chain for generating timestamps used in anchor commits for streams. Clay is openly available for anyone to use now.</p>"},{"location":"learn/networks/#dev-unstable","title":"Dev Unstable","text":"<p>Dev Unstable is a public Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the develop branch of <code>js-ceramic</code>. It should be considered unstable and highly experimental; only use this network if you want to test the most cutting edge features, but expect issues. Dev Unstable nodes communicate over the dedicated <code>/ceramic/dev-unstable</code> libp2p topic and use Ethereum's G\u00f6rli testnet blockchain for generating timestamps used in anchor commits for streams.</p>"},{"location":"learn/networks/#private-networks","title":"Private networks","text":"<p>You can also prototype applications on Ceramic by running the protocol in a local environment completely disconnected from other public nodes.</p>"},{"location":"learn/networks/#local","title":"Local","text":"<p>Local is a private test network used for the local development of Ceramic applications. Nodes connected to the same local network communicate over a randomly-generated libp2p topic <code>/ceramic/local-$(randomNumber)</code> and use a local Ethereum blockchain provided by Truffle's Ganache for generating timestamps used in anchor commits for streams.</p>"},{"location":"learn/roadmap/","title":"Ceramic Roadmap","text":"<p>The core Ceramic team remains committed to making ongoing improvements to both ComposeDB and the underlying Ceramic protocol. Concurrently, we seek to involve the Ceramic developer community in shaping Ceramic's future. We value your active participation in helping us prioritize the features  and improvements that matter most to our developer base.</p> <p>All curent and future projects are outlined in the Ceramic roadmap.</p> <p>We welcome your feedback and insights on our roadmap priorities. You can show your support or express your concerns about projects on the roadmap by upvoting or downvoting them. Additionally, we encourage you to leave more detailed  comments, making suggestions or indicating relevant feature requests.</p>"},{"location":"learn/use-cases/","title":"Use Cases","text":"<p>Explore the many ways your project or business can leverage Ceramic's decentralized data streaming platform. Ceramic is a general-purpose protocol, so this list is definitely non-exhaustive; it's meant to serve as a starting point for ideation. The use cases on this list are not mutually exclusive and many Ceramic integrations will make use of more than one.</p>"},{"location":"learn/use-cases/#decentralized-identity","title":"Decentralized identity","text":"<p>Build secure applications using decentralized identities and portable, user-controlled data storage. Ceramic is home to the Identity Index protocol which provides a robust, flexible, and standards-based decentralized identity system that can serve as the cornerstone of any Web3 application. Building with the Identity Index protocol allows users to control their identities and data in a manner independent from any single application or platform, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application. Identities are based on W3C standards and can be used with wallets from many different blockchains and Web3 platforms.</p> <ul> <li>Decentralized identifiers (DIDs)</li> <li>Aggregated and cross-chain identities</li> <li>Web3: Connect wallets from any L1 or L2 protocol</li> <li>Web2: Link social accounts from any platform</li> <li>User profiles</li> <li>Social graphs</li> <li>Data storage</li> <li>Reputation systems</li> </ul>"},{"location":"learn/use-cases/#decentralized-databases","title":"Decentralized databases","text":"<p>Replace your database backend or local storage and store/host all of your content in mutable, decentralized streams.</p> <ul> <li>User data and user-generated content</li> <li>User activity and history</li> <li>Application data</li> <li>Application state and other cookie-like content</li> <li>Cross-device local storage</li> </ul>"},{"location":"learn/use-cases/#evolutionary-files","title":"Evolutionary files","text":"<p>Store editable, version-controlled files, documents, and other media on IPFS that maintains a tamper-proof and auditable history without needing external services to compute state changes, enforce permissions, or keep track of changing CIDs. Also make these files publicly available and discoverable over a global network.</p> <ul> <li>Mutable NFT files</li> <li>JSON documents</li> <li>JSON schemas</li> <li>Arbitrary metadata</li> <li>Verifiable credentials</li> </ul>"},{"location":"learn/use-cases/#multi-user-applications","title":"Multi-user applications","text":"<p>Leverage the unique features and properties of Ceramic to create permissionless social networks where content is decentralized and owned by users instead of platforms.</p> <ul> <li>Social media</li> <li>Community platforms</li> <li>Governance forums</li> </ul>"},{"location":"learn/use-cases/#decentralized-publications","title":"Decentralized publications","text":"<p>Publish and host content on a decentralized, censorship-resistant platform where data can be made globally available, authorship can be verified, links never rot, and each piece of content can be updated by its creator while still maintaining a tamper-proof audit trail of changes.</p> <ul> <li>Blogging platforms</li> <li>News media and publications</li> </ul>"},{"location":"learn/use-cases/#cross-application-data-sharing","title":"Cross-application data sharing","text":"<p>On Ceramic, all data is published to the open web where it's easy to share verifiable information between different organizations and applications in real-time without worrying about correctness or dealing with centralized servers and one-off API integrations.</p> <ul> <li>Cross-application data</li> <li>Cross-organizational data</li> <li>Enterprise system of record (SOR)</li> </ul>"},{"location":"learn/use-cases/#semantic-web","title":"Semantic web","text":"<p>Link multiple streams together to form a graph of relationships between verifiable data objects that can each individually evolve without breaking the graph.</p>"},{"location":"learn/use-cases/#remixable-content","title":"Remixable content","text":"<p>Fork and remix any streams on the network into entirely new creations. No permission needed.</p>"},{"location":"learn/welcome/","title":"Ceramic Docs","text":""},{"location":"learn/welcome/#the-composable-data-network","title":"The Composable Data Network","text":"<p>Ceramic is a decentralized data network that powers an ecosystem of interoperable Web3 applications and services. Ceramic's event streaming protocol is a highly-scalable decentralized data infrastructure used for building all kinds of interoperable Web3 services and protocols, such as decentralized databases. Ceramic-powered databases and services enable thousands of Web3 developers to build data-intensive applications and solve the world's most complex data challenges. By decentralizing application databases, Ceramic makes data composable and reusable across all applications.</p> <p></p> <p></p>"},{"location":"learn/welcome/#introduction-to-ceramic","title":"Introduction to Ceramic","text":"<ul> <li> <p>Try the ComposeDB Quickstart to try the newest Ceramic-powered graph database</p> </li> <li> <p>Try the Ceramic Quickstart to learn about lower-level Ceramic functionality</p> </li> <li> <p>Go deeper by reading the Ceramic Protocol specification</p> </li> <li> <p>Explore use cases and projects built on Ceramic</p> </li> </ul>"},{"location":"learn/welcome/#build-applications","title":"Build Applications","text":""},{"location":"learn/welcome/#composedb-graph-db-for-web3-apps","title":"ComposeDB: Graph DB for Web3 Apps \u2192","text":"<p>ComposeDB is a decentralized graph database powered by Ceramic that enables you to build powerful Web3 applications using composable data, GraphQL, and reusable models. ComposeDB is the newest and most popular database built on Ceramic.</p>"},{"location":"learn/welcome/#run-a-ceramic-node","title":"Run a Ceramic Node","text":"<p>Run a Ceramic node to provide data storage, compute, and bandwidth for your Ceramic application. Today there are no tokenized incentives for running a Ceramic node, but by running a node you can ensure the data for your app remains available while helping contribute to the network's decentralization.</p> <ul> <li> <p>Run Ceramic in the cloud</p> </li> <li> <p>Run Ceramic locally</p> </li> </ul>"},{"location":"learn/welcome/#join-the-community","title":"Join the Community","text":"<ul> <li> <p>Join our Forum to ask questions and get support</p> </li> <li> <p>Join the Discord to discuss the Ceramic Network</p> </li> <li> <p>Follow us on Twitter for updates</p> </li> <li> <p>Read the blog for news, announcements, and tutorials</p> </li> <li> <p>Watch the Youtube channel for videos and presentations</p> </li> <li> <p>Work on Ceramic through open roles at 3Box Labs</p> </li> </ul>"},{"location":"learn/advanced/consensus/","title":"Consensus","text":"<p>This page describes the consensus and conflict resolution model for streams on Ceramic.</p>"},{"location":"learn/advanced/consensus/#overview","title":"Overview","text":"<p>Ceramic maintains consensus for individual data streams. This is in contrast to traditional blockchain systems where consensus is maintained on the entire global ledger, or to distributed database systems where consensus is maintained for the entire database. Maintaining consensus at the level of individual data objects allows Ceramic to be much more scalable, as nodes only need to track information for the Streams that they care about, rather than for all Streams on the network. This also allows different Streams to use different consensus models - allowing for a flexible and extensible consensus system that can evolve over time and be tailored to specific use cases. In Ceramic, consensus is handled by individual StreamTypes, meaning new StreamTypes introduced in the future may also introduce new consensus mechanisms.</p> <p>Warning</p> <p>This page contains lots of information about how Ceramic handles reaching consensus on Streams, but the most important part for most developers to understand is the semantics around simultaneous updates.</p>"},{"location":"learn/advanced/consensus/#existing-consensus-model","title":"Existing consensus model","text":"<p>Most of the existing StreamTypes today use diffs encoded with json-patch to represent state transitions, and use the Earliest Anchor Wins rule for conflict resolution.</p>"},{"location":"learn/advanced/consensus/#json-patch-diffs","title":"Json-patch diffs","text":"<p>In the existing TileDocument StreamType, updates to the document's contents are encoded using json-patch. The resulting diff goes into a Ceramic Commit and can be used to transform the stream's contents from a previous state to a new state. Syncing a TileDocument involves getting the initial state from the genesis commit, then applying the json-patch diffs from each subsequent commit to the content, one at a time, until the end of the stream's commit log, at which point you have the current state of the content.</p>"},{"location":"learn/advanced/consensus/#write-conflicts","title":"Write conflicts","text":"<p>Sometimes, two conflicting logs for the same Stream might exist simultaneously. This can happen when the controller of the stream makes conflicting updates to the same stream on different devices or via different applications. It can also happen if a single Stream has multiple end users who are able to author updates to the stream (either because the stream has multiple controller DIDs, or because the DID method being used as the stream controller allows multiple users/private keys to sign messages on its behalf, like the did:safe DID method, for example).</p> <p>Whatever the reason for the diverging logs for a single Stream, it is important that all nodes can come to agreement (consensus) as to which is the correct log for that Stream. Most StreamTypes currently rely on the Earliest Anchor Wins strategy for resolving conflicts between stream logs.</p>"},{"location":"learn/advanced/consensus/#earliest-anchor-wins","title":"Earliest Anchor Wins","text":"<p>Updates to Ceramic Streams are periodically anchored onto a blockchain (currently Ethereum). This immutable proof-of-publication is used to get a trustless timestamp for when the update occurred. This allows us to safely compare the timestamps associated with different branches of a Stream's log to determine which update happened first. When there are conflicting histories for a Stream log and one branch was anchored earlier than the other, the branch that was anchored earlier wins. If one branch was anchored and the other not, then the branch that was anchored is prefered.</p>"},{"location":"learn/advanced/consensus/#longest-update-chain","title":"Longest update chain","text":"<p>The Earliest Anchor Wins rule can solve many problems related to coming to consensus on a Stream's state, but still has issues if multiple updates are created quickly. Since anchors only happen periodically (depends on the anchor service being used, but currently twice a day for the anchor service that 3Box Labs operates for Ceramic mainnet), multiple updates can be created and published before any of them get anchored. In that case, we still need to come to consensus on the current state. When there are conflicting logs for a stream neither of which have been anchored, we prefer whichever log is longer. This ensures that the most active history with the most updates is preserved. If there are conflicting unanchored branches that have the same length, then the system picks the winning log arbtrarily, but deterministically, to ensure that all nodes come to agreement on the same log, even if there is no good information available to use to decide which to prefer. This can result writes being lost in certain rare instances where there are conflicting updates published within a few seconds of each other.</p>"},{"location":"learn/advanced/consensus/#simultaneous-updates","title":"Simultaneous updates","text":"<p>Ceramic Streams today are updated using a read-modify-write approach. This means that write conflicts can result in writes being lost in some specific scenarios. Consider an app that wants to add a new entry to an array contained within a TileDocument stream. The app loads a stream, gets the current contents of the Stream (including the current value of the array to be updated), adds an element into the array locally, then issues an update to Ceramic with the new contents. The code for this may look something like:</p> <pre><code>const streamId = '&lt;...&gt;' // A StreamID for an existing Ceramic Stream\nconst doc = await TileDocument.load(ceramic, streamId)\n// doc's content contains a 'friends' array field with the value ['mohsin', 'liz']\nconst content = doc.content\ncontent.friends.push('sergey')\nawait doc.update(content)\n</code></pre> <p>If, while this code is running, another update is made to this same Stream (using code that looks much the same but say adding 'stephanie' instead of 'sergey'), then this code may not be aware of that update when the new state is published to the network via the <code>doc.update</code> call. You could wind up with two conflicting updates published to the network, one adding 'sergey' to the list, the other adding 'stephanie' to the list. In this case the network will eventually come to consensus about which update to keep, but which one is chosen is arbitrary, and the rejected update will be lost forever. This means that there is a chance that the final array winds up being <code>['mohsin', 'liz', 'sergey']</code>, and it is equally possible that the final array winds up being <code>['mohsin', 'liz', 'stephanie']</code>, with no way to tell in advance which update will win out.</p> <p>This behavior is usually not a problem for Ceramic, since most Ceramic streams are controlled by a single end user, who will not be making multiple simultaneous updates to a given stream at the same time. This does mean, however, that Ceramic is not well suited at the moment to applications that depend on allowing multiple end users to update a single stream simultaneously. Note that so long as updates happen more than approximately 30 seconds apart, that should be enough time for the updates to be shared across the entire Ceramic network and prevent conflicts like these from occurring. Also, future StreamTypes may not be subject to this issue, as future StreamTypes will be able to use different consensus mechanisms better suited to handling simultaneous updates.</p>"},{"location":"learn/advanced/consensus/#future-improvements","title":"Future improvements","text":"<p>In the future, Ceramic plans to offer StreamTypes that use CRDTs to encode updates to Streams, which will allow simultaneous updates to be merged automatically without conflict. Such plans, however, are currently still in the research phase.</p>"},{"location":"learn/advanced/consensus/#further-reading","title":"Further reading","text":"<p>If you want more, lower-level details about how Ceramic maintains consensus on Stream logs, you can read the specification.</p>"},{"location":"learn/advanced/data-availability/","title":"Data Availability","text":"<p>This page describes the data persistence and data availability model for streams on Ceramic.</p>"},{"location":"learn/advanced/data-availability/#overview","title":"Overview","text":"<p>Stream data can be divided into two main categories: commits and state. While there is some overlap, these two types of data have enough difference that they should be considered separately when planning how to persist and host your streams. All commits and state for a given stream must be available when performing writes or queries on that stream; if not, your client will return an error. This error will disappear once all data comes back online. In the event that one or more commits for the given stream were permanently lost due to improper persistence management, then this stream will be corrupted and the error will not disappear.</p>"},{"location":"learn/advanced/data-availability/#stream-commits","title":"Stream commits","text":"<p>Every stream is an event log consisting of one or more commits, and each commit contains at least two IPLD objects. Collectively these commits store the data that makes up the content of a stream.</p>"},{"location":"learn/advanced/data-availability/#caching","title":"Caching","text":"<p>Ceramic nodes have a built-in caching mechanism for short-term storage of commits. Whenever a Ceramic node performs a write or a query on a stream, all commits for that stream are first synced from the network and automatically loaded into that node's in-memory cache. This results in the most popular streams being replicated the most, providing some level of data persistence and availability. However to preserve disk space and node resources, in-memory cache defaults to a limit of 500 streams (but can be configured to any number). Once that number is reached, the oldest streams will be evicted from the node's cache in order to make room for newer ones.</p> <p>If the node happens to shut down or restart, the cache will be cleared. Without sufficient replication across other nodes due to popularity or additional data persistence measures prior to a shutdown, streams that only exist in-memory will be lost forever. Therefore, cache-only is not a dependable source of data availability for a longer period than a specific session.</p>"},{"location":"learn/advanced/data-availability/#pinning","title":"Pinning","text":"<p>Pinning provides a more long-lived mechanism of data persistence for commits. Pinning is a process for instructing a Ceramic node to explicitly host (i.e. \"pin\") the commits for a specific stream. Since commits are stored in IPLD, Ceramic nodes already contain a bundled IPFS node which is where this pinning occurs. IPFS nodes can pin all commits for any stream which is accessible over the Ceramic network to which it is connected. Ceramic pinning can also work using an external IPFS node instead of the bundled internal version.</p> <p>If developers want the easiest way to make their streams persistent beyond a single session and more resilient against data loss, then pinning is the right option. Ceramic nodes can pin an unlimited number of streams. However, note that if only one IPFS node is pinning a given stream and it disappears forever or gets corrupted, then that stream will be lost. Also, if only one node is pinning a stream (and no other Ceramic nodes have it in cache) and that node goes offline, then that stream will be unavailable to others. Therefore, for improved resilience and data availability it is best to have multiple IPFS nodes running in different envitonments pinning the same streams.</p> <p>See the Pinning guide for instructions on how to pin streams on a Ceramic node.</p>"},{"location":"learn/advanced/data-availability/#archiving","title":"Archiving","text":"<p>Archiving is the most durable, long-lived form of persistence for commits. In addition to caching and pinning, Ceramic developers may also configure their node to connect to an external service for archiving all commits that make up a stream. The exact guarantees provided by archiving differ with each implementation and service provider. For example, archiving to Filecoin provides crypto-economically guaranteed data availability with a pay-as-you-go model, while archiving to Arweave provides crypto-economically guaranteed data availability with a one-time payment model. Conversely, archiving to Amazon S3 provides a simpler model however Amazon cannot guarantee that your data will always be available (for example you could stop paying your bill), but the storage is still more resilient than using pinning and caching only.</p>"},{"location":"learn/advanced/data-availability/#stream-state","title":"Stream state","text":"<p>In addition to the commit log mentioned above which is stored in IPFS, every stream has a state which is not stored in IPFS but rather is collectively tracked, persisted, and made available by all Ceramic nodes that are caching and/or pinning the stream. Both the complete commit history and the state are needed to successfully load and interact with streams.</p>"},{"location":"learn/advanced/data-availability/#caching_1","title":"Caching","text":"<p>State caching works the same as commit caching.</p>"},{"location":"learn/advanced/data-availability/#pinning_1","title":"Pinning","text":"<p>State pinning works the same as commit pinning, except state pinning does not occur on IPFS. State pinning simply occurs in a database internal to the Ceramic node.</p>"},{"location":"learn/advanced/data-availability/#archiving_1","title":"Archiving","text":"<p>Ceramic is working on a durable, decentralized state store which will be used to persist and guarantee availability for the state of streams. This is on the roadmap. It's not critical to the immediate use of Ceramic, but will serve to make state more resilient and available. In the meantime, Ceramic supports archiving state to Amazon S3, for an option with more durability and reliability than the local database used by default.</p>"},{"location":"learn/advanced/overview/","title":"Overview","text":"<p>Ceramic is a public, permissionless, open source protocol that provides computation, state transformations, and consensus for all types of data structures stored on the decentralized web. Ceramic's stream processing enables developers to build secure, trustless, censorship-resistant applications on top of dynamic information without trusted database servers.</p> <p>This overview introduces how:</p> <ul> <li>Decentralized content computation gives rise to a new era of open source information</li> <li>Stream processing provides an appropriate framework for dynamic, decentralized content</li> <li>You can use Ceramic to replace your database with a truly decentralized alternative</li> </ul> <p>To skip ahead and get started building, try the Playground to demo Ceramic in a browser application, the Quick Start guide to learn the basics using the Ceramic CLI, or follow the Installation page to integrate Ceramic into your project.</p>"},{"location":"learn/advanced/overview/#the-internet-of-open-source-information","title":"The internet of open source information","text":"<p>At its core, the internet is a collection of applications running on stateful data sources \u2013 from identity systems and user tables to databases and feeds for storing all kinds of content generated by users, services, or machines.</p> <p>Most of the information on today's internet is locked away on application-specific database servers designed to protect data as a proprietary resource. Acting as trusted middlemen, applications make it difficult and opaque for others to access this information by requiring explicit permissions, one-off API integrations, and trust that returned state is correct. This siloed and competitive environment results in more friction for developers and worse experiences for users.</p> <p>Along other dimensions, the web has rapidly evolved into a more open source, composable, and collaborative ecosystem. We can observe this trend in open source software enabled by Git's distributed version control and in open source finance enabled by blockchain's double-spend protection. The same principles of open source have not yet been applied to content.</p> <p>The next wave of transformative innovation will be in applying the same open source principles to the world's information, unlocking a universe of content that can be frictionlessly shared across application or organizational boundaries. Achieving this requires a decentralized computation network designed specifically for content with flexibility, scalability, and composability as first class requirements.</p>"},{"location":"learn/advanced/overview/#decentralized-content-computation","title":"Decentralized content computation","text":"<p>Open sourcing the content layer for applications requires deploying information to a public, permissionless environment where files can be stored, computation can be performed, state can be tracked, and others can easily access content.</p> <p>Advancements in other Web3 protocols have already achieved success in decentralized file storage. As a universal file system for the decentralized web, IPFS (including IPLD and Libp2p) provides an extremely flexible content naming and routing system. As a storage disk, durable persistence networks (such as Filecoin, Arweave, and Sia) ensure that the content represented in IPFS files is persisted and kept available. This stack of Web3 protocols performs well for storing static files, but on its own lacks the computation and state management capacity for more advanced database-like features such as mutability, version control, access control, and programmable logic. These are required to enable developers to build fully featured decentralized applications.</p> <p>Ceramic enables static files to be composed into higher-order mutable data structures, programmed to behave in any desired manner, whose resulting state is stored and replicated across a decentralized network of nodes. Ceramic builds upon and extends the IPFS file system and underlying persistence networks, as well as other open standards in the decentralized ecosystem, with a general-purpose decentralized content computation substrate. Due to Ceramic's permissionless design and unified global network, anyone in the world can openly create, discover, query, and build upon existing data without needing to trust a centralized server, integrate one-off APIs, or worry if the state of information being returned is correct.</p>"},{"location":"learn/advanced/overview/#streams","title":"Streams","text":"<p>Ceramic's decentralized content computation network is modeled after various stream processing frameworks found in Web2. In these types of systems, events are ingested, processed as they arrive, and the resulting output is applied to a log. When queried and reduced, this log represents the current state of a piece of information. This is an appropriate framework for conceptualizing how dynamic information should be modeled on the decentralized web. Furthermore because the function that processes incoming events on any particular stream can be custom written with logic for any use case, it provides the general-purpose flexibility and extensibility needed to represent the diversity of information that may exist on the web.</p> <p>On Ceramic, each piece of information is represented as an append-only log of commits, called a Stream. Each stream is a DAG stored in IPLD, with an immutable name called a StreamID, and a verifiable state called a StreamState. Streams are similar in concept to Git trees, and each stream can be thought of as its own blockchain, ledger, or event log.</p>"},{"location":"learn/advanced/overview/#streamtypes","title":"StreamTypes","text":"<p>Each stream must specify a StreamType, which is the processing logic used by the particular stream. A StreamType is essentially a function that is executed by a Ceramic node upon receipt of a new commit to the stream that governs the stream's state transitions and resulting output. StreamTypes are responsible for enforcing all rules and logic for the stream, such as data structure, content format, authentication or access control, and consensus algorithm. If an update does not conform to the logic specified by the StreamType, the update is disregarded. After applying a valid commit to the stream, the resulting StreamState is broadcast out to the rest of the nodes on the Ceramic Network. Each of the other nodes that are also maintaining this stream will update their StreamState to reflect this new transaction.</p> <p>Ceramic's flexible StreamTypes framework enables developers to deploy any kind of information that conforms to any set of arbitrary rules as a stateful stream of events. Ceramic clients come pre-packaged with a standard set of StreamTypes that cover a wide range of common use cases, making it easy to get started building applications:</p> <ul> <li>Tile Document: a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store. Tile Documents are frequently used as a database replacement for identity metadata (profiles, social graphs, reputation scores, linked social accounts), user-generated content (blog posts, social media, etc), indexes of other StreamIDs to form collections and user tables (IDX), DID documents, verifiable claims, and more. Tile Documents rely on DIDs for authentication and all valid updates to a stream must be signed by the DID that controls the stream.</li> <li>CAIP-10 Link: a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. A DID can have an unlimited number of CAIP-10 Links that bind it to many different addresses on many different blockchain networks. CAIP-10 Links also rely on DIDs for authentication, the same as Tile Documents.</li> <li>Custom: You can implement your own StreamType and deploy it to your Ceramic node if the pre-packaged StreamTypes are not suitable for your use case.</li> </ul>"},{"location":"learn/advanced/overview/#authentication","title":"Authentication","text":"<p>StreamTypes are able to specify their authentication requirements for how new data is authorized to be added to a particular stream. Different StreamTypes may choose to implement different authentication requirements. One of the most powerful and important authentication mechanisms that Ceramic StreamTypes support is DIDs, the W3C standard for decentralized identifiers. DIDs are used by the default StreamTypes (Tile Documents and CAIP-10 Links).</p> <p>DIDs provide a way to go from a globally-unique, platform-agnostic string identifier to a DID document containing public keys for signature verification and encryption. Ceramic is capable of supporting any DID method implementation. Below, find the DID methods that are currently supported by Ceramic:</p> <ul> <li>PKH DID Method: A DID method that natively supports blockchain accounts. DID documents are statically generated from a blockchain account, allowing blockchain accounts to sign, authorize and authenticate in DID based environments. </li> <li>3ID DID Method: A DID method that uses Ceramic's Tile Document StreamType to represent a mutable DID document. 3IDs are typically used for end-user accounts. When 3IDs are used in conjunction with the Identity Index protocol and the 3ID Keychain (as is implemented in 3ID Connect), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms.</li> <li>Key DID Method: A DID method statically generated from any Ed25519 key pair. Key DIDs are typically used for developer accounts. Key DID is lightweight, but the drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised.</li> <li>NFT DID Method (coming soon): A DID method for any NFT on any blockchain. The DID document is statically generated from on-chain data. The DID associated to the blockchain account of the asset's current owner (using CAIP-10 Links) is the only entity authorized to act on behalf of the NFT DID, authenticate in DID-based systems, and make updates to streams or other data owned by the NFT DID. When owenership of the NFT changes, so does the controller permissions.</li> <li>Safe DID Method (coming soon): A DID method for a Gnosis Safe smart contract on any blockchain. Typically used for organizations, DAOs, and other multi-sig entities.</li> </ul>"},{"location":"learn/advanced/overview/#ceramic-network","title":"Ceramic Network","text":"<p>The Ceramic Network is a decentralized, worldwide network of nodes running the Ceramic protocol that communicate over a dedicated topic on the Libp2p peer-to-peer networking protocol. Ceramic is able to achieve maximum horizontal scalability, throughput, and performance due to its unique design.</p>"},{"location":"learn/advanced/overview/#sharded-execution-environment","title":"Sharded execution environment","text":"<p>Unlike traditional blockchain systems where scalability is limited to a single global virtual execution environment (VM) and the state of a single ledger is shared between all nodes, each Ceramic node acts as an individual execution environment for performing computations and validating transactions on streams \u2013 there is no global ledger. This \"built-in\" execution sharding enables the Ceramic Network to scale horizontally to parallelize the processing of an increasing number of simultaneous stream transactions as the number of nodes on the network increases. Such a design is needed to handle the scale of the world's data, which is orders of magnitude greater than the throughput needed on a financial blockchain. Another benefit of this design is that a Ceramic node can perform stream transactions in an offline-first environment and then later sync updates with the rest of the network when it comes back online.</p>"},{"location":"learn/advanced/overview/#global-namespace","title":"Global namespace","text":"<p>Since all nodes are part of the same Ceramic Network, every stream on Ceramic exists within a single global namespace where it can be accessed by any other node or referenced by any other stream. This creates a public data web of open source information.</p>"},{"location":"learn/advanced/overview/#additional-node-responsibilities","title":"Additional node responsibilities","text":"<p>In addition to executing stream transactions according to StreamType logic, Ceramic nodes also maintain a few other key responsibilities:</p> <ul> <li>StreamState storage: A Ceramic node only persists StreamStates for the streams it cares to keep around, a process called \"pinning.\" Different nodes will maintain StreamStates for different streams, but multiple nodes can maintain the state of a single stream.</li> <li>Commit log storage: A Ceramic node maintains a local copy of all commits to the streams it is pinning.</li> <li>Persistence connectors: Ceramic nodes can optionally utilize an additional durable storage backend for backing up commits for streams it is pinning. This can be any of the persistence networks mentioned above, including Filecoin, Arweave, Sia, etc. (coming soon).</li> <li>Query responses: Ceramic nodes respond to stream queries from clients. If the node has the stream pinned, it will return the response; if not, it will ask the rest of the network for the stream over libp2p and then return the response.</li> <li>Broadcasting transactions: When a Ceramic node successfully performs a transaction on a stream, it broadcasts this transaction out the rest of the network over libp2p so other nodes also pinning this stream can update their StreamState to reflect this new transaction.</li> </ul>"},{"location":"learn/advanced/overview/#components-of-a-ceramic-node","title":"Components of a Ceramic Node","text":"<p>A fully functioning Ceramic Node consists of a Ceramic Instance with associated storages and requires a Ceramic Anchor Service (CAS) to be available on the network.</p> <p>The storage needs of a Ceramic Node include the Ceramic State Store and the IPFS repo.  See persisting IPFS data for details.</p> <p></p>"},{"location":"learn/advanced/overview/#clients","title":"Clients","text":"<p>Clients provide standard interfaces for performing transactions and queries on streams, and are installed into applications. Clients are also responsible for authenticating users and signing transactions.</p> <p>Currently there are three clients for Ceramic. Additional client implementations can easily be developed in other programming languages:</p> <ul> <li>JS HTTP client: A lightweight JavaScript client which connects to a remote Ceramic node over HTTP. The JS HTTP client is recommended for application developers.</li> <li>JS Core client: A JavaScript client which also includes a full Ceramic node. The JS Core client is for those who want the maximum decentralization of running the full Ceramic protocol directly in a browser application.</li> <li>CLI: A command line interface for interacting with a Ceramic node.</li> </ul>"},{"location":"learn/advanced/overview/#getting-started","title":"Getting started","text":""},{"location":"learn/advanced/overview/#try-ceramic","title":"Try Ceramic","text":"<p>To experience how Ceramic works in a browser application, try the Playground app.</p>"},{"location":"learn/advanced/overview/#installation","title":"Installation","text":"<p>Getting started with Ceramic is simple. Visit the Quick Start guide to learn the basics using the Ceramic CLI or follow the Installation page to integrate Ceramic into your project.</p>"},{"location":"learn/advanced/overview/#tools-and-services","title":"Tools and services","text":"<p>In addition to various standards referenced throughout this document, the Ceramic community has already begun delevoping many different open source protocols, tools, and services that simplify the experience of developing on Ceramic. Here are a few notable examples:</p> <ul> <li>3ID Connect: A authentication SDK for browser-based applications that allows your users to transact with Ceramic using their blockchain wallet.</li> <li>Identity Index (IDX): A protocol for decentralized identity that allows a DID to aggregate an index of all their data from across all apps in one place. IDX enables user-centric data storage, discovery, and interoperability. It is effectively a decentralized, cross-platform user table. IDX can reference all data source types, including Ceramic streams and other peer-to-peer databases and files.</li> <li>IdentityLink: A service that issues verifiable claims which prove a DID owns various other Web2 social accounts such as Twitter, Github, Discord, Discourse, Telegram, Instagram, etc. Once issued, claims are stored in the DID's Identity Index.</li> <li>Documint: A browser-based IDE for creating and editing streams.</li> <li>Tiles: An explorer for the Ceramic Network.</li> </ul>"},{"location":"learn/advanced/privacy/","title":"Privacy","text":"<p>This page describes various privacy aspects of the Ceramic protocol. Measures we've taken so far, planned future measures, and future research directions.</p>"},{"location":"learn/advanced/privacy/#ceramic-protocol","title":"Ceramic Protocol","text":"<p>The StreamType system is already quite flexible in terms of how streams can provide developers with privacy features.</p>"},{"location":"learn/advanced/privacy/#default-properties-of-tile-and-caip10links","title":"Default properties of Tile and Caip10Links","text":"<p>Currently if you create a TileDocument or Caip10Link stream any data put into it will be public by default. It's however possible to encrypt the content put into the stream by accessing the DID instance from Ceramic (<code>ceramic.did</code>) and using its encryption functionality as described in the How to store signed and encrypted data on IPFS blog post.</p>"},{"location":"learn/advanced/privacy/#confidential-streams","title":"Confidential streams","text":"<p>A planned improvement to the TileDocument StreamType is to add confidentiality. This basically means that the content of each update to the stream would be encrypted by a symmetric key. Whenever a Ceramic node syncs the stream it would only be able to read the stream content if it has the symmetric key for this stream. Stream metadata such as which DID signed the update, in what order, and when it was anchored would still be public.</p> <p>A StreamType without history like DIDPublish could further improve the situation somewhat since nodes that sync the stream would not see historical update metadata.</p>"},{"location":"learn/advanced/privacy/#private-streams","title":"Private streams","text":"<p>A fully private stream would mean that all of the data and metadata is encrypted.</p> <p>One approach to this is the one taken by Textile ThreadsDB which separates the notion of a follow key and a content key. This allows certain nodes to read the metadata and pin the stream, but without seeing the content, while other nodes can't see anything at all into the stream. So essentially streams are still only confidential to the trusted set of peers that have the follow key.</p> <p>A better approach could be to use some sort of zero-knowledge proof system to keep track of the tip of a set of streams anonymously. This is still a completely open research topic but would likely add some overhead to the party reading the stream. One upside here would be that this system could operate completely trustlessly unlike Textile ThreadsDB.</p>"},{"location":"learn/advanced/security/","title":"Security","text":"<p>This page describes various security aspects of the Ceramic protocol and miscellaneous systems like 3ID Connect.</p>"},{"location":"learn/advanced/security/#ceramic-protocol","title":"Ceramic Protocol","text":"<p>The main security properties that makes up Ceramic are cryptographic signatures, proof-of-publication (through blockchain anchors), and hash-linked data structures. Together these properties allows the construction of a verifiable data structure. In addition to this Ceramic relies on libp2p pubsub to gossip about stream updates.</p>"},{"location":"learn/advanced/security/#stream-data-structure","title":"Stream data structure","text":"<p>In general streams are made up of commits which are linked together as a DAG using hash links. This data structure is represented using IPLD. Commits always contain some sort of proof, usually this is a signature or a proof-of-publication. When a Ceramic node syncs a stream this linked DAG of commits can be verified locally and thus be fully trusted.</p> <p>Signed commits are generally signed by the controller of the stream. Different StreamTypes may have different rules about how the signature should be encoded. The TileDocument StreamType uses dag-jose to encode signatures. This format is recommended to be used by any new StreamTypes.</p> <p>A proof-of-publication is a proof that some content was published at some point in time. This is achieved by publishing the hash of the content on a blockchain. These proofs can be made more cost effective by putting multiple content hashes as leaves in a merkle tree and only publishing the root. The proof-of-publication provides a definite ordering of events in a stream, which is useful when you want to do key revocation in a secure manner.</p> <p>The linked commit DAG provides a logical ordering of events which is useful when constructing streams that use CRDT type logic. For a detailed description of these benefits reference the Merkle-CRDTs paper.</p>"},{"location":"learn/advanced/security/#conflict-resolution-strategies","title":"Conflict resolution strategies","text":"<p>Different StreamTypes in Ceramic may have different conflict resolution strategies with different security properties.</p> <p>The earliest anchor rule solves any conflict in the history of a stream by picking the stream that was anchored at the earliest point in time. This enables keys to be securely revoked since someone that gains possession of an old key after it was revoked will be unable to produce a proof-of-publication that is earlier than the first anchor. This is used in the 3ID DID Method which registers a set of public keys associated to a DID URL, when the 3ID stream is updated with new public keys, revoking the old keys, an outside observer can be sure of the state of the 3ID without any secondary sources of information. 3IDs are built on top of the TileDocument stream type, and alternative DID methods could also be built on top of it.</p> <p>A drawback with the \"earliest anchor rule\" is that the controller of the stream can create anchored commits in secret and reveal them at a later point in time to change the history of the stream. There are various ways to mitigate this. One of them is to only allow anchor services that actively publish all created anchor commits when they are created.</p> <p>The latest nonce rule solves any conflict by simply picking the signed commit which includes the largest nonce. This strategy doesn't support key revocation, so the controller of a stream with this strategy can't be changed. Ceramic doesn't support this strategy yet, but it is required for StreamTypes like DIDPublish. In the future The Caip10Link StreamType may also be updated to use this strategy for efficiency reasons.</p>"},{"location":"learn/advanced/security/#network-gossip","title":"Network gossip","text":"<p>Ceramic nodes use libp2p pubsub to gossip about stream tips. The two operations that happen in the gossip is publication of stream updates and queries for tips by nodes that load a specific stream. The main security consideration for a Ceramic node is that any new tip that comes in for a stream which it cares about could be a fake or invalid tip for that stream and thus needs to be verified.</p>"},{"location":"learn/advanced/security/#dos-attack","title":"DoS attack","text":"<p>A malicious node can spam the pubsub topic by sending a lot of messages. This may be randomly generated messages that are not even for valid streams, or it could be invalid tips for valid streams that get rejected by the stream update rules (the \"false log attack\" explained below). The main counter attack for this is to limit the amount of messages a single node can send by having an automated reputation system that disconnects from nodes which are spammy. No such reputation systems exists in ceramic today, though it is planned as a future improvement.</p>"},{"location":"learn/advanced/security/#false-log-attack","title":"False log attack","text":"<p>A malicious node can spam nodes that pin specific streams by sending faulty commit logs. The unsuspecting node would sync the log of the stream and find it invalid, at which point the node would throw out the faulty log without applying it to its local copy of the stream's state. However, if the false log is long and the malicious node sends multiple of these it may cause a significant amount of overhead. The most simple countermeasure to this is to simply stop accepting tips from nodes which have proven to not be reliable. A more significant approach would be to build a StreamType that includes a recursive zero-knowledge proof that the log is indeed correctly associated with the given streamid.</p>"},{"location":"learn/advanced/security/#caip10link-clock-synchronization","title":"Caip10Link clock synchronization","text":"<p>Currently the Caip10Link streamtype relies on system time on the client machine to mitigate replay attacks. A new update to a Caip10Link stream is only valid if the proof includes a timestamp that is larger than the timestamp of the previous update. This presents a problem however if the users system time for some reason is incorrectly far into the future. Users would at this point be unable to prevent a replay attack using a proof created on this machine. The replay attack could be used to reset a Caip10Link to point to any DID it had previously been linked to. A possible workaround could be to switch to using a <code>nonce</code> which is always incremented by one, or include the <code>prev</code> pointer to the previous commit in the proof.</p>"},{"location":"learn/network/clients/","title":"Network Overview","text":"<p>Ceramic is a decentralized network of nodes that run the Ceramic protocol.</p>"},{"location":"learn/network/clients/#clients","title":"Clients","text":"<p>Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network.</p>"},{"location":"learn/network/clients/#responsibilities","title":"Responsibilities","text":""},{"location":"learn/network/clients/#api-interface","title":"API Interface","text":""},{"location":"learn/network/clients/#authenticate-users","title":"Authenticate users","text":""},{"location":"learn/network/clients/#sign-records","title":"Sign records","text":""},{"location":"learn/network/clients/#add-more","title":"Add more","text":""},{"location":"learn/network/clients/#client-implementations","title":"Client Implementations","text":"<ul> <li>HTTP Client</li> <li>JS Client</li> <li>CLI Client</li> </ul>"},{"location":"learn/network/clients/#nodes","title":"Nodes","text":"<p>Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes.</p>"},{"location":"learn/network/clients/#networking","title":"Networking","text":""},{"location":"learn/network/clients/#network-connection","title":"Network connection","text":"<p>Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network.</p>"},{"location":"learn/network/clients/#gossip-updates","title":"Gossip updates","text":"<p>Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network.</p>"},{"location":"learn/network/clients/#query-responses","title":"Query responses","text":"<p>Nodes are responsible for responding to queries about any document that it has. If the node has the document in its cache it will respond directly, but if if doesn't have it, it will ask other nodes on the network for it using libp2p.</p>"},{"location":"learn/network/clients/#storage","title":"Storage","text":""},{"location":"learn/network/clients/#loading-documents","title":"Loading documents","text":"<p>Nodes can ask other nodes for a document and it will sync it from the network and load it in memory. This includes the entire document log (contents) and its most recent tip (state).</p>"},{"location":"learn/network/clients/#cachingpinning-documents","title":"Caching/Pinning documents","text":"<p>Ceramic nodes use an instance of IPFS for short-term pinning/caching the documents that they care about. For each document that it cares about, a node will cache its document log and its tip. Nodes cache the Ceramic nodes come prepackaged with an internal IPFS node, but an externally run IPFS node may be used instead. (add something in here about garbage collection?)</p>"},{"location":"learn/network/clients/#persistence-coordination","title":"Persistence coordination","text":"<p>Ceramic nodes may optionally specify one or more external service(s) for the long-term storage of documents. If specified, the node is responsible for forwarding document records to this service. Learn more about persistence options.</p>"},{"location":"learn/network/clients/#transactions","title":"Transactions","text":""},{"location":"learn/network/clients/#authentication","title":"Authentication (??)","text":"<p>Nodes take a DID provider instance and allow that authenticated user to perform transactions.</p>"},{"location":"learn/network/clients/#record-validation","title":"Record validation","text":"<p>Nodes receive records (from clients (or anchor services?)) and then validate that these records conform to the rules of the document's specified doctype.</p>"},{"location":"learn/network/clients/#record-application","title":"Record application","text":"<p>Nodes apply only valid records to the document's document log. Invalid or malformed records are discarded.</p>"},{"location":"learn/network/clients/#anchor-service-coordination","title":"Anchor service coordination","text":"<p>After applying a genesis record or signed record to the document log, nodes then send these records to the HTTP endpoint of an anchor service which anchors it in a blockchain. After successfully anchoring the record, the anchor service sends back an anchor record over libp2p which is then applied to the document log by the node.</p>"},{"location":"learn/network/clients/#conflict-resolution","title":"Conflict resolution","text":"<p>Should this be its own category, or should this live elsewhere?</p>"},{"location":"learn/network/clients/#anchor-services","title":"Anchor Services","text":""},{"location":"learn/network/clients/#responsibilities_1","title":"Responsibilities","text":""},{"location":"learn/network/clients/#blockchain-anchoring","title":"Blockchain anchoring","text":"<p>The primary responsibility of an anchor service is to generate anchor records by committing signed records into a blockchain. All of the responsibilities below are in service of this primary responsibility.</p>"},{"location":"learn/network/clients/#merkle-tree-construction","title":"Merkle tree construction","text":"<p>Constructs a merkle tree of all signed records that eill be simultaneously committed to a blockchain in a single hash, called a merkle root.</p>"},{"location":"learn/network/clients/#anchor-metadata","title":"Anchor metadata","text":"<p>Bloom filter, helps with indexing services.</p>"},{"location":"learn/network/clients/#anchor-status-messages","title":"Anchor status messages","text":"<p>Sends messages to the pubsub room specified for the Ceramic network that the anchor service is servicing. This allows Ceramic nodesLearn more about anchor status messages.</p>"},{"location":"legacy/","title":"Legacy Ceramic Tools","text":"<p>We recommend building your app with the most current developer tooling available. Build with ComposeDB: A Decentralized Graph Database for Web3 Apps \u2192.</p> <p>This section contains docs for various legacy Ceramic developer tools that are no longer actively maintained. Some apps are still using these tools and need the docs, otherwise they would be deleted. The tools in this section make use of the IDX Database, a legacy and far less powerful DB alternative to ComposeDB.</p>"},{"location":"pages/3box-migration/","title":"3ID Migration: 3Box to Ceramic","text":"<p>If you have used 3Box with 3ID-Connect in the past, you will already have an existing 3ID. No additional steps have to be taken to migrate your existing 3ID to the Ceramic network. When you interact with any application on Ceramic through 3ID-Connect, your 3ID will automatically be migrated.</p> <p>The migration includes moving your 3ID and control of your 3ID to the Ceramic network, migrating your 3Box profile to the profile definition and schema in IDX, and lastly migrating your address, Twitter and Github links.</p> <p>Any additional data in 3Box may or may not be migrated by the applications themselves built on 3Box. Those applications will guide you through any additional migration steps if necessary.</p>"},{"location":"pages/3box-migration/#migration-difficulties","title":"Migration Difficulties","text":"<p>Most users will be able to migrate without difficulty, but there is a number of known instances where we can not easily migrate your 3ID. In theses cases we will create a new 3ID for you and partially migrate any data that we can. You will be able to re-add any profile data and social links that fail to migrate in the future.</p> <p>Very Early 3Box Users</p> <p>Early 3Box users will have muport DIDs instead of the now standard 3ID DID implementation. For future interoperability in Ceramic and to take advantage of all the features in 3ID we have chosen not to migrate these DIDs. When you use 3ID-Connect on Ceramic we will detect that you have a muport DID and instead create a new 3ID for you. We will still migrate your profile data if we can, but will not migrate your Twitter and Github links.</p> <p>Multiple Linked Accounts</p> <p>There was a known past bug in 3Box that resulted in multiple addresses being linked to a DID in an unexpected way. When you use 3ID-Connect on Ceramic we will detect that you have one of these accounts and instead create a new 3ID for you. Users accounts that have this issue may not have expected to link these accounts, so we will not migrate your profile data or your social links.</p> <p>Migration Failures</p> <p>3Box existed for a while before Ceramic and we may have not built support for all prior existing formats. If migration fails at any point during the process, we will still attempt partial migrations when we can and continue with a best effort migration. If migration fails during 3ID migration, we will create a new 3ID and try to migrate your profile data still. If migration fails during profile or social link migration, we will return your migrated 3ID anyways.</p>"},{"location":"pages/3box-migration/#for-developers","title":"For Developers","text":"<p>You can find more details in this blog post, if you are interested in the more technical details of the migration or in migrating your own application from 3Box to Ceramic.</p>"},{"location":"pages/3box-migration/#questions-or-support","title":"Questions or support?","text":"<p>We're always available to answer any questions and help you through this migration. Reach out to us in the\u00a0Ceramic Discord\u00a0for assistance.</p>"},{"location":"pages/3boxlabs-privacy-policy/","title":"Privacy Policy","text":"<p>Last Updated: January 20, 2020</p> <p>This Privacy Policy (\u201cPolicy\u201d) describes how 3Box Labs, our related products, including but not limited to Ceramic, IDX, and self.ID(\u201cwe\u201d, \u201cour\u201d, or \u201cus\u201d) collects, uses, shares, and stores Personal Information when app developers and other users (\u201cyou\u201d) use 3Box Labs, Ceramic, IDX, self.ID, and all related tools, applications, websites, data, software, infrastructure, and other services we provide (the \u201cProducts, Services, and Network\u201d). By accessing or using the Products, Services, and Network you accept this Policy and our Terms and Conditions, and you consent to our collection, use, disclosure, and retention of your Personal Information as described in this Policy. If you do not agree with any part of this Policy or our Terms and Conditions, you must stop accessing the Products, Services, and Network. To exercise any rights you may have over your Personal Information, please see the section on Your Choices below.</p>"},{"location":"pages/3boxlabs-privacy-policy/#decentralized-data-storage","title":"DECENTRALIZED DATA STORAGE","text":"<p>Our Products, Services, and Network are blockchain-agnostic and leverage distributed-data-storage systems, so nearly all data is kept directly with you and other users and not on our servers, computers, or other systems and devices. To help you manage your data and content, our Products and Services allow you to create and link an Account or Decentralized ID (\u201cDID\u201d). These features are intended to give you more control over your data and privacy-preserving options to choose how your Personal Information is shared and used by other applications or services. For example, to the extent any data is stored privately on the Products and Services, it is unreadable by other apps and users unless you expressly grant others permission to access your data.</p> <p>If you shared your data with other users or a third-party app hosted on or linked to the Products, Services, and Network, you should look to the privacy policy and any terms those third parties or dApps. We do not control third-party apps and are not responsible for how they may treat your Personal Information.</p>"},{"location":"pages/3boxlabs-privacy-policy/#what-we-collect","title":"WHAT WE COLLECT","text":"<p>When you visit our Sites or use our Products, Services, and Network, we may collect information that could identify you directly or indirectly (\u201cPersonal Information\u201d). Personal Information does not include publicly available information or any data that has been deidentified, aggregated, or otherwise anonymized. We only collect the minimum information needed to provide the Products, Services, and Network including:</p> <ul> <li>Identifying Information. To enable you to use our Products, Services, and Network, control your data, and send and receive information, we may collect your public key or DID to identify you.   Account Information. To use certain features of the Products, Services, and Network you must create an Account or DID and provide information such as your Ethereum public key, or other form of authentication. You may also choose to enhance your profile with your name, photo, GitHub account, or other information.</li> <li>User Content. If you share files, content, messages, and other data (\u201cUser Content\u201d) on the Products, Services, Networks, or any third-party apps we may have access to User Content.</li> <li>Cookie Log Data. Our Site uses Cookies to collect your Internet Protocol (IP) address, device identifiers, browser type, and browsing activity (\u201cLog Data\u201d). We use this information to improve functionality and customize the Product, Services, and Network. See the section on Cookies below for more information.</li> <li>Signatures. To enable you to use our Products, Services, or Network, we may prompt you to sign messages with your private key or wallet seed as a way to authenticate and prove control over your key and identity. We are not able to see your private key or wallet seed.</li> </ul> <p>We will never ask you to share your private keys, wallet seed, or other sensitive Personal Information. Trust no one that asks you to enter your private keys or wallet seed.</p>"},{"location":"pages/3boxlabs-privacy-policy/#cookies","title":"COOKIES","text":"<p>Cookies, tags, and similar technologies are small pieces of code placed on your browser, device, or hard drive when you visit a website or use an application (\u201cCookies\u201d).</p> <ul> <li>How We Use Cookies. We may use Cookies for the following reasons:</li> <li>Functionality. To ensure they function properly;</li> <li>Security. To help detect fraud and abuse, including malicious attempts to access data without authorization;</li> <li>Analytics. To gather usage and performance data;</li> <li>Advertising. To collect information about how you interact with our website, and your activity to draw inferences about your preferences.</li> <li> <p>How to Control Cookies. If you wish to prevent cookies from tracking your activity on our website or visits across multiple websites, you can set your browser to block certain cookies or notify you when a cookie is set. If you block cookies, certain features on the Products, Services, or Network may not work.</p> </li> <li> <p>You may control Google analytics by visiting Google\u2019s website.</p> </li> <li> <p>You may control cookies by visiting the link below to your web browser below:</p> <ul> <li>Chrome</li> <li>Safari</li> <li>Internet Explorer</li> <li>Mozilla</li> </ul> </li> <li> <p>You may opt-out of interest-based advertising by visiting the Digital Advertising Alliance\u2019s or Network Advertising Initiative\u2019s websites.</p> </li> </ul> <p>We are not responsible for the completeness, effectiveness, or accuracy of any of these or other third party opt-out options or programs.</p> <ul> <li>Do Not Track Requests. Some web browsers or smartphones can set \u201cDo Not Track\u201d requests to block user activity from being tracked across web pages or devices. We do not recognize \u201cDo Not Track\u201d signals because there is no industry standard way to do so.</li> </ul> <p>Change cookie settings</p>"},{"location":"pages/3boxlabs-privacy-policy/#use-of-personal-information","title":"USE OF PERSONAL INFORMATION","text":"<p>We use the Personal Information we collect for:</p> <ul> <li>Functionality. To enable you to access the Site and use the Products, Services, and Network and deliver products or perform actions you request, for example enabling you to create an Account, DID, or develop apps.</li> <li>Communications. To inform you about relevant promotions, upcoming events, and other news about the Products, Services, or Network and our select partners. We may also use your Personal Information to respond to your comments and questions about the Products, Services, and Network and to provide customer service.</li> <li>System Updates or Alerts. To send information, including confirmations, technical notices, updates, security alerts, and support and administrative messages.</li> <li>Optimization. To optimize your user experience, we may use your Personal Information to operate, maintain, and improve our Products, Services, and Network.</li> <li>Compliance with the Law. To comply with applicable laws, regulations, lawful requests, and other legal process, such as to respond to subpoenas or requests from government authorities.</li> <li>Fraud Prevention and Safety. To protect, investigate, and deter against fraudulent, unauthorized, illegal activity, or unauthorized access to or use of Personal Information, our Products, Services, and Network or related systems.</li> </ul> <p>We may use Personal Information for other limited purposes consistent with the purposes for which we collected that information. We will not use Personal Information for materially different or incompatible purposes without first taking reasonable steps to notifying you and, if necessary, obtain your consent.</p>"},{"location":"pages/3boxlabs-privacy-policy/#sharing-personal-information","title":"SHARING PERSONAL INFORMATION","text":"<p>We only disclose or share Personal Information with others with your consent or when permitted by applicable law, including under these circumstances:</p> <ul> <li>Professional Advisors and Service Providers. We may share information with those who need it to do work for us. These recipients may include third-party companies and individuals to administer and provide the Products, Services, and Network on our behalf (such as customer support, hosting, email delivery and database management), and lawyers, bankers, auditors, and insurers.</li> <li>Affiliates. We may disclose Personal Information to our other brands, subsidiaries, and corporate affiliates for purposes consistent with this Privacy Policy.</li> <li>Third Parties. You may enable settings and features that enable your Personal Information to be available to or shared with other users, companies, or entities of your choosing. We do not control those third parties and we are not responsible for how they may treat your Personal Information. You should look to those third parties\u2019 privacy policy and terms to understand how they treat your Personal Information and what rights you may have.</li> <li>Business Transfers. We may share personal information when we do a business deal or transfer that includes the sale or transfer of all or a part of our business or assets, for example in any merger, financing, acquisition, or bankruptcy transaction or proceeding.</li> <li>Compliance with Laws and Law Enforcement; Protection and Safety. We may share Personal Information for legal, protection, and safety purposes, including to:</li> <li>Comply with laws;</li> <li>Respond to lawful requests, court order, and other legal processes;</li> <li>Protect the rights, freedoms, and property of the Company, our agents, customers, and others; or,</li> <li>Respond to an emergency concerning the safety or wellbeing of our employees, agents, our customers, or any other person.</li> </ul>"},{"location":"pages/3boxlabs-privacy-policy/#how-information-is-secured","title":"HOW INFORMATION IS SECURED","text":"<p>We retain Personal Information only for as long as it is necessary and relevant to fulfill the purposes for which it was collected. We may retain Personal Information longer if we must do so to comply with applicable law. Once we no longer need to retain Personal Information, we permanently delete it or we may anonymize it so the Information can no longer be associated with a specific individual. We use industry-standard security measures to protect the security and confidentiality of Personal Information. However, the security of information transmitted through or stored on the internet can never be guaranteed. To the fullest extent permitted by law, we are not responsible for any interception, interruption, or loss of data through the internet. You are responsible for maintaining the security of any password, user ID or other form of authentication involved in obtaining access to password-protected or secure areas of any of our Products, Services, and Network. We may suspend use of any aspect of the Products, Services, and Network without notice if we suspect any breach of security or similar issues.</p>"},{"location":"pages/3boxlabs-privacy-policy/#third-party-applications-or-websites","title":"THIRD-PARTY APPLICATIONS OR WEBSITES","text":"<p>Our Products, Services, and Network allow you to share information through other third-party applications, including dApps, or websites. These links are provided solely as a convenience to you if you share content. When you visit third-party websites or applications, those third parties may collect your Personal Information along with all content you share. We do not control those websites and applications, and we are not responsible for how they may treat your information. We encourage you to check the privacy policies and terms of those websites and applications to learn more about their practices.</p>"},{"location":"pages/3boxlabs-privacy-policy/#your-choices","title":"YOUR CHOICES","text":"<p>You may review, opt-out of sharing, correct, or delete your Personal Information through your Account at any time or by contacting us at support@3box.io.</p>"},{"location":"pages/3boxlabs-privacy-policy/#california-residents","title":"California Residents","text":"<p>California residents may have additional rights over their Personal Information.</p>"},{"location":"pages/3boxlabs-privacy-policy/#the-right-to-request-more-information","title":"The Right to Request More Information","text":"<p>You may have the right to request more information about how we treated your Personal Information in the past 12 months, including:</p> <ul> <li>The categories of Personal Information we collected about you;</li> <li>The categories of sources from which we collected that information;</li> <li>Our business or commercial purpose for collecting that information;</li> <li>The categories of third parties with whom we shared that information; and/or</li> <li>The specific pieces of Personal Information we collected about you.</li> </ul>"},{"location":"pages/3boxlabs-privacy-policy/#the-right-to-request-access","title":"The Right to Request Access","text":"<p>You also may have the right to request access to your Personal Information.</p>"},{"location":"pages/3boxlabs-privacy-policy/#the-right-to-request-deletion","title":"The Right to Request Deletion","text":"<p>Under certain conditions, you may have the right to request that we delete your Personal Information. Simply logging out does not delete your account or the Personal Information we may have collected.</p>"},{"location":"pages/3boxlabs-privacy-policy/#third-party-marketing-and-selling","title":"Third-Party Marketing and Selling","text":"<p>We do not provide your information to third parties for their direct marketing purposes. Neither do we intend to sell your personal information to third parties without providing you notice and an opportunity to opt out.</p>"},{"location":"pages/3boxlabs-privacy-policy/#how-to-exercise-your-rights","title":"How to Exercise Your Rights","text":"<p>To submit a request to exercise these rights you may contact us at support@3box.io. For all requests, please clearly state that the request is related to \u201cYour California Privacy Rights\u201d and provide your name, Account or DID name, Ethereum public key and an e-mail address or mailing address where you may be reached. If you make a request, we will acknowledge we have received it within ten days. If you do not receive a response, please ensure your request was submitted and send a follow up email to support@3box.io.</p>"},{"location":"pages/3boxlabs-privacy-policy/#verification","title":"Verification","text":"<p>Before we can respond to your request, we must verify your identity using Personal Information. If we cannot verify your request, we will contact you for more information. If we cannot verify your identity after a good faith attempt, we may deny the request and, if so, will explain the basis for the denial.</p>"},{"location":"pages/3boxlabs-privacy-policy/#designating-an-authorized-agent","title":"Designating an Authorized Agent","text":"<p>You may designate someone to submit requests and act on your behalf (an \u201cAuthorized Agent\u201d). To do so, you must provide us with written permission to allow your Authorized Agent to act on your behalf.</p>"},{"location":"pages/3boxlabs-privacy-policy/#eu-data-subjects","title":"EU Data Subjects","text":"<p>If you are located in the European Economic Area, you may have additional rights over your Personal Information.</p>"},{"location":"pages/3boxlabs-privacy-policy/#sensitive-data","title":"Sensitive Data","text":"<p>Some of the information you provide us may constitute sensitive data as defined in the GDPR (also referred to as special categories of personal data), including identification of your race or ethnicity on government-issued identification documents.</p>"},{"location":"pages/3boxlabs-privacy-policy/#legal-basis-for-processing","title":"Legal Basis for Processing","text":"<p>We only use your Personal Information as permitted by applicable law, including:</p> <ul> <li>With your Consent. You may choose to provide or share your Personal Information and consent to our processing of that Information. Where our use of your Personal Information is based upon your consent, you may withdraw consent anytime by adjusting your Account settings, refraining from accessing the Site or using the Products, Services, and Network or contacting us at support@3box.io.</li> <li>Legitimate Interests. Where processing is not based on your consent, we rely on our Legitimate Interests to accomplish the uses listed above. We consider and balance any potential impacts on you or your rights before we process your Personal Information for our Legitimate Interests. We do not use your Personal Information for activities where our interests are overridden by any adverse impact to you.</li> <li>Compliance with a Legal Obligation. We may need to process Personal Information to comply with applicable laws, regulations, or other legal requirements.</li> </ul>"},{"location":"pages/3boxlabs-privacy-policy/#international-transfers","title":"International Transfers","text":"<p>We operate from the United States. This means your Personal Information may be transferred to or from the United States where privacy laws may not be as protective as those in your jurisdiction. We transfer Personal Information between the European Economic Area (\u201cEEA\u201d) and the U.S. or other countries based on a data transfer mechanism recognized by the European Commission as adequately protecting personal information.</p>"},{"location":"pages/3boxlabs-privacy-policy/#retention","title":"Retention","text":"<p>We will maintain your Personal Information for as long as reasonably necessary to accomplish the purposes for which it was collected, or as otherwise required or permitted by law.</p>"},{"location":"pages/3boxlabs-privacy-policy/#data-subject-rights","title":"Data Subject Rights","text":"<p>If you are an individual in the EEA, you have the following additional rights over your Personal Information:</p> <ul> <li>Access. You have the right to request copies of your personal information. We may charge you a small fee for this service.</li> <li>Rectification. You have the right to request that we correct any information you believe is inaccurate. You also have the right to request we complete information you believe is incomplete. You may always correct and update your information by logging onto your Account and editing your information.</li> <li>Erasure. Under certain conditions, you have the right to request that we delete your personal information.</li> <li>Restrict processing. Under certain conditions, you have the right to object to the processing of your personal information.</li> <li>Data portability. Under certain conditions, you have the right to request we transfer personal information we have collected about you either to another organization, or directly to you.</li> </ul>"},{"location":"pages/3boxlabs-privacy-policy/#how-to-exercise-your-rights_1","title":"How to Exercise Your Rights","text":"<p>To submit a request to exercise these rights please contact us: Email: support@3box.io. For all requests, please clearly state that the request is related to \u201cYour EU Privacy Rights\u201d and provide your name, Account or DID name, Ethereum public key and an e-mail address or mailing address where you may be reached. If you make a request, we have one month to respond to you. We may require you to verify your identity before we may respond to you. Although we urge you to contact us to find a solution for every concern, you have the right to lodge a complaint with your competent data protection authority.</p>"},{"location":"pages/3boxlabs-privacy-policy/#children","title":"CHILDREN","text":"<p>The Products, Services, and Network are not intended for children under age 13, and we do not knowingly collect Personal Information from children under 13. If we discover we have Personal Information related to a child under 13 we will delete that information. If you are under the age of majority in your jurisdiction of residence, you may use the Products, Services, and Network only with the consent of or under the supervision of your parent or legal guardian. If you are the parent or legal guardian of a child under 13 or minor and you believe we have collected your child has used our Site or Products and Services without your permission, please contact us at support@3box.io.</p>"},{"location":"pages/3boxlabs-privacy-policy/#changes-to-this-privacy-policy","title":"CHANGES TO THIS PRIVACY POLICY","text":"<p>We may change this Policy. We encourage you to periodically review this page for the latest information on our privacy practices. If we make any material changes, we will take reasonable steps to notify you and, if necessary, obtain your consent. We will take your continued use of the Products, Services, and Network after any new Policy is posted as an indication you accept the modified Privacy Policy.</p>"},{"location":"pages/3boxlabs-privacy-policy/#contact-us","title":"CONTACT US","text":"<p>If you have questions or concerns about this Policy, please contact us at support@3box.io.</p>"},{"location":"pages/3boxlabs-terms-conditions/","title":"Terms and Conditions","text":"<p>Last Updated: January 20, 2020</p> <p>3Box Labs, our related products, including Ceramic, IDX, and self.ID, and our officers, employees, agents, affiliates, successors, and assigns (\u201cwe\u201d, \u201cour\u201d, or \u201cus\u201d) provide software for distributed infrastructure that allows people, companies, organizations and other entities (\u201cyou\u201d including any entity you may represent) to store, publish and selectively share content and information. The technology we provide is intended to empower users with control of their own data, agency in how it is used, and privacy where they want it. It is built to technologically assure that no company, including 3Box Labs, can access or exploit user data without express permission. To meet these goals, 3Box Labs has built a suite of products and services that are in active development. Please check these Terms and Conditions regularly to ensure you have the most up to date and relevant information. These Terms and Conditions (\u201cTerms\u201d) govern your use of 3Box Labs, Ceramic, IDX, self.ID, and all related tools, applications, websites, data, software, infrastructure, and other services we provide and to which these terms are attached (collectively our \u201cProducts, Services, and Network\u201d). Certain features of the Products, Services, and Network may be subject to additional guidelines, terms, or rules, which will be posted in connection with such features (\u201cAdditional Terms\u201d).</p> <p>IMPORTANT: Please read these Terms carefully because they are a legally binding contract between you, including the entity you may represent, and us. These Terms contain important information about your rights and responsibilities when accessing the Products, Services, or Network.</p> <p>IF THERE IS A LEGAL DISPUTE REGARDING THESE TERMS OR OUR PRODUCTS AND SERVICES, THE PARTIES AGREE TO RESOLVE ALL SUCH DISPUTES THROUGH BINDING ARBITRATION, TO THE MAXIMUM EXTENT PERMITTED BY LAW THE PARTIES WAIVE ANY RIGHT TO A JURY TRIAL, BENCH TRIAL, OR CLASS ACTION. BY ACCESSING OR USING THE PRODUCTS, SERVICES, OR NETWORK YOU ACKNOWLEDGE AND ACCEPT THESE TERMS AND CONDITION, OUR PRIVACY POLICY, AND ANY ADDITIONAL TERMS THAT MAY APPLY. IF YOU DO NOT AGREE WITH ALL OF THESE TERMS, OR SUBSEQUENT MODIFICATIONS OF WHICH YOU ARE PROVIDED NOTICE, YOU MAY NOT ACCESS, USE, OR CONTINUE TO ACCESS OR USE THE PRODUCTS, SERVICES, OR NETWORK.</p>"},{"location":"pages/3boxlabs-terms-conditions/#1-accounts","title":"1. ACCOUNTS","text":"<p>1.1 Eligibility. The Products, Services, and Network are not intended for children under age 13, and we do not knowingly collect Personal Information from children under 13. If we discover we have Personal Information related to a child under 13 we will delete that information. If you are under the age of majority in your jurisdiction of residence, you may use the Products, Services, and Network only with the consent of your parent or legal guardian. If you are the parent or legal guardian of a child under 13 or minor and you believe your child has used our Products, Services, or Network without your permission, please contact us at support@3box.io.</p> <p>1.2 Account Creation. To use certain features of the Products, Services, or Network, you must create or link a profile, or decentralized ID (\u201cDID\u201d) and public key (\u201cAccount\u201d). After this, you may choose to add other contact information such as your name, photo or GitHub account to your profile. You may delete your profile at any time, for any reason, by following the instructions on the applicable Product, Service, or Network. We may suspend or terminate your access to the Products, Services, or Network if you violate these Terms or applicable law.</p> <p>1.3 Account Privacy. You are responsible for maintaining the confidentiality of your Account login information and are responsible for all activities that occur under your Account. You may also choose to authorize other users, platforms, or apps to interact with you through your Account, including permission to view or update your profile and access any of your content, files, code, messages, and other data (your \u201cUser Content\u201d). Each user, party, application, website, product, or service to whom you choose to provide private access can view your User Content. With permission they can also store additional data or data in your Account. You should not use our Products, Services, or Network to store or share sensitive personal data that you do not want to make accessible to others.</p> <p>1.4 Account Security. You are responsible for ensuring that any networks, computers, or other systems and devices (\u201cComputer Networks\u201d) in your control are reasonably secured from the risk of unauthorized access, disruption, or compromise. You agree to immediately notify us of any actual or suspected unauthorized use of your Account, User Content, or any other breach of security by contacting us at support@3box.io. We are not responsible for security issues that result from your failure to maintain the privacy or security of your own Account and Computer Networks. If your activity causes or contributes to a breach of security on any related Computer Network, you may be required to indemnify us for any costs, damages, or other losses as a result. See Section 6.3 on Indemnification for more information.</p>"},{"location":"pages/3boxlabs-terms-conditions/#2-acceptable-use-of-the-products-services-and-network","title":"2. ACCEPTABLE USE OF THE PRODUCTS, SERVICES, AND NETWORK","text":"<p>2.1 Acceptable Use. When accessing the or using the Products, Services, and Network you agree not to:</p> <p>i. Upload, transmit, or distribute to or through the Products, Services, or Network any computer viruses, worms, or any software intended to damage or alter a computer system or data, including computer viruses, works, time bombs, Trojan horses, and other harmful or malicious code, routines, files, scripts, agents, or programs;</p> <p>ii. Send unsolicited or unauthorized advertising, promotional materials, junk mail, spam, chain letters, pyramid schemes, or any other form of duplicative or unsolicited messages, whether commercial or otherwise;</p> <p>iii. Harvest, collect, gather or assemble information or data regarding other users, including email addresses, without a legal basis to do so;</p> <p>iv. Interfere with, disrupt, or create an undue burden on servers or networks connected to the Products, Services, or Network, or violate the regulations, policies or procedures of such networks;</p> <p>v. Attempt to gain unauthorized access to the Products, Services, or Network (or to other computer systems or networks connected to or used together with the Products, Services,or Network), whether through password mining or any other means; or,</p> <p>vi. Harass, threaten, or otherwise interfere with any other user\u2019s use and enjoyment of the Products, Services, or Network.</p> <p>2.2 Ownership. Excluding any User Content you may create, you acknowledge that all the intellectual property rights, including copyrights, patents, trademarks, and trade secrets, in the Products, Services, and Network and their content are owned by 3Box Labs, Ceramic, IDX, or self.ID, respectively. Neither these Terms (nor your access to or use of Products, Services, or Network) transfers to you or any third party any rights, title, or interest in or to such intellectual property, except for the limited use and access rights expressly set forth below in Section 2.3. There are no implied licenses granted under these Terms, and we reserve all rights not granted in these Terms.</p> <p>2.3 License. Subject to these Terms, we grant you a non-transferable, non-exclusive, revocable, limited license to use and access the Products, Services, and Network for their intended, lawful purposes.</p> <p>2.4 Restrictions. The limited rights granted to you in these Terms are subject to restrictions, including that you shall not:</p> <p>i. License, sell, rent, lease, transfer, assign, distribute, host, or otherwise commercially exploit the Products, Services, or Network, whether in whole or in part, or any content displayed on the Products, Services, or Network;</p> <p>ii. Modify, make derivative works of, disassemble, reverse compile or reverse engineer any part of the Products, Services, or Network, except as expressly permitted in writing;</p> <p>iii. Access the Products, Services, or Network to build a similar or competitive website, product, platform, or service;</p> <p>iv. Copy, reproduce, distribute, republish, download, display, post, or transmit in any form or by any means any part of the Products, Services,or Network unless expressly stated otherwise in these Terms; or,</p> <p>v. Store or distribute any information, material or data that is infringing, unlawful, or which violates the privacy or intellectual property rights of any third party.</p> <p>2.5 Enforcement. We reserve the right to enforce these Terms and investigate or take appropriate action against you, in our sole discretion, if you violate the Acceptable Uses, Restrictions, or any other provision of these Terms. This may include clocking your access, removing or destroying User Content, and reporting you to law enforcement authorities.</p> <p>2.6 Feedback. Should you encounter any bugs, glitches, lack of functionality or other problems on the Products, Services, or Network, please let us know by contacting us at support@3box.io. We appreciate your feedback as it helps us develop the Products, Services, or Network and offer the best service possible. If you provide any feedback or suggestions regarding the Products, Service, or Network (\u201cFeedback\u201d), you assign to 3Box Labs all rights in such Feedback and agree that we shall have the right to use and fully act on such Feedback and related information as we deem appropriate. We will treat any Feedback you provide to us as non-confidential and non-proprietary. You agree that you will not submit any information or ideas you consider confidential or proprietary.</p> <p>2.7 Modification. We reserve the right, at any time, to modify, suspend, or discontinue the Products, Services, or Network (in whole or in part) with or without notice to you. You agree that we will not be liable to you or to any third party for any modification, suspension, or discontinuation of the Products, Services, and Network or any part thereof.</p> <p>2.8 No Support or Maintenance. You acknowledge and agree that we have no obligation to provide you with any support or maintenance in connection with the Products, Services, and Network.</p>"},{"location":"pages/3boxlabs-terms-conditions/#3-user-content","title":"3. USER CONTENT","text":"<p>3.1 Creating User Content. When you use our Products, Services, and Network, you may provide things such as code, your files, content, messages, and other data (\u201cUser Content\u201d). You may choose to share User Content publicly, in which case it will be accessible and viewable by anybody. If you shared User Content which you no longer want to share publicly or privately using our Products, Services, or Network, you must either revoke access or delete that User Content. By making such deletion, other participants in the network will be notified to remove the content and it will be deleted from any nodes run by 3Box Labs. However, this may not permanently erase the existence of or substance of any User Content from all aspects of the network entirely. In a distributed network, it is not possible for us to guarantee that all node operators will delete content.</p> <p>3.2 User Content Restrictions. When accessing the Products, Services, or Network you must not collect, upload, transmit, display, or distribute any User Content that may:</p> <p>i. Violate any third-party right, including any copyright, trademark, patent, trade secret, moral right, privacy right, right of publicity, or any other intellectual property or proprietary right;</p> <p>ii. Contain any unlawful, harassing, abusive, tortious, threatening, harmful, invasive of another\u2019s privacy, vulgar, defamatory, false, intentionally misleading, trade libelous, pornographic, obscene, patently offensive, promotes racism, bigotry, hatred, or physical harm of any kind against any group or individual or is otherwise objectionable;</p> <p>iii. Contain viruses, worms, or any software intended to damage or alter a computer system or data, including computer viruses, works, time bombs, Trojan horses, and other harmful or malicious code, routines, files, scripts, agents, or programs;</p> <p>iv. Be harmful to minors in any way;</p> <p>v. Interfere with or disrupts the integrity or performance of the Site, Products, Services, Network, User Content, or any other data contained therein; or,</p> <p>vi. Violate any applicable law, regulation, or obligations or restrictions imposed by any third party.</p> <p>3.3 Rights in User Content. You represent and warrant that you have the right to grant and hereby grant 3Box Labs an irrevocable, nonexclusive, royalty-free and fully paid, worldwide license to reproduce, distribute, publicly display and perform, prepare derivative works of, incorporate into other works, and otherwise use your User Content; and, to grant sublicenses of these rights, solely for the purposes of including your User Content in the Products, Services, and Network. You irrevocably waive any claims and assertions of moral rights or attribution regarding your User Content.</p> <p>3.4 Responsibility for User Content. You are solely responsible for your User Content. You assume all risks associated with use of your User Content, including any reliance on its accuracy, completeness or usefulness by others, or any disclosure of your User Content that personally identifies you or any third party. You represent and warrant that your User Content does not violate these Terms. You may not represent or imply to others that your User Content is in any way provided, sponsored, or endorsed by 3Box Labs. Because you alone are responsible for your User Content, you may expose yourself to liability if, for example, your User Content violates the Acceptable Use Policy. We are not obligated to backup or maintain any User Content, and your User Content may be deleted at any time without prior notice. You are solely responsible for creating and maintaining your own backup copies of your User Content if you desire.</p> <p>3.5 Copyright Infringement. If you believe that your copyright or the copyright of a person on whose behalf you are authorized to act has been infringed, please provide us a written notice at support@3box.io containing the following information:</p> <p>i. An electronic or physical signature of the person authorized to act on behalf of the owner of the copyright or other intellectual property interest;</p> <p>ii. A description of the copyrighted work or other intellectual property you claim has been infringed; and,</p> <p>iii. A description of where the material you claim is infringing is on the Site.</p>"},{"location":"pages/3boxlabs-terms-conditions/#4-third-party-links-ads-other-users","title":"4. THIRD-PARTY LINKS &amp; ADS; OTHER USERS","text":"<p>4.1 Third-Party Links &amp; Ads. The Products, Services, and Network may contain links to third-party websites, services, or display advertisements for third parties (\u201cThird-Party Links &amp; Ads\u201d). We provide access to these Third-Party Links &amp; Ads only as a convenience to you. We do not control these third parties or operate, review, approve, monitor, or endorse Third-Party Links &amp; Ads, so we are not responsible for those third parties\u2019 policies and practices, including how they may treat your data. Use caution and review the terms and privacy policies of those third parties before proceeding with any transaction in connection with such Third-Party Links &amp; Ads.</p> <p>4.2 Other Users\u2019 Content. Because we do not control User Content, you acknowledge and agree that we are not responsible for any User Content, whether provided by you or by others, such as dapps to whom you have granted private access. We make no guarantees regarding the accuracy, currency, suitability, or quality of any User Content. Your interactions with other users are solely between you and such users. You agree that we will not be responsible for any loss or damage incurred as the result of any such interactions. If there is a dispute between you and any user, we are under no obligation to become involved.</p>"},{"location":"pages/3boxlabs-terms-conditions/#5-disclaimers-and-warranties","title":"5. DISCLAIMERS AND WARRANTIES","text":"<p>5.1 Limited Warranty. WE EXPRESSLY DISCLAIM ANY AND ALL WARRANTIES AND CONDITIONS OF ANY KIND, WHETHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING ALL WARRANTIES OR CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, QUIET ENJOYMENT, ACCURACY, OR NON-INFRINGEMENT. WE (AND OUR SUPPLIERS) MAKE NO WARRANTY THAT THE PRODUCTS, SERVICES, OR NETWORK WILL MEET YOUR REQUIREMENTS, WILL BE AVAILABLE ON AN UNINTERRUPTED, TIMELY, SECURE, OR ERROR-FREE BASIS, OR WILL BE ACCURATE, RELIABLE, FREE OF VIRUSES OR OTHER HARMFUL CODE, COMPLETE, LEGAL, OR SAFE. IF APPLICABLE LAW REQUIRES ANY WARRANTIES WITH RESPECT TO THE PRODUCTS, SERVICES, OR NETWORK, ALL SUCH WARRANTIES ARE LIMITED IN DURATION TO NINETY (90) DAYS FROM THE DATE OF FIRST USE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO THE ABOVE EXCLUSION MAY NOT APPLY TO YOU. SOME JURISDICTIONS DO NOT ALLOW LIMITATIONS ON HOW LONG AN IMPLIED WARRANTY LASTS, SO THE ABOVE LIMITATION MAY NOT APPLY TO YOU.</p> <p>5.2 Risks of Cryptographic Systems. You acknowledge and understand that cryptography is a progressing field. Advances in code cracking or technical advances such as developing quantum computers may present risks to cryptographic systems and the Products, Services, or Network, which could cause the theft or loss of your property. To the extent possible, we intend to update the code underlying the Products, Services, or Network to account for any advances in cryptography and to incorporate additional security measures, but do not guarantee or otherwise represent full security of the system. By using the Products, Services, or Network you acknowledge these inherent risks.</p> <p>5.3 Security, Vulnerabilities, or Interruptions. We are in early stages of development. You acknowledge that applications are code subject to flaws and acknowledge that you are solely responsible for evaluating any available code provided by the Products, Services, or Network. You further expressly acknowledge that applications can be written maliciously or negligently, and we cannot be held liable for your interactions with third party applications. These warnings and others later provided by us in no way evidence or represent an ongoing duty to alert you to all of the potential risks of utilizing the Products, Services, and Network. You agree that we have no responsibility or liability to:</p> <p>i. Update the Products, Services, or Network to address, mitigate, or remediate any security or other vulnerabilities;</p> <p>ii. Ensure that any integrations or APIs are secure and function without errors, bugs, or other interruptions; or,</p> <p>iii. Ensure that the Products, Services, or Network have no weaknesses or bugs that may cause security vulnerabilities, data loss, damage, destructions, disclosure, or other compromises.</p> <p>5.4 Release of all Claims. YOU RELEASE, FOREVER DISCHARGE 3BOX LABS, CERAMIC, IDX, AND/OR SELF.ID FROM, AND WAIVE AND RELINQUISH EACH AND EVERY PAST, PRESENT, OR FUTURE DISPUTE, CLAIM, CONTROVERSY, DEMAND, RIGHT, OBLIGATION, LIABILITY ACTION, OR CAUSE OF ACTION OF EVERY KIND AND NATURE THAT ARISES DIRECTLY OR INDIRECTLY FROM YOUR USE OF THE PRODUCTS, SERVICES, AND NETWORK TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW. IF YOU ARE A CALIFORNIA RESIDENT, YOU HEREBY WAIVE CALIFORNIA CIVIL CODE SECTION 1542 IN CONNECTION WITH THE FOREGOING, WHICH STATES: \u201cA general release does not extend to claims that the creditor or releasing party does not know or suspect to exist in his or her favor at the time of executing the release and that, if known by him or her, would have materially affected his or her settlement with the debtor or released party.\u201d</p> <p>5.5 No Third Party Beneficiaries. You agree there shall be no third party beneficiaries to the Terms, nor will these Terms be construed as creating or implying any relationship of agency, franchise, partnership, or joint venture between you and 3Box Labs.</p>"},{"location":"pages/3boxlabs-terms-conditions/#6-limitation-on-liability-and-indemnification","title":"6. LIMITATION ON LIABILITY AND INDEMNIFICATION","text":"<p>PLEASE READ THIS SECTION CAREFULLY AS IT CONTAINS IMPORTANT LIMITATIONS ON OUR LIABILITY AND YOUR RIGHTS.</p> <p>6.1 Limitation on Liability. TO THE FULLEST EXTENT PERMITTED BY LAW, IN NO EVENT SHALL 3BOX LABS, CERAMIC, IDX, AND/OR SELF.ID (OR OUR SUPPLIERS) BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY LOST PROFITS, LOST DATA, COSTS OF PROCUREMENT OF SUBSTITUTE PRODUCTS, OR ANY INDIRECT, CONSEQUENTIAL, EXEMPLARY, INCIDENTAL, SPECIAL OR PUNITIVE DAMAGES ARISING FROM OR RELATING TO THESE TERMS OR YOUR USE OF, OR INABILITY TO USE, THE PRODUCTS, SERVICES, OR NETWORK, EVEN IF WE HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. ACCESS TO, AND USE OF, THE PRODUCTS, SERVICES, OR NETWORK IS AT YOUR OWN DISCRETION AND RISK, AND YOU WILL BE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR DEVICE OR COMPUTER SYSTEM, OR LOSS OF DATA RESULTING THEREFROM.</p> <p>6.2 Total Aggregate Liability. TO THE FULLEST EXTENT PERMITTED BY LAW, NOTWITHSTANDING ANYTHING TO THE CONTRARY CONTAINED HEREIN, OUR LIABILITY TO YOU FOR ANY DAMAGES ARISING FROM OR RELATED TO THIS AGREEMENT (FOR ANY CAUSE WHATSOEVER AND REGARDLESS OF THE FORM OF THE ACTION), WILL AT ALL TIMES BE LIMITED TO A MAXIMUM OF FIFTY US DOLLARS (U.S. $50). THE EXISTENCE OF MORE THAN ONE CLAIM WILL NOT ENLARGE THIS LIMIT. YOU AGREE THAT OUR SUPPLIERS WILL HAVE NO LIABILITY OF ANY KIND ARISING FROM OR RELATING TO THIS AGREEMENT. SOME JURISDICTIONS DO NOT ALLOW THE LIMITATION OR EXCLUSION OF LIABILITY FOR INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE ABOVE LIMITATION OR EXCLUSION MAY NOT APPLY TO YOU.</p> <p>6.3 Indemnification. YOU AGREE TO INDEMNIFY AND HOLD HARMLESS 3BOX LABS, CERAMIC, IDX, AND/OR SELF.ID FROM EVERY PAST, PRESENT, OR FUTURE DISPUTE, CLAIM, CONTROVERSY, DEMAND, RIGHT, OBLIGATION, LIABILITY ACTION, OR CAUSE OF ACTION OF EVERY KIND, INCLUDING COSTS AND ATTORNEYS FEES, THAT ARISES OUT OF YOUR:</p> <p>i. Misuse of the Products, Services, and Network;</p> <p>ii. Failure to secure your Networks, Account, or User Content;</p> <p>iii. Violation of these Terms;</p> <p>iv. Violation of applicable laws; or,</p> <p>v. User Content.</p> <p>We reserve the right, at your expense, to assume the exclusive defense and control of any matter for which you must indemnify us, and you agree to cooperate with our defense of these claims. You agree not to settle any matter without our prior written consent. We will use reasonable efforts to notify you of any such claim, action or proceeding upon learning of it.</p>"},{"location":"pages/3boxlabs-terms-conditions/#7-dispute-resolution","title":"7. DISPUTE RESOLUTION","text":"<p>PLEASE READ THIS SECTION CAREFULLY. IT CONTAINS IMPORTANT INFORMATION THAT COMPELS MANDATORY ARBITRATION AND PROVIDES A CLASS ACTION WAIVER.</p> <p>7.1 Applicability of Arbitration Agreement. All claims and disputes (excluding claims for injunctive or other equitable relief as set forth below) in connection with the Terms or the use of any product or service provided by 3Box Labs, Ceramic, IDX, or Self.ID, respectively, that cannot be resolved informally or in small claims court shall be resolved by binding arbitration on an individual basis under this Arbitration Agreement. Unless otherwise agreed to, all arbitration proceedings shall be held in English. This Arbitration Agreement applies to you and 3Box Labs, Ceramic, IDX, or Self.ID, respectively, and to any of our subsidiaries, affiliates, agents, employees, predecessors in interest, successors, and assigns, as well as all authorized or unauthorized users or beneficiaries of the Products, Services, and Network these Terms.</p> <p>7.2 Notice Requirement and Informal Dispute Resolution. Before either party may seek arbitration, the party must first send to the other party a written Notice of Dispute (\u201cNotice\u201d) describing the claim or dispute, and the requested relief. A Notice to 3Box Labs, Ceramic, IDX, or Self.ID, should be sent to: 275 S 5<sup>th</sup> St, 15E, Brooklyn, NY 11211. After the Notice is received, you and 3Box Labs, Ceramic, IDX, or Self.ID, may attempt to resolve the claim or dispute informally. If unable to resolve the claim or dispute within thirty (30) days after the Notice is received, either party may begin an arbitration proceeding. Any settlement offer made by any party may not be disclosed to the arbitrator until after the arbitrator has determined the amount of the award, if any, to which either party is entitled.</p> <p>7.3 Arbitration Rules. Arbitration shall be initiated through the American Arbitration Association (\u201cAAA\u201d), an established alternative dispute resolution provider (\u201cADR Provider\u201d). If AAA is not available to arbitrate, the parties shall select an alternative ADR Provider. The rules of the ADR Provider shall govern all aspects of the arbitration, including but not limited to the method of initiating and/or demanding arbitration, except to the extent such rules conflict with the Terms. The AAA Consumer Arbitration Rules (\u201cArbitration Rules\u201d) governing the arbitration are available online at www.adr.org or by calling the AAA at 1-800-778-7879. The arbitration shall be conducted by a single, neutral arbitrator. Any claims or disputes where the total award sought is less than Ten Thousand U.S. Dollars (US $10,000.00) may be resolved through binding non-appearance-based arbitration, at the option of the party seeking relief. For claims or disputes where the total award sought is Ten Thousand U.S. Dollars (US $10,000.00) or more, the right to a hearing will be determined by the Arbitration Rules. Any judgment on the award rendered by the arbitrator may be entered in any court of competent jurisdiction, subject to the Limitations of Liability set out in Section 6. Each party shall bear its own costs (including attorney\u2019s fees) and disbursements arising out of the arbitration and shall pay an equal share of the fees and costs of the ADR Provider.</p> <p>7.4 Additional Rules for Non-Appearance Based Arbitration. If non-appearance based arbitration is elected, the arbitration shall be conducted by telephone, online and/or based solely on written submissions; the specific manner shall be chosen by the party initiating the arbitration. The arbitration shall not involve any personal appearance by the parties or witnesses unless otherwise agreed by the parties.</p> <p>7.5 Time Limits. If you or 3Box Labs, Ceramic, IDX, or Self.ID, pursue arbitration, the arbitration action must be initiated and/or demanded within the statute of limitations (i.e., the legal deadline for filing a claim) and within any deadline imposed under the AAA Rules for the pertinent claim.</p> <p>7.6 Authority of Arbitrator. If arbitration is initiated, the arbitrator will decide the rights and liabilities, if any, of you and 3Box Labs, Ceramic, IDX, or Self.ID, and the dispute will not be consolidated with any other matters or joined with any other cases or parties. The arbitrator shall have the authority to grant motions dispositive of all or part of any claim. The arbitrator shall have the authority to award monetary damages, and to grant any non-monetary remedy or relief available to an individual under applicable law, the AAA Rules, and the Terms. The arbitrator shall issue a written award and statement of decision describing the essential findings and conclusions on which the award is based, including the calculation of any damages awarded. The arbitrator has the same authority to award relief on an individual basis that a judge in a court of law would have. The award of the arbitrator is final and binding upon you and 3Box Labs, Ceramic, IDX, or Self.ID.</p> <p>7.7 Waiver of Jury Trial. THE PARTIES HEREBY WAIVE THEIR CONSTITUTIONAL AND STATUTORY RIGHTS TO GO TO COURT AND HAVE A TRIAL IN FRONT OF A JUDGE OR A JURY, instead electing that all claims and disputes shall be resolved by arbitration under this Arbitration Agreement. Arbitration procedures are typically more limited, more efficient and less costly than rules applicable in a court and are subject to very limited review by a court. If any litigation should arise between you and 3Box Labs, Ceramic, IDX, or Self.ID, in any state or federal court in a suit to vacate or enforce an arbitration award or otherwise, YOU AND 3BOX LABS, CERAMIC, IDX, AND SELF ID WAIVE ALL RIGHTS TO A JURY TRIAL, instead electing that the dispute be resolved by a judge.</p> <p>7.8 Waiver of Class or Consolidated Actions. ALL CLAIMS AND DISPUTES WITHIN THE SCOPE OF THIS ARBITRATION AGREEMENT MUST BE ARBITRATED OR LITIGATED ON AN INDIVIDUAL BASIS AND NOT ON A CLASS BASIS, AND CLAIMS OF MORE THAN ONE CUSTOMER OR USER CANNOT BE ARBITRATED OR LITIGATED JOINTLY OR CONSOLIDATED WITH THOSE OF ANY OTHER CUSTOMER OR USER.</p> <p>7.9 Confidentiality. All aspects of the arbitration proceeding, including but not limited to the award of the arbitrator and compliance therewith, shall be strictly confidential. The parties agree to maintain confidentiality unless otherwise required by law. This paragraph shall not prevent a party from submitting to a court of law any information necessary to enforce this Agreement, to enforce an arbitration award, or to seek injunctive or equitable relief.</p> <p>7.10 Small Claims Court. Notwithstanding the foregoing, either you or 3Box Labs, Ceramic, IDX, or Self.ID may bring an individual action in small claims court.</p> <p>7.11 Emergency Equitable Relief. Notwithstanding the foregoing, either party may seek emergency equitable relief before a state or federal court to maintain the status quo pending arbitration. A request for interim measures shall not be deemed a waiver of any other rights or obligations under this Arbitration Agreement.</p> <p>7.12 Survival of Arbitration Agreement. This Arbitration Agreement will survive the termination of your relationship with 3Box Labs, Ceramic, IDX, or Self.ID.</p> <p>7.13 Courts. Where the foregoing Arbitration Agreement permits the parties to litigate in court, the parties agree to submit to the personal jurisdiction of the courts within Kings County, New York, for such purpose.</p> <p>7.14 Governing Law. These Terms are to be interpreted and applied under New York state law without regards for the state\u2019s conflicts of law policies.</p>"},{"location":"pages/3boxlabs-terms-conditions/#8-other-general-terms","title":"8. OTHER GENERAL TERMS","text":"<p>8.1 Term and Termination. Subject to this Section, these Terms will remain in full force and effect while you use the Products, Services, and Network. We may suspend or terminate your rights to use the Products, Services, and Network (including your Account) at any time for any reason at our sole discretion, including for any use of the Products, Services, or Network in violation of these Terms. Upon termination of your rights under these Terms, your Account and right to access and use the Products, Services, and Network will terminate immediately. You understand that any termination of your Account may involve deletion of your User Content associated with your Account from our live databases. We will have no liability whatsoever to you for any termination of your rights under these Terms, including for termination of your Account or deletion of your User Content. To the fullest extent permitted by law, even after your rights under these Terms are terminated, the Terms will remain in effect.</p> <p>8.2 Severability. If any part or parts of this Arbitration Agreement are found under the law to be invalid or unenforceable by a court of competent jurisdiction, then such specific part or parts shall be of no force and effect and shall be severed and the remainder of the Agreement shall continue in full force and effect.</p> <p>8.3 Right to Waive. We may, at our sole discretion, waive any of the rights and limitations in these Terms. Such waiver shall not waive or affect any other portion of these Terms.</p> <p>8.4 Export. The Products, Services, and Network, or User Content may be subject to U.S. export control laws and may be subject to export or import regulations in other countries. You agree not to export, re-export, or transfer, directly or indirectly, any U.S. technical data acquired from 3Box Labs or any products utilizing such data, in violation of the United States export laws or regulations.</p>"},{"location":"pages/3boxlabs-terms-conditions/#9-entire-terms","title":"9. ENTIRE TERMS","text":"<p>These Terms constitute the entire agreement between you and us regarding the Products, Services, and Network. Our failure to exercise or enforce any right or provision of these Terms shall not operate as a waiver of such right or provision. The section titles in these Terms are for convenience only and have no legal or contractual effect. The word \u201cincluding\u201d means \u201cincluding without limitation\u201d. If any provision of these Terms is, for any reason, held to be invalid or unenforceable, the other provisions of these Terms will be unimpaired and the invalid or unenforceable provision will be deemed modified so it is valid and enforceable to the maximum extent permitted by law. Your relationship to 3Box Labs, Ceramic, IDX, or Self.ID, is that of an independent contractor, and neither party is an agent or partner of the other. These Terms, and your rights and obligations herein, may not be assigned, subcontracted, delegated, or otherwise transferred by you without our prior written consent, and any attempted assignment, subcontract, delegation, or transfer in violation of the foregoing will be null and void. We may freely assign these Terms. These Terms shall be binding upon assignees.</p>"},{"location":"pages/3boxlabs-terms-conditions/#10-changes","title":"10. CHANGES","text":"<p>These Terms are subject to occasional revision. If we make any material changes, we will take reasonable steps to notify you and change the Last Updated date above. Continued use of our Products, Services, or Network following such updates shall indicate your acknowledgement and agreement to be bound by the updated Terms.</p>"},{"location":"pages/3boxlabs-terms-conditions/#11-contact","title":"11. CONTACT","text":"<p>We welcome your comments or questions about these Terms. Contact us at support@3box.io.</p>"},{"location":"pages/3id-lifecycle/","title":"3ID Lifecycle","text":"<p>This page describes the complete lifecycle of a 3ID DID, including how the DID document is created, how keys are managed, and how 3ID Connect uses these building blocks. Most of the logic described here is implemented in the 3id-did-provider package.</p> <p>The two core components to the 3ID lifecycle are the 3ID DID method and the 3ID Keychain which is a standard for storing encrypted key material in a DID's Identity Index.</p>"},{"location":"pages/3id-lifecycle/#3id-did-provider-lifecycle","title":"3ID DID provider lifecycle","text":"<p>Every 3ID has a seed which is the secret used to update the 3ID, sign messages, and decrypt messages as the 3ID. The 3ID DID provider manages this seed using authSecrets. Each <code>authSecret</code> can be used to authenticate to the 3ID and thus get access to the seed.</p> <p></p>"},{"location":"pages/3id-lifecycle/#creating-a-3id","title":"Creating a 3ID","text":"<p>To create a 3ID the 3id-did-provider accepts an <code>authSecret</code> and an <code>authId</code>. It roughly follows the following algorithm.</p> <ol> <li>We have an <code>authSecret A</code> that is used to create <code>did:key:A</code> using the <code>key-did-provider-ed25519</code> provider</li> <li>A deterministic TileDocument, referred to as AuthLink, is created. If this is a new <code>authSecret</code> the loaded AuthLink will be empty</li> <li>A seed for the 3ID is randomly generated; two asymmetric keys (<code>signing</code>, and <code>encryption</code>), and a <code>did:key:management-1</code> are derived from the seed. A stream for the 3ID DID document is created with <code>did:key:management-1</code> as the controller, the <code>signing</code> and <code>encryption</code> public keys are stored in the streams content</li> <li>The seed is encrypted to <code>did:key:A</code></li> <li>The encrypted seed is put into the 3ID Keychain, which is an Identity Index record associated with the 3ID from step 3</li> <li>The AuthLink document is updated to contain the 3ID from step 3.</li> </ol>"},{"location":"pages/3id-lifecycle/#loading-an-existing-3id","title":"Loading an existing 3ID","text":"<p>If an <code>authSecret</code> has already been associated with a 3ID then this 3ID will be loaded instead of a new one created. Once authenticated the user can make updates to the 3ID document itself, as well author signatures and decrypt messages as the 3ID.</p> <ol> <li><code>authSecret A</code> is used to create <code>did:key:A</code> using the <code>key-did-provider-ed25519</code> provider.</li> <li>A deterministic TileDocument, referred to as AuthLink, is created. If this is an existing <code>authSerect</code> the loaded AuthLink contain a 3ID</li> <li>Using the 3ID from the previous step we can deterministically load the 3ID keychain</li> <li>Decrypt the seed in the 3ID Keychain that was encrypted to <code>did:key:A</code></li> </ol>"},{"location":"pages/3id-lifecycle/#adding-a-new-authsecret","title":"Adding a new <code>authSecret</code>","text":"<p>We can add a new <code>authSecret</code> with two simple steps.</p> <ol> <li><code>authSecret B</code> is used to create <code>did:key:B</code></li> <li>The <code>seed</code> is encrypted to <code>did:key:B</code> and stored in the 3ID Keychain</li> <li>An AuthLink stream is created for <code>did:key:B</code> and updated to link to the 3ID</li> </ol>"},{"location":"pages/3id-lifecycle/#revoking-an-authsecret","title":"Revoking an <code>authSecret</code>","text":"<p>Assume that we have <code>authSecret A</code> and <code>authSecret B</code> associated to our 3ID, and we want to revoke <code>authSecret A</code>. Lets refer to the current seed as <code>seed 1</code>. Note that you should always end up with at least one <code>authSecret</code> in the end. It doesn't make sense to revoke all authSecrets as there no longer would be a way to authenticate to this 3ID.</p> <ol> <li>Randomly generate a new seed, <code>seed 2</code></li> <li>Two asymmetric keys (<code>signing</code>, and <code>encryption</code>), and a <code>did:key:management-2</code> are derived from <code>seed 2</code>. The 3ID stream for the 3ID DID document is updated with <code>did:key:management-2</code> as the controller, the <code>signing</code> and <code>encryption</code> public keys in the content</li> <li>The <code>seed 1</code> is encrypted to <code>seed 2</code> and stored in the 3ID Keychain, so that we can use it to decrypt any message encrypted to the previous version of the 3ID document</li> <li><code>seed 2</code> is encrypted to <code>authSecret B</code> but not to <code>authSecret A</code></li> <li>The encrypted <code>seed 2</code> is stored in the 3ID keychain</li> </ol> <p>After these steps are taken, <code>authSecret A</code> can no longer be used to authenticate to the 3ID.</p>"},{"location":"pages/3id-lifecycle/#usage-in-3id-connect","title":"Usage in 3ID Connect","text":"<p>A natural question at this point is: Where does these authSecrets come from? In 3ID Connect normal blockchain wallets are used to create these secrets in the following way.</p> <ol> <li>A signature of some static message is requested from the users wallet, e.g. MetaMask</li> <li>If the user accepts a signature is returned</li> <li>The entropy (randomness) of the signature is now used as an <code>authSecret</code> (we take the hash of the signature to get the <code>authSecret</code>), in addition 3ID Connect will use the wallet AccountID as the <code>authId</code></li> </ol> <p>Note that this relies on the wallet making deterministic signatures, such that we can get the same <code>authSecret</code> every time.</p> <p>In addition to the authentication flow, 3ID Connect also creates a Caip10Link from the wallet AccountID to the 3ID. This allows application developers to query the users 3ID using an Ethereum address for example. The Caip10Link is also stored in the users CryptoAccounts Identity Index definition.</p>"},{"location":"pages/3id-security/","title":"3ID Security","text":"<p>The 3ID Connect system allows blockchain accounts to be used as an authentication method to the keys used for the users 3ID. In order to authenticate a user signs a message with their wallet. The entropy is used to generate a Key DID which in turn is used to decrypt the seed used for the 3ID.</p> <p>The main security concern here is that the seed used for the 3ID is stored within the 3ID iframe. While this restricts the app using 3ID Connect from doing whatever it wants with the seed, a malicious browser plugin could easily pick up the seed from the web browser and take full control over the users 3ID. While are multiple paths that can be used to mitigate this issue, it's currently considered to be a fair tradeoff to improve UX for users. In contrast to a users crypto wallet, the 3ID doesn't actually hold or control any cryptocurrency; it only controls data read/writes. This means that the incentive for a hacker to execute an attack is much smaller since there is no immediate financial reward. Also note that this security issue is not inherent to 3ID itself, it's just related to how 3ID is used within 3ID connect.</p>"},{"location":"pages/3id-security/#possible-security-improvements","title":"Possible security improvements","text":""},{"location":"pages/3id-security/#external-3id-controller","title":"External 3ID controller","text":"<p>The 3ID DID document has different public keys used for writing and controlling the DID document itself. Currently however, these keys are generated from the same seed and this seed is stored in the iframe as mentioned above. This means that if someone gets access to this seed and rotates keys using the controller key they will own the 3ID forever.</p> <p>One possible mitigation strategy is to generate the day-to-day public keys and the controller public key from different seeds, and then make sure to store the controller key separately in a more secure manner (not in the iframe). This would make it possible to recover from a scenario where the day-to-day writing public keys are compromised (seed is stolen from the iframe) because the seed of the controller key would still be in control of the user. An example solution here could be to store the seed of the controller key in a MetaMask Snap plugin.</p>"},{"location":"pages/3id-security/#dont-store-keys-in-web-context","title":"Don't store keys in web context","text":"<p>The long term solution is of course to not store any keys of the 3ID in the web browser context. This could be achieved though wallets supporting 3ID directly, or an Object-based capability system rooted in blockchain accounts which would allow applications to request specific permissions from wallets.</p>"},{"location":"protocol/api/","title":"Ceramic API","text":"<p>The new and improved Ceramic API is a work in progress. We will update this page when it's available. In the meantime, have a look at the HTTP API that's implemented by the current JS Ceramic implementation.</p>"},{"location":"protocol/nodes/","title":"Nodes","text":"<p>Two types of nodes currently work together to support the Ceramic network.</p>"},{"location":"protocol/nodes/#ceramic-nodes","title":"Ceramic Nodes","text":"<p>A Ceramic node is a bundle of services and long-lived processes that support the protocol and provide access to the Ceramic Network. Current implementations bundle and run most all of the following services and sub protocols defined here. This includes the following:</p>"},{"location":"protocol/nodes/#ipfs-services","title":"IPFS Services","text":"<p>The following services are typically provided to a Ceramic node by a connected IPFS node. These services do not necessarily have to be provided through an IPFS node or all bundled together.</p> IPLD Blockstore Stores the underlying IPLD blocks for event streams. Supports block formatting and content addressing. Gossipsub Several layers of the libp2p stack are used including GossipSub to query streams and broadcast stream updates in the network. Kademlia DHT A distributed hash table for content and peer lookup and discovery. The same DHT table is used as the primary IPFS network. Bitswap Exchange and sync blocks with peers. Allows an event stream to be sycned from one node to another."},{"location":"protocol/nodes/#ceramic-services","title":"Ceramic Services","text":"Pinning Tracks the streams a node wants to store and to receive the latest events for. StateStore Tracks and stores the latest tips for pinned streams and caches stream state. Networking Runs the stream query and update protocols on Gossipsub and manages peer connections. API Provides HTTP API service for connected Ceramic clients to read, write and query streams. Additionally, some node management functions are included. Timestamping Regularly publishes timestamp proofs and Ceramic time events for a given set of events. <p>Note</p> <p>In the future, node implementations may only provide a subset of services to the network. For example, nodes may be optimized to provide only indexing, long term storage, client APIs etc.</p>"},{"location":"protocol/nodes/#timestamp-nodes","title":"Timestamp Nodes","text":"<p>Timestamping nodes support a small but important subset of the Ceramic protocol. Timestamping is entirely described by CAIP-168 IPLD Timestamp Proof and Ceramic Time Events.  Timestamp services aggregate events from streams to be timestamped, construct Merkle proofs, publish transactions and publish timestamp events to the Ceramic Network. Ceramic mainnet currently supports <code>f(bytes32)</code>  timestamp transaction types on Ethereum mainnet. This transaction type is entirely described by the <code>eip155</code> namespace for CAIP-168. </p>"},{"location":"protocol/nodes/#implementations","title":"Implementations","text":"<p>The following table includes active node implementations:</p> Node Name Language Description Status Maintainer Ceramic js-ceramic JavaScript Complete Ceramic implementation. Runs all Ceramic core services, and connects to an IPFS node for all IPFS, libp2p, IPLD services needed. View all subpackages. Production 3Box Labs Timestamp ceramic-anchor-service JavaScript Complete timestamp services. Supports f(bytes32) and raw transaction types for EVM (EIP-155) blockchains. Production 3Box Labs <p>Longterm Ceramic is targeting multiple implementations of the protocol to support general resilience, robustness and security. Want to work on a node implementation in a new language like Rust or Go? Get in touch on the Forum!</p>"},{"location":"protocol/overview/","title":"Ceramic Protocol","text":"<p>Ceramic is a decentralized event streaming protocol that enables developers to build decentralized databases, distributed compute pipelines, and authenticated data feeds, etc. Ceramic nodes can subscribe to subsets of streams forgoing the need of a global network state. This makes Ceramic an eventually consistent system (as opposed to strongly consistent like L1 blockchains), enabling web scale applications to be built reliably.</p> <p>The protocol doesn't prescribe how to interpret events found within streams; this is left to the applications consuming the streams. One example of this type of application is ComposeDB.</p>"},{"location":"protocol/overview/#core-components","title":"Core Components","text":"<p>The Ceramic protocol consists of the following components:</p> <ul> <li>Streams \u2192</li> <li>Accounts \u2192</li> <li>Networking \u2192</li> <li>Ceramic API \u2192</li> <li>Ceramic Nodes \u2192</li> </ul>"},{"location":"protocol/overview/#specification-status","title":"Specification Status","text":"Section State 1. Streams Draft/WIP 1.1. Event Log Reliable 1.2. URI Scheme Reliable 1.3. Consensus Draft/WIP 1.4. Lifecycle Reliable 2. Accounts Draft/WIP 2.1. Decentralized Identifiers Draft/WIP 2.2. Authorizations Reliable 2.3. Object-Capabilities Draft/WIP 3. Networking Draft/WIP 3.1. Tip Gossip Reliable 3.2. Tip Queries Reliable 3.3. Event Fetching Reliable 3.4. Network Identifiers Reliable 4. API Missing 5. Nodes Draft/WIP"},{"location":"protocol/overview/#legend","title":"Legend","text":"Spec state Label Unlikely to change in the foreseeable future. Stable All content is correct. Important details are covered. Reliable All content is correct. Details are being worked on. Draft/WIP Do not follow. Important things have changed. Incorrect No work has been done yet. Missing"},{"location":"protocol/overview/#next-steps","title":"Next Steps","text":"<p>Start learning about Streams, the core data structures used in the Ceramic protocol.</p>"},{"location":"protocol/accounts/","title":"Accounts","text":"<p>User-owned Ceramic accounts</p>"},{"location":"protocol/accounts/#overview","title":"Overview","text":"<p>User owned data requires an account model that is both core to the protocol and general enough to support the wide diversity of possible account models and real world scenarios. Accounts are identified by Decentralized Identifiers, a general and extensible method to represent unique account strings, resolve public keys, and other account info or key material. Object-Capabilities are used to permission and authorize stream writes from one account to another, this may include session keys, applications and managing organization access. </p>"},{"location":"protocol/accounts/#decentralized-identifiers","title":"Decentralized Identifiers","text":"<p>Decentralized Identifiers (DIDs) are used to represent accounts. DIDs are identifiers that enable verifiable, decentralized digital identities. They require no centralized party or registry and are extremely extensible, allowing a variety of implementations and account models to exist. </p>"},{"location":"protocol/accounts/#authorizations","title":"Authorizations","text":"<p>Authorizations allow one account to delegate stream access to another account. While the current model is simple and minimal, it is descriptive enough to follow the rule of least privilege and limit the access that is delegated to another account. </p>"},{"location":"protocol/accounts/#object-capabilities","title":"Object Capabilities","text":"<p>Object Capabilities or CACAO are the technical feature and implementation that enables support for permissions and a general and powerful capability-based authorization system over streams.</p>"},{"location":"protocol/accounts/authorizations/","title":"Authorizations","text":"<p>Authorization is the act of delegating access to a stream to an account that is different than its owner. As a best practice, when granting authorizations to another account you want to follow the rule of least privilege and only authorize that delegate's temporary key to write the minimally needed data to Ceramic. </p>"},{"location":"protocol/accounts/authorizations/#scopes","title":"Scopes","text":"<p>CACAO and Ceramic support a basic way to describe the resources and actions an authorization includes. The resource parameter is an array of strings. In Ceramic those strings are StreamIDs or model StreamIDs. The implied action is write access, as read access is not authorized in any way at the protocol level. Read access would require an encryption protocol, as streams are public, and is out of scope for now. </p> <p>Note</p> <p>In the future, we expect the ability to specify more granular authorizations based on actions (write, delete, create, update etc) and resources.</p>"},{"location":"protocol/accounts/authorizations/#streams","title":"Streams","text":"<p>For example, to authorize an account to write to only two specific streams, you would specify the streamIds as resources in the CACAO as follows:</p> <pre><code>[ \"ceramic://kjzl6cwe1jw14bby1eybtqjr1w5l8xysitwmd34i8huccr7lk8g6xrt2l1c1ngn\", \"ceramic://kjzl6cwe1jw1476bbp2a0lg8gcmk9zj1xjanpg6dooc3golyb2fnmwmg0p6ane3\"]\n</code></pre>"},{"location":"protocol/accounts/authorizations/#models","title":"Models","text":"<p>The mostly commonly used pattern is to specify authorizations by model streamIds. <code>model</code> is a property that can be defined in a streams init event. When specified and used with CACAO it allows a DID and key the ability to write to all streams with this specific model value for that user. </p> <p>Note</p> <p>Ceramic will likely support other keys and values in streams beyond <code>model</code> for authorizations in the future.</p> <p>Models at the moment are primarily used as higher level concept built on top of Ceramic. A set of models will typically describe the entire write data-model of an application, making it a logical way for a user to authorize an application to write to all streams that is needed for that application. </p> <p>For example, a simple social application with a user profile and posts would have two corresponding models, a profile model and a post model. The CACAO would have the resources specified by an array of both model streamIds, shown below. This would allow a DID with this CACAO to create and write to any stream with these models. Allowing it to create as many posts as necessary. </p> <p>Resources defined by model streamID are formatted as <code>ceramic://*?model=&lt;StreamId&gt;</code> and would be defined as follows for the prior example. </p> <pre><code>[ \"ceramic://*?model=kjzl6hvfrbw6c7keo17n66rxyo21nqqaa9lh491jz16od43nokz7ksfcvzi6bwc\", \"ceramic://*?model=kjzl6hvfrbw6c99mdfpjx1z3fue7sesgua6gsl1vu97229lq56344zu9bawnf96\"]\n</code></pre>"},{"location":"protocol/accounts/authorizations/#wildcard","title":"Wildcard","text":"<p>Lastly a wildcard for all resources is supported. For security reasons, wildcard will be deprecated in the future and is only included here for completeness. </p> <pre><code>[ \"ceramic://*\" ]\n</code></pre>"},{"location":"protocol/accounts/decentralized-identifiers/","title":"Identifiers","text":"<p>Ceramic streams rely on an account model to authenticate and authorize updates to a stream. A fully realized vision of user owned data includes the use of public key cryptography and the ability to sign data with a public-private key-pair controlled by a user. But key pairs alone are often not user friendly nor sufficient and don't fully represent the range of real world scenarios. </p>"},{"location":"protocol/accounts/decentralized-identifiers/#decentralized-identifiers-dids","title":"Decentralized Identifiers (DIDs)","text":"<p>Ceramic uses Decentralized Identifiers (DIDs) to represent accounts. DIDs are identifiers that enable verifiable, decentralized digital identities. They require no centralized party or registry and are extremely extensible, allowing a variety of implementations and account models to exist. </p> <p>DID methods are specific implementations of the DID standard that define an identifier namespace along with how to resolve its DID document, which typically stores public keys for signing and encryption. The ability to resolve public keys from identifiers allows anyone to verify a signature for a DID. </p>"},{"location":"protocol/accounts/decentralized-identifiers/#supported-methods","title":"Supported Methods","text":"<p>At this time, the following DID methods can be used with Ceramic: </p>"},{"location":"protocol/accounts/decentralized-identifiers/#pkh-did","title":"PKH DID","text":"<p>PKH DID Method: A DID method that natively supports blockchain accounts. DID documents are statically generated from a blockchain account, allowing blockchain accounts to sign, authorize and authenticate in DID based environments. PKH DID is the primary and recommended method in Ceramic. did:pkh Method Specification</p> <pre><code>did:pkh:eip155:1:0xb9c5714089478a327f09197987f16f9e5d936e8a\n</code></pre>"},{"location":"protocol/accounts/decentralized-identifiers/#key-did","title":"Key DID","text":"<p>Key DID Method: A DID method that expands a cryptographic public key into a DID Document, with support for Ed25519 and Secp256k1. Key DIDs are typically not used in long lived environments. did:key Method Specification</p> <pre><code>did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK\n</code></pre>"},{"location":"protocol/accounts/decentralized-identifiers/#3id-did","title":"3ID DID","text":"<p>3ID DID Method: A DID method that uses Ceramic's Tile Document StreamType to represent a mutable DID document. 3ID can be controlled with any number of blockchain accounts. did:3id Method Specification</p> <pre><code>did:3:kjzl6cwe1jw149tlplc4bgnpn1v4uwk9rg9jkvijx0u0zmfa97t69dnqibqa2as\n</code></pre>"},{"location":"protocol/accounts/object-capabilities/","title":"Object Capabilities","text":"<p>Ceramic streams support CACAO, allowing a basic but powerful capability-based authorization system to exist. CACAO, or \"chain agnostic object capabilities\", are composable, transferable and verifiable containers for authorizations and encoded in IPLD.  For the full CACAO specification and more examples, reference CAIP-74: CACAO - Chain Agnostic CApability Object.</p>"},{"location":"protocol/accounts/object-capabilities/#approach","title":"Approach","text":"<p>Object capability-based authorization systems, of which CACAO is an implementation, are a natural way to represent authorizations in open and distributed systems. Object capabilities require little coordination, are only stored by parties that care about a particular capability, and are self-verifiable. </p> <p>Contrast this to popular authorization models like access controls lists (ACLs), which often rely on the ability to maintain an accurate, agreed-upon, and up to date list of authorizations. ACLs are simple and sufficient when you can rely on a single authoritative source to maintain the list, but quickly become difficult in a distributed setting. Maintaining a list amongst many unknown participants becomes a difficult consensus problem and often very costly at scale, requiring lots of upfront and continuous coordination. </p>"},{"location":"protocol/accounts/object-capabilities/#usage","title":"Usage","text":"<p>CACAO enables the ability for one account to authorize another account to construct signatures over limited data on their behalf, or in this case write to a Ceramic stream. </p>"},{"location":"protocol/accounts/object-capabilities/#using-blockchain-accounts","title":"Using blockchain accounts","text":"<p>When combined with \"Sign-in with X\", CACAO unlocks the ability for blockchain accounts to authorize Ceramic accounts (DIDs) to sign data on their behalf. </p> <p>This frequently used pattern in Ceramic greatly increases the the usability of user-owned data and public-key cryptography. Thanks to the adoption of blockchain based systems, many users now have the ability to easily sign data in web-based environments using their wallet and blockchain account. </p>"},{"location":"protocol/accounts/object-capabilities/#authorizing-sessions","title":"Authorizing sessions","text":"<p>Data-centric systems like Ceramic often have more frequent writes than a blockchain system, so it can be impractical to sign every Ceramic stream event in a blockchain wallet. Instead with the use of CACAO and \"Sign-in with X\" many writes can be made by way of a temporary key and DID authorized with a CACAO. Allowing a user to only sign once with a blockchain based account and wallet, then continue to sign many payloads for an authorized amount of time (session).</p> <p>In the future, we expect the ability to model the authorizations for more complex environments and structures including full organizations.</p>"},{"location":"protocol/accounts/object-capabilities/#specification","title":"Specification","text":"<p>Support for object capabilities in the core Ceramic protocol is described below. Events in streams are signed payloads formatted in IPLD using DAGJWS (DAG-JOSE), as described here. This describes how this is extended to construct a valid signed payload using CACAO in DAGJWS, by example of first constructing a JWS with CACAO. A JWS with CACAO can then be directly encoded with DAG-JOSE after. </p>"},{"location":"protocol/accounts/object-capabilities/#jws-with-cacao","title":"JWS with CACAO","text":"<p>JWS CACAO support includes adding a <code>cap</code> parameter to the JWS Protected Header and specifying the correct <code>kid</code> parameter string. Here is an example protected JWS header with CACAO:</p> <pre><code>{ \n  \"alg\": \"EdDSA\",\n  \"cap\": \"ipfs://bafyreidoaclgf2ptbvflwalfrr6d4iqehkzyidwbzaouprdbjjfb4yim6q\"\n  \"kid\": \"did:key:z6MkrBdNdwUPnXDVD1DCxedzVVBpaGi8aSmoXFAeKNgtAer8#z6MkrBdNdwUPnXDVD1DCxedzVVBpaGi8aSmoXFAeKNgtAer8\"\n }\n</code></pre> <p>Where:</p> <ul> <li><code>alg</code> - identifies the cryptographic algorithm used to secure the JWS</li> <li><code>cap</code> - maps to a URI string, expected to be an IPLD CID resolvable to a CACAO object</li> <li><code>kid</code> - references the key used to secure the JWS. In the scope here this is expected to be a DID with reference to any key in the DID verification methods. The parameter MUST match the <code>aud</code> target of the CACAO object for both the CACAO and corresponding signature to be valid together.</li> </ul> <p>Since <code>cap</code> is currently not a registered header parameter name in the IANA \"JSON Web Signature and Encryption Header Parameters\" registry, we treat this as a \"Private Header Parameter Name\" for now with additional meaning provided by the CACAO for implementations that choose to use this specification.</p> <p>This means that ignoring the <code>cap</code> header during validation will still result in a valid JWS payload by the key defined in the <code>kid</code>. It just has no additional meaning by what is defined in the CACAO. The <code>cap</code> header parameter could also have support added as an extension by using the <code>crit</code> (Critical) Header Parameter in the JWS, but there is little reason to invalidate the JWS based on a consumer not understanding the <code>cap</code> header given it is still valid.</p>"},{"location":"protocol/accounts/object-capabilities/#dagjws-with-cacao","title":"DagJWS with CACAO","text":"<p>Construction</p> <p>Given JWS with CACAO described in prior section, follow the DAG-JOSE specification and implementations for the steps to construct a given JWS with CACAO header and payload into a DagJWS. DagJWS is very similar to any JWS, except that the payload is a base64url encoded IPLD CID that references the JSON object payload.</p> <pre><code>{ \n  cid: \"bagcqcera2mews3mbbzs...quxj4bes7fujkms4kxhvqem2a\",\n  value: {\n    jws: { \n      link: CID(\"bafyreidkjgg6bi4juwx...lb2usana7jvnmtyjb4xbgwl6e\"),\n      payload: \"AXESIGpJjeCjiaWv...LKw6pIDQfTVrJ4SHlwmsvx\", \n      signatures: [\n        {\n          protected: \"eyJhbGciOiJFZERTQSIsImNh...GU2djZEpLTmhYSDl4Rm9rdEFKaXlIQiJ9\"\n          signature: \"6usTYvu5KN0LFTQsWE9U-tqx...h60EgfvjL_rlAW7_tnQUl84sQyogpkLAQ\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>Verification</p> <p>The following algorithm describes the steps required to determine if a given DagJWS with CACAO is valid:</p> <ol> <li>Follow DAG-JOSE specification to transform a given DagJWS into a JWS.</li> <li>Follow JWS specifications to determine if the given JWS is valid. Verifying that the given signature paired with <code>alg</code> and <code>kid</code> in the protected header is valid over the given payload. If invalid, an error MUST be raised.</li> <li>Resolve the given URI in <code>cap</code> parameter of the projected JWS header to a CACAO JSON object. Follow the CAIP-74 CACAO specification to determine if the given CACAO is valid. If invalid, an error MUST be raised.</li> <li>Ensure that the <code>aud</code> parameter of the CACAO payload is the same target as the <code>kid</code> parameter in the JWS protected header. If they do not match, an error MUST be raised.</li> </ol> <p>Example</p> <p>Example IPLD dag-jose encoded block, strings abbreviated.</p> <pre><code>{ \n  cid: \"bagcqcera2mews3mbbzs...quxj4bes7fujkms4kxhvqem2a\",\n  value: {\n    jws: { \n      link: CID(\"bafyreidkjgg6bi4juwx...lb2usana7jvnmtyjb4xbgwl6e\"),\n      payload: \"AXESIGpJjeCjiaWv...LKw6pIDQfTVrJ4SHlwmsvx\", \n      signatures: [\n        {\n          protected: \"eyJhbGciOiJFZERTQSIsImNh...GU2djZEpLTmhYSDl4Rm9rdEFKaXlIQiJ9\"\n          signature: \"6usTYvu5KN0LFTQsWE9U-tqx...h60EgfvjL_rlAW7_tnQUl84sQyogpkLAQ\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <p>If <code>block.value.jws.signatures[0].protected</code> is decoded, you would see the following object, a JWS protected header as described above:</p> <pre><code>{\n  \"alg\": \"EdDSA\",\n  \"cap\": \"ipfs://bafyreidoaclgf...yidwbzaouprdbjjfb4yim6q\",\n  \"kid\": \"did:key:z6Mkq2ZyjGV54ev...hXH9xFoktAJiyHB#z6Mkq2ZyjGV54ev...hXH9xFoktAJiyHB\"\n}\n</code></pre>"},{"location":"protocol/networking/","title":"Networking","text":"<p>Networking sub-protocols for Ceramic</p>"},{"location":"protocol/networking/#overview","title":"Overview","text":"<p>Ceramic streams and nodes are grouped into independent networks. These networks can be either for public use or for use by a specific community. There are currently a few commonly shared and default networks. When a stream is published in a network, other nodes in the same network are able to query and discover the stream, receive the latest stream events (tips), and sync the entire event set for a stream. Each of the these network functions are defined by a sub protocol listed below.</p>"},{"location":"protocol/networking/#networks","title":"Networks","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over dedicated libp2p pubsub topics. They are easily identified by a path string, for example <code>/ceramic/mainnet</code> .</p>"},{"location":"protocol/networking/#tip-gossip","title":"Tip Gossip","text":"<p>When a stream is updated, the latest event (tip) is gossiped and propagated out to all the nodes in a network that are interested in that particular stream. Listening for all tips, allows a node to learn about streams it did not know about. </p>"},{"location":"protocol/networking/#tip-queries","title":"Tip Queries","text":"<p>Nodes in a network with a specific StreamId can query for the most recent event (tip) of that given stream. Queries enable a node that know about a stream to find the latest event (tip). </p>"},{"location":"protocol/networking/#event-fetching","title":"Event Fetching","text":"<p>Nodes that have the tip (latest event) of a stream, can use the tip to fetch all prior events in that stream.  Fetching enables a node that knows a tip to sync the entire event set for a stream and learn its latest state. </p>"},{"location":"protocol/networking/event-fetching/","title":"Event Fetching","text":"<p>Once a tip is discovered through the Tip Gossip or Tip Query protocols a node knows both the StreamID and the latest event CID of the stream. The latest Event contains the CID of the <code>prev</code> Event and so on until the Init Event is found in the event log. The Init Event's CID is also in the StreamID. This is proof that the tip is part of the stream identified by the StreamId.</p> <p>The tip is one of Init, Data, or Time Event. If the tip CID is the initial event CID then the stream has never been updated and the initial event is the complete event log. If the tip CID points to a Data, or Time event then that event will contain a <code>prev</code> field with a CID link to its previous event. IPFS can be used to retrieve this event. Similarly you can use IPFS to recursively fetch and resolve every <code>prev</code> event in an event log until reaching the initial event. At that point you have retrieved and synced the entire stream. </p> <p>Fetching an event with IPFS from a peer both relies on IPFS BitSwap and the IPFS DHT.</p>"},{"location":"protocol/networking/networks/","title":"Networks","text":"<p>Information about the default Ceramic networks</p>"},{"location":"protocol/networking/networks/#overview","title":"Overview","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over dedicated libp2p pubsub topics. Networks are disjoint from one another; streamsthat exist on one network are not discoverable or usable on another.</p> <p>These pubsub topics are used to relay all messages for the defined networking sub protocols, including Tip Gossip and Tip Queries. </p>"},{"location":"protocol/networking/networks/#all-networks","title":"All Networks","text":"<p>An overview of the various Ceramic networks available today:</p> Name Network ID Ceramic Pubsub Topic Timestamp Authority Type Mainnet mainnet /ceramic/mainnet Ethereum Mainnet (EIP155:1) Public Clay Testnet testnet-clay /ceramic/testnet-clay Ethereum Gnosis Chain Public Dev Unstable dev-unstable /ceramic/dev-unstable Ethereum Goerli Testnet Public Local local /ceramic/local-$(randomNumber) Ethereum by Truffle Ganache Private In-memory inmemory None Private <p>Note</p> <p>There is currently a proposal to decompose each network into multiple pubsub topics for scalability, the pubsub topics will remain prefixed by the network identifier <code>/ceramic/&lt;network&gt;/&lt;sep&gt;</code> see CIP-120</p>"},{"location":"protocol/networking/networks/#public-networks","title":"Public networks","text":"<p>Ceramic has three public networks that can be used when building applications:</p> <ul> <li>Mainnet</li> <li>Testnet Clay</li> <li>Dev Unstable</li> </ul>"},{"location":"protocol/networking/networks/#mainnet","title":"Mainnet","text":"<p>Mainnet is the main public network used for production deployments on Ceramic. Ceramic's mainnet nodes communicate over the dedicated <code>/ceramic/mainnet</code> libp2p pubsub topic and use Ethereum's mainnet blockchain (<code>EIP155:1</code>) for generating timestamps used in time events for streams. </p>"},{"location":"protocol/networking/networks/#clay-testnet","title":"Clay Testnet","text":"<p>Clay Testnet is a public Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. While we aim to maintain a high level of quality on the Clay testnet that mirrors the expectations of Mainnet as closely as possible, ultimately the reliability, performance, and stability guarantees of the Clay network are lower than that of Mainnet. Because of this, the Clay network should not be used for applications in production. </p> <p>Clay nodes communicate over the dedicated <code>/ceramic/testnet-clay</code> libp2p pubsub topic and use Ethereum's Gnosis blockchain for generating timestamps used in time events for streams.</p>"},{"location":"protocol/networking/networks/#dev-unstable","title":"Dev Unstable","text":"<p>Dev Unstable is a public Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the develop branch of <code>js-ceramic</code>. It should be considered unstable and highly experimental; only use this network if you want to test the most cutting edge features, but expect issues.</p> <p>Dev Unstable nodes communicate over the dedicated <code>/ceramic/dev-unstable</code> libp2p pubsub topic and use Ethereum's Goerli testnet blockchains for generating timestamps used in time events for streams. </p>"},{"location":"protocol/networking/networks/#private-networks","title":"Private Networks","text":"<p>You can prototype applications on Ceramic by running the protocol in a local environment completely disconnected from other public nodes. Here \"private\" indicates that it is independent of the mainnet network, but does not imply any confidentiality guarantees. This is still public data.</p>"},{"location":"protocol/networking/networks/#local","title":"Local","text":"<p>Local is a private test network used for the local development of Ceramic applications. Nodes connected to the same local network communicate over a randomly-generated libp2p topic <code>/ceramic/local-$(randomNumber)</code> and use a local Ethereum blockchain provided by Truffle's Ganache for generating timestamps used in time events for streams. </p>"},{"location":"protocol/networking/networks/#examples","title":"Examples","text":""},{"location":"protocol/networking/networks/#typescript-definitions","title":"TypeScript Definitions","text":"<pre><code>enum Networks {\n  MAINNET = 'mainnet', // The prod public network\n  TESTNET_CLAY = 'testnet-clay', // Should act like mainnet to test apps\n  DEV_UNSTABLE = 'dev-unstable', // May diverge from mainnet to test Ceramic\n  LOCAL = 'local', // local development and testing\n  INMEMORY = 'inmemory', // local development and testing\n}\n</code></pre>"},{"location":"protocol/networking/tip-gossip/","title":"Tip Gossip","text":"<p>When a stream is updated, the latest event (tip) is gossiped and propagated out to all the nodes in a network that are interested in that particular stream. Additionally, listening for all tips, allows a node to learn about streams it did not know about. This allows all interested nodes in the network to quickly get the latest update and state for a stream.</p>"},{"location":"protocol/networking/tip-gossip/#protocol","title":"Protocol","text":""},{"location":"protocol/networking/tip-gossip/#publishing-updates","title":"Publishing Updates","text":"<p>When an event is created and appended to a stream, the node will publish an update message to the network. All messages are broadcast on the libp2p pubsub topic for the network this node is configured for. Any other node listening on this network will receive the update and then can decide to take any further action or discard. </p>"},{"location":"protocol/networking/tip-gossip/#update-messages","title":"Update Messages","text":"<pre><code>type UpdateMessage = {\n  typ: MsgType.UPDATE //0\n  stream: StreamID\n  tip: CID\n  model?: StreamID\n}\n</code></pre> <p>Where:</p> <ul> <li><code>typ</code> - the message is an update message, enum <code>0</code></li> <li><code>stream</code> - streamId of the stream which this update is for</li> <li><code>tip</code> - CID of the latest event (tip) of the stream, the update</li> <li><code>model</code> - streamId of the ComposeDB data model that the stream being updated belongs to (optional)</li> </ul>"},{"location":"protocol/networking/tip-gossip/#replicating-updates","title":"Replicating Updates","text":"<p>Any nodes that have received an update message and are interested in that stream can now save the tip (update). Any node that has saved this update can now answer tip queries for this stream. As long as there is at least one node in the network with this information (tip) saved, the publishing node can go down without effecting the availability of the stream.</p>"},{"location":"protocol/networking/tip-gossip/#examples","title":"Examples","text":""},{"location":"protocol/networking/tip-gossip/#typescript-definitions","title":"TypeScript  Definitions","text":"<pre><code>/**\n * Ceramic Pub/Sub message type.\n */\nenum MsgType {\n  UPDATE = 0,\n  QUERY = 1,\n  RESPONSE = 2,\n  KEEPALIVE = 3,\n}\n\ntype UpdateMessage = {\n  typ: MsgType.UPDATE\n  stream: StreamID\n  tip: CID  // the CID of the latest commit\n  model?: StreamID // optional\n}\n\n// All nodes will always ignore this message\ntype KeepaliveMessage = {\n  typ: MsgType.KEEPALIVE\n  ts: number // current time in milliseconds since epoch\n  ver: string // current ceramic version\n}\n</code></pre>"},{"location":"protocol/networking/tip-queries/","title":"Tip Queries","text":"<p>Ceramic streams are identified by a URI called StreamIds. Nodes that want to sync a stream need to query the network for the tip of that stream using its StreamId. </p> <p>Note</p> <p>Tips are the most recent Init, Data, or Time event for a given Stream Tip</p>"},{"location":"protocol/networking/tip-queries/#protocol","title":"Protocol","text":"<p>A node resolving a Ceramic URI sends a query message to the network and then listens for responses with the candidates for the current tip of the stream. Any node that is interested in the same stream on the network and has stored its tips will respond with a response message. All messages are sent on the libp2p pubsub topic for the network the node is configured for.</p>"},{"location":"protocol/networking/tip-queries/#query-message","title":"Query Message","text":"<pre><code>type QueryMessage = {\n  typ: MsgType.QUERY // 1\n  id: string\n  stream: StreamID\n}\n</code></pre> <p>Where:</p> <ul> <li><code>typ</code> - the message is a query message, enum <code>1</code></li> <li><code>stream</code> - the streamId that is being queried or resolved</li> <li><code>id</code> - a multihash <code>base64url.encode(sha265(dagCBOR({typ:1, stream: streamId})))</code>, can generally be treated as a random string that is used to pair queries to responses</li> </ul>"},{"location":"protocol/networking/tip-queries/#response-message","title":"Response Message","text":"<pre><code>type ResponseMessage = {\n  typ: MsgType.RESPONSE // 2\n  id: string\n  tips: Map&lt;StreamId, CID&gt; \n}\n</code></pre> <p>Where:</p> <ul> <li><code>typ</code> - the message is a response message, enum <code>2</code></li> <li><code>id</code> - id of the query that this message is a response to</li> <li><code>tips</code> - map of <code>StreamID</code> to CID of stream tip</li> </ul> <p>Note</p> <p>Currently this will only ever have a single <code>StreamID</code> in the query, but Ceramic will likely have batch queries at some point in the future.</p>"},{"location":"protocol/networking/tip-queries/#examples","title":"Examples","text":""},{"location":"protocol/networking/tip-queries/#typescript-definitions","title":"TypeScript Definitions","text":"<pre><code>enum MsgType { // Ceramic Pub/Sub message type.\n  UPDATE = 0,\n  QUERY = 1,\n  RESPONSE = 2,\n  KEEPALIVE = 3,\n}\n\ntype QueryMessage = {\n  typ: MsgType.QUERY\n  id: string\n  stream: StreamID\n}\n\ntype ResponseMessage = {\n  typ: MsgType.RESPONSE\n  id: string\n  tips: Map&lt;string, CID&gt;\n}\n</code></pre>"},{"location":"protocol/streams/","title":"Streams","text":"<p>Data structures core to Ceramic</p>"},{"location":"protocol/streams/#overview","title":"Overview","text":"<p>Streams are a core concept in Ceramic, they include a primary data structure called an event log, a URI scheme to identify unique streams in a network, a simple consensus model to agree on the same event log across the network, and a supporting lifecycle of creating, updating, querying, and syncing streams. </p>"},{"location":"protocol/streams/#event-log","title":"Event Log","text":"<p>The core data structure of streams is a self-certifying event log. It combines IPLD for hash linked data and cryptographic proofs to create an authenticated and immutable log. This event log can be used to model mutable databases and other data structures on top.</p>"},{"location":"protocol/streams/#uri-scheme","title":"URI Scheme","text":"<p>A URI scheme is used to reference unique streams and unique events included in streams. They use a self describing format that allows anyone to parse and consume a stream correctly, while also easily supporting future changes and new types. </p>"},{"location":"protocol/streams/#consensus","title":"Consensus","text":"<p>An event log or stream can end up with multiple branches or tips across nodes in the network. Different branches will result in differing stream state. A simple consensus model is used to allow all nodes whom consume the same set of events to eventually agree on a single log or state. </p>"},{"location":"protocol/streams/#stream-lifecycle","title":"Stream Lifecycle","text":"<p>A stream write lifecycle includes its creation and updates, otherwise know as events. A stream read lifecycle includes queries and syncing. </p>"},{"location":"protocol/streams/consensus/","title":"Consensus","text":""},{"location":"protocol/streams/consensus/#consensus-model","title":"Consensus Model","text":"<p>Event streams rely on a limited conflict resolution or consensus model. Global consensus and ordering is not needed for progress and most decisions are localized to the consuming party of a single event stream. Guarantees are limited, but if any two parties consume the same set of events for a stream, they will arrive at the same state. </p> <p>The underlying log structure of an event stream allows multiple parallel histories, or branches, to be created resulting in a tree structure. A log or valid event stream is a single tree path from a known \"latest\" event to the Init Event. Latest events are also referred to as stream \"tips\". Logs can have multiple tips when there are branches in the log, and the \"tip\" selection for the canonical log of a stream becomes a consensus problem. </p>"},{"location":"protocol/streams/consensus/#single-stream-consensus","title":"Single stream consensus","text":"<p>A tip and canonical log for a stream are selected by the following pseudo algorithm and rules: </p> <ol> <li>Given a set of tips, traverse each tree path from tip till a commonly shared Time Event or the Init Event. </li> <li>From the shared event, traverse each path in the opposite direction (towards tip) until a Time Event is found (or the end of the log is reached). This set of events are considered conflicting events.</li> <li>Given each Time Event, determine the blockheight for the transaction included in the timestamp proof. Select the path with lowest blockheight. If a single path is selected, exit with path and tip selected, otherwise continue. Most cases will terminate here, it will be rare to have the same blockheight.</li> <li>If multiple tips have the same blockheight, select the path with the greatest number of events from the last timestamp proof till tip. If single path selected, exit with path and tip selected, otherwise continue.</li> <li>If number of events is equal, chooses the event and path which has the smallest CID in binary format (an arbitrary but deterministic choice)</li> </ol>"},{"location":"protocol/streams/consensus/#cross-stream-ordering","title":"Cross stream ordering","text":"<p>It is assumed all timestamp events in a network are committed to the same blockchain, as specified by the <code>chainId</code> in the timestamp event. The main Ceramic network commits timestamp proofs to the Ethereum blockchain. </p> <p>The addition of timestamp events in streams gives some notion of relative global time for all events time-stamped on the same blockchain. This allows events across different streams to be globally ordered if a higher-level protocol requires it. Ceramic events can also be ordered against transactions and state on the blockchain in which it is timestamped. On most secure blockchains you can also reference wall clock time within some reasonable bounds and order events both in and out of the system based on that. </p>"},{"location":"protocol/streams/consensus/#risks","title":"Risks","text":""},{"location":"protocol/streams/consensus/#late-publishing","title":"Late Publishing","text":"<p>Without any global consensus guarantees, all streams and their potential tips are not known by all participants at any point in time. There may be partitions in the networks, existence of local networks, or individual participants may choose to intentionally withhold some events while publishing others. Selective publishing like this may or may not be malicious depending on the context in which the stream is consumed.</p> <p>Consider the following example: A user creates a stream, makes two conflicting updates and timestamps one of them earlier than the other, but only publishes the data of the update that was timestamped later. Now subsequent updates to the stream will be made on top of the second, published update. Every observer will accept these updates as valid since they have not seen the first update. However if the user later publishes the data of the earlier update, the stream will fork back to this update and all of the other updates made to the stream will be invalidated.</p> <p>Most of the time, the potential of an intentional late publishing attack isn't a concern in practice, as streams in Ceramic are generally controlled by a single user, and there's no incentive to attack one's own streams. This would become more of a concern, however, in streams with more sophisticated access control that allowed multiple end users to write into the same stream.  In that case, all users of the stream would need to trust all the other users who have - or have ever had - write access to the stream to not be secretly sitting on timestamped writes that they haven't yet published, or else risk those writes being revealed later on and causing the stream to lose all writes that have occurred since the previously secret write was created.</p> <p>Additionally, note that late publishing may also be used as a deterrent to selling user identities. An identity or account buyer can't know that the seller is not keeping secret events that they will publish after the identity was sold.</p>"},{"location":"protocol/streams/event-log/","title":"Event Log","text":"<p>The core data structure in the Ceramic protocol is a self-certifying event log. It combines IPLD for hash linked data and cryptographic proofs to create an authenticated and immutable log. This event log can be used to model mutable databases and other data structures on top.</p>"},{"location":"protocol/streams/event-log/#introduction","title":"Introduction","text":"<p>Append-only logs are frequently used as an underlying immutable data structure in distributed systems to improve data integrity, consistency, performance, history, etc. Open distributed systems use hash linked lists/logs to allow others to verify the integrity of any data. IPLD provides a natural way to define an immutable append-only log. </p> <ul> <li>Web3 authentication - When combined with cryptographic signatures and blockchain timestamping, it allows authenticated writes to these logs using blockchain accounts and DIDs</li> <li>Low cost decentralization - Providing a common database layer for users and applications besides more expensive on-chain data or centralized and siloed databases</li> <li>Interoperability, flexibility, composability - A minimally defined log structure allows a base level of interoperability while allowing diverse implementations of mutable databases and data structures on top. Base levels of interoperability include log transport, update syncing, consensus, etc.</li> </ul>"},{"location":"protocol/streams/event-log/#events","title":"Events","text":"<p>Logs are made up of events. An init event originates a new log and is used to reference or name a log. The name of a stream is referred to as a StreamId. Every additional \"update\" is appended as a data event. Periodically, time events are added after one or more data events. Time events allow you to prove an event was published at or before some point in time using blockchain timestamping. They can also be used for ordering events within streams and for global ordering across streams and blockchain events. The minimal definition of a log is provided here, additional parameters in both the headers and body are defined at application level or by higher level protocols. </p> <p>Data events (and often Init Events) are signed DAGJWS and encoded in IPLD using the DAG-JOSE codec. Event payloads are typically encoded as DAG-CBOR, but could be encoded with any codec supported by a node or the network. Formats and types are described using IPLD schema language and event encoding is further described below. </p>"},{"location":"protocol/streams/event-log/#init-event","title":"Init Event","text":"<p>A log is initialized with an init event. The CID of this event is used to reference or name this log in a StreamId. An init event may be signed or unsigned.</p> <pre><code>type InitHeader struct {\n  controllers [String]\n}\ntype InitPayload struct {\n  header InitHeader\n  data optional Any \n}\n\ntype InitJWS struct { // This is a DagJWS\n  payload String\n  signatures [Signature]\n  link: &amp;InitPayload\n}\n\ntype InitEvent InitPayload | InitJWS\n</code></pre> <p>Parameters defined as follows:</p> <ul> <li><code>controllers</code> - an array of DID strings that defines which DIDs can write events to the log, when using CACAO, the DID is expected to be the issuer of the CACAO. Note that currently only a single DID is supported.</li> <li><code>data</code> - data is anything, if defined the Init Event must match the InitJWS struct or envelope and be encoded in DAG-JOSE, otherwise the InitPayload would be a valid init event alone and encoded in DAG-CBOR</li> </ul>"},{"location":"protocol/streams/event-log/#data-event","title":"Data Event","text":"<p>Log updates are data events. Data events are appended in the log to an init event, prior data events or a time event. A data event MUST be signed. </p> <pre><code>type Event InitEvent | DataEvent | TimeEvent\n\ntype DataHeader struct {\n  controllers optional [String]\n}\n\ntype DataEventPayload struct {\n  id &amp;InitEvent\n  prev &amp;Event\n  header optional DataHeader\n  data Any \n}\n\ntype DataEvent struct { // This is a DagJWS\n  payload String\n  signatures [Signature]\n  link: &amp;DataEventPayload\n}\n</code></pre> <p>Additional parameters defined as follows, controllers and data defined same as above.</p> <ul> <li><code>id</code> - CID (Link) to the init event of the log</li> <li><code>prev</code> - CID (Link) to prior event in log</li> <li><code>header</code> - Optional header, included here only if changing header parameter value (controllers) from prior event. Other header values may be included outside this specification.</li> </ul> <p>This being a minimally defined log on IPLD, later specifications or protocols can add additional parameters to both init and data events and their headers as needed. </p>"},{"location":"protocol/streams/event-log/#time-event","title":"Time Event","text":"<p>Time events can be appended to init events, and 1 or more data events. Reference CAIP-168 IPLD Timestamp Proof specification for more details on creating and verifying time events. Time Events are a simple extension of the IPLD Timestamp Proof specification, where <code>prev</code> points to the prior event in the log and is expected to be the data for which the timestamp proof is for. A timestamp event is unsigned.</p> <pre><code>type TimeEvent struct {\n  id &amp;InitEvent\n  prev &amp;DataEvent | &amp;InitEvent\n  proof Link\n  path String\n}\n</code></pre>"},{"location":"protocol/streams/event-log/#verification","title":"Verification","text":"<p>A valid log is one that includes data events as defined above and traversing the log resolves to an originating init event as defined above. Each event is valid when it includes the required parameters above and the DAGJWS signature is valid for the given event <code>controller</code> DID and valid as defined below. Time events are defined as valid by CAIP-168. There will likely be additional verification steps specific to any protocol or application level definition.</p>"},{"location":"protocol/streams/event-log/#encoding","title":"Encoding","text":""},{"location":"protocol/streams/event-log/#jws-dag-jose","title":"JWS &amp; DAG-JOSE","text":"<p>All signed events are encoded in IPLD using DAG-JOSE. DAG-JOSE is a codec and standard for encoding JOSE objects in IPLD. JOSE includes bothJWS for signed JSON objects and JWE for encrypted JSON objects. JWS is used for events here and is commonly used standard for signed data payloads. Some parameters are further defined for streams. The original DAG-JOSE specification can be found here.</p> <p>The following defines a general signed event, both init and data events are more specifically defined above. </p> <pre><code>type Signature struct {\n  header optional { String : Any }\n  // The base64url encoded protected header, contains:\n  // `kid` - the DID URL used to sign the JWS\n  // `cap` - IPFS url of the CACAO used (optional)\n  protected optional String\n  signature String\n}\n\ntype EventJWS struct {\n  payload String\n  signatures [Signature]\n  link: &amp;Event\n}\n</code></pre> <p>Where:</p> <ul> <li><code>link</code> - CID (Link) to the event for which this signature is over. Provided for easy application access and IPLD traversal, expected to match CID encoded in payload</li> <li><code>payload</code> - base64url encoded CID link to the event (JWS payload) for which this signature is over</li> <li><code>protected</code> - base64 encoded JWS protected header</li> <li><code>header</code> - base64 encoded JWS header</li> <li><code>signature</code> - base64 encoded JWS signature</li> </ul>"},{"location":"protocol/streams/lifecycle/","title":"Stream Lifecycle","text":""},{"location":"protocol/streams/lifecycle/#write-lifecycle","title":"Write Lifecycle","text":""},{"location":"protocol/streams/lifecycle/#create","title":"Create","text":"<p>A stream is created when an Init Event is created and published. The stream is then uniquely referenced in the network by its StreamId, which is derived from this Init Event. </p>"},{"location":"protocol/streams/lifecycle/#update","title":"Update","text":"<p>Updates to a stream include the creating and publishing of data events or timestamp events. When creating these events they must reference the latest event or tip in the stream. The latest event, if there is multiple, is determined by locally following the conflict resolution and consensus rules. The current update protocol is described further here. </p> <p>The data event is a signed event and is expected to be created and published by the controller of the given stream it is being appended. A timestamp event on the other hand can be created by any participant in network, given that it is a valid timestamp proof. Typically in the Ceramic network they will be created and published by a timestamping service. </p>"},{"location":"protocol/streams/lifecycle/#read-lifecycle","title":"Read Lifecycle","text":""},{"location":"protocol/streams/lifecycle/#query","title":"Query","text":"<p>The network can be queried to discover the latest tips for any stream by StreamId. Knowing both the StreamId and tip then allows any node to sync the stream. Query requests are broadcast to the entire network to discover peers that have tips for any given stream. Future query protocols can be optimized and include other stream attributes and values to discover streams and stream tips. The current query protocol is described further here. </p>"},{"location":"protocol/streams/lifecycle/#sync","title":"Sync","text":"<p>Streams can be synced and loaded by knowing both the StreamId and the latest event (tip). Given the latest tip you can traverse the stream event log from event to event in order until the Init Event is reached. Each event is loaded from peers in the network, any peer with a tip is expected to have the entirety of the event stream log. The current sync protocol is described further here </p>"},{"location":"protocol/streams/lifecycle/#durability","title":"Durability","text":""},{"location":"protocol/streams/lifecycle/#maintenance","title":"Maintenance","text":"<p>A stream is a set of events and these events are stored in IPFS nodes. As long as the entire set of events is pinned and advertised on the IPFS DHT, the respective stream will be retrievable. If your application depends on a stream remaining available, it is your application's responsibility to maintain and store all of its events. This can be done by running your own IPFS nodes or by using an IPFS pinning service. Typically you will be running an IPFS node with Ceramic. </p> <p>If any events are not available at a given time, it is not a guarantee that the stream has been deleted. A node with a copy of those events may be temporarily offline and may return at some future time.</p> <p>Other nodes in the network can pin (maintain and store) events from your streams or anyone else's streams. If you suffer a data loss, some other node MAY have preserved your data. Popular streams and their events are likely to be stored on many nodes in the network. </p>"},{"location":"protocol/streams/uri-scheme/","title":"URI Scheme","text":""},{"location":"protocol/streams/uri-scheme/#stream-url","title":"Stream URL","text":"<p>Each stream in Ceramic is identified by a unique URL. This URL is comprised of a protocol identifier for Ceramic and a StreamId as defined below.</p> <p>When encoded as a string the StreamID is prepended with the protocol handler and StreamID is typically encoded using <code>base36</code>. This fully describes which stream and where it is located, in this case it can be found on the Ceramic Network.</p> <pre><code>ceramic://&lt;StreamId&gt;\n</code></pre> <p>For example, a StreamId may look as follows:</p> <pre><code>ceramic://kjzl6fddub9hxf2q312a5qjt9ra3oyzb7lthsrtwhne0wu54iuvj852bw9wxfvs\n</code></pre> <p>EventIds can also be encoded in the same way. </p> <pre><code>ceramic://&lt;EventId&gt;\n</code></pre>"},{"location":"protocol/streams/uri-scheme/#streamid","title":"StreamId","text":"<p>A StreamId is composed of a StreamId code, a stream type, and a CID. It is used to reference a specific and unique event stream. StreamIds are similar to CIDs in IPLD, and use multiformats, but they provide additional information specific to Ceramic event streams. This also allows them to be distinguished from CIDs. The init event of an event stream is used to create the StreamId. </p> <p>StreamIds are defined as:</p> <pre><code>&lt;streamid&gt; ::= &lt;multibase-prefix&gt;&lt;multicodec-streamid&gt;&lt;stream-type&gt;&lt;init-cid-bytes&gt;\n\n# e.g. using CIDv1\n&lt;streamid&gt; ::= &lt;multibase-prefix&gt;&lt;multicodec-streamid&gt;&lt;stream-type&gt;&lt;multicodec-cidv1&gt;&lt;multicodec-content-type&gt;&lt;multihash-content-address&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;multibase-prefix&gt;</code> is a multibase code (1 or 2 bytes), to ease encoding StreamIds into various bases. NOTE: Binary (not text-based) protocols and formats may omit the multibase prefix when the encoding is unambiguous.</li> <li><code>&lt;multicodec-streamid&gt;</code> <code>0xce</code> is a multicodec used to indicate that it's a StreamId, encoded as a varint</li> <li><code>&lt;stream-type&gt;</code> is a varint representing the stream type of the stream.</li> <li><code>&lt;init-cid-bytes&gt;</code> is the bytes from the CID of the <code>init event</code>,  stripped of the multibase prefix.</li> </ul> <p>The multicodec for StreamID is <code>0xce</code>. For compatibility with browser urls it's recommended to encode the StreamId using [<code>base36</code>].</p> <p>The stream type value does not currently have any functionality at the protocol level. Rather, it is used by applications building on top of Ceramic (e.g. ComposeDB) to distinguish between different logic that is applied when processing events. Stream Type values have to be registered in the table of CIP-59. </p>"},{"location":"protocol/streams/uri-scheme/#eventid","title":"EventId","text":"<p>EventIds extend StreamIds to reference a specific event in a specific stream. Additional bytes are added to the end of a StreamId. If it represents the genesis event the zero byte is added (<code>0x00</code>) otherwise the CID that represents the event is added.</p> <p>EventIds are defined as</p> <pre><code>&lt;streamid&gt; ::= &lt;multibase-prefix&gt;&lt;multicodec-streamid&gt;&lt;stream-type&gt;\n  &lt;genesis-cid-bytes&gt;\n  &lt;event-reference&gt;\n\n# e.g. using CIDv1 and representing the genesis event\n&lt;streamid&gt; ::= &lt;multibase-prefix&gt;&lt;multicodec-streamid&gt;&lt;stream-type&gt;\n  &lt;multicodec-cidv1&gt;&lt;multicodec-content-type&gt;&lt;multihash-content-address&gt;\n  &lt;0x00&gt;\n\n# e.g. using CIDv1 and representing an arbitrary event in the log\n&lt;streamid&gt; ::= &lt;multibase-prefix&gt;&lt;multicodec-streamid&gt;&lt;stream-type&gt;\n  &lt;multicodec-cidv1&gt;&lt;multicodec-content-type-1&gt;&lt;multihash-content-address-1&gt;\n  &lt;multicodec-cidv1&gt;&lt;multicodec-content-type-2&gt;&lt;multihash-content-address-2&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;event-reference&gt;</code> is either the zero byte (<code>0x00</code>) or CID bytes.</li> </ul>"},{"location":"protocol/streams/uri-scheme/#stream-versions","title":"Stream Versions","text":"<p>Each EventId can also be considered a reference to a specific version of a stream. At any EventId, a stream can be loaded up until that event and the resulting set of events are considered the version of that stream.</p>"},{"location":"reference/","title":"Ceramic Reference Documentation","text":"<p>This section contains reference documentation as well as instructions for common usage for core Ceramic libraries and various developer tools in the ecosystem.</p>"},{"location":"reference/#ceramic-clients","title":"Ceramic Clients","text":"<ul> <li>Ceramic JS HTTP client</li> <li>DID JSON-RPC client</li> </ul>"},{"location":"reference/#accounts","title":"Accounts","text":"<ul> <li>DID Session</li> <li>3ID DID libraries</li> <li>Key DID libraries</li> </ul>"},{"location":"reference/#streams","title":"Streams","text":"<ul> <li>Tile Document client</li> <li>CAIP-10 Link client</li> </ul>"},{"location":"reference/#glaze-suite","title":"Glaze Suite","text":"<ul> <li>DID DataStore client</li> <li>DevTools library</li> </ul> <ul> <li>DataModel client</li> <li>Tile loader library</li> </ul>"},{"location":"reference/#selfid-sdk","title":"Self.ID SDK","text":"<ul> <li>Self.ID Framework</li> <li>Self.ID React</li> <li>Self.ID Web</li> <li>Self.ID Core</li> <li>Self.ID Image utilities</li> </ul>"},{"location":"reference/#glossary","title":"Glossary","text":"<ul> <li>Glossary of terms</li> </ul>"},{"location":"reference/glossary/","title":"Glossary of terms","text":"<p>This page contains a glossary of terms for Ceramic. Consider this list a work-in-progress; we will continue to update it until it's complete.</p>"},{"location":"reference/glossary/#core-concepts","title":"Core concepts","text":""},{"location":"reference/glossary/#streams","title":"Streams","text":"<p>Streams are DAG-based data structures for storing continuous, mutable streams of content on IPFS and tracking state in a completely decentralized, peer-to-peer way. When syncing or loading a stream from the network, you will always get back the current state.</p>"},{"location":"reference/glossary/#streamid","title":"StreamID","text":"<p>A StreamID is an immutable identifier for a stream. StreamIDs enable continuous streams of data to be referenced by a persistent identifier instead of by constantly-changing IPFS CIDs.</p>"},{"location":"reference/glossary/#streamtypes","title":"StreamTypes","text":"<p>StreamTypes are functions used for processing updates to streams. StreamTypes handle everything from defining the data structure of the stream, to what can be stored in its commits, its state transitition function, authentication requirements, and conflict resolution strategy. Every stream must specify a StreamType; and StreamTypes run on Ceramic nodes. Ceramic comes pre-installed with various StreamTypes, or you can code your own.</p>"},{"location":"reference/glossary/#commits","title":"Commits","text":"<p>Commits are individual IPFS records that make up a stream. Streams may contain one or more commits.</p>"},{"location":"reference/glossary/#genesis-commit","title":"Genesis commit","text":"<p>A genesis commit is the first commit in a stream. Genesis commits may be signed by a public key, or unsigned.</p>"},{"location":"reference/glossary/#signed-commit","title":"Signed commit","text":"<p>Signed commits are commits that update the state of a stream. All signed commits need to be cryptographically signed by a public key.</p>"},{"location":"reference/glossary/#anchor-commit","title":"Anchor commit","text":"<p>Anchor commits are commits that contain a blockchain timestamp, providing an immutable record of time and ordering to other commits in the stream, sometimes known as a proof-of-publication. Anchor commits are needed since vanilla merkle DAGs have no notion of absolute time needed to build consensus.</p>"},{"location":"reference/glossary/#commitid","title":"CommitID","text":"<p>A commitID is an immutable identifier for a specific commit in a stream.</p>"},{"location":"reference/glossary/#state","title":"State","text":"<p>State represents the state of a stream at various points in time. When a stream is loaded or queried from the network, the current state is returned.</p>"},{"location":"reference/glossary/#tip","title":"Tip","text":"<p>A tip is the CID for the most recent commit(s) of a stream.</p>"},{"location":"reference/glossary/#conflict-resolution-strategy","title":"Conflict resolution strategy","text":"<p>A conflict resolution strategy is logic defined by a StreamType that describes how the protocol should handle conflicting updates to a stream that uses this StreamType.</p>"},{"location":"reference/glossary/#controllers","title":"Controllers","text":"<p>Controllers are entities allowed to perform updates to a stream, by creating new signed commits. A given stream may have one or more controllers.</p>"},{"location":"reference/glossary/#stream-authentication","title":"Stream authentication","text":""},{"location":"reference/glossary/#authentication","title":"Authentication","text":"<p>Authentication allows a user to perform protected operations on a stream, such as creating genesis commits, signed commits, or decrypting data. Each StreamType implementation is able to specify its own authentication mechanism as long as the signatures can be resolved/validated by Ceramic, but most StreamTypes use DIDs.</p>"},{"location":"reference/glossary/#dids","title":"DIDs","text":"<p>DIDs is the W3C standard for decentralized identifiers. The DID specification outlines a standard URI scheme for creating a persistent decentralized identifier (DID) for a given subject as well as resolving metadata about that identifier via a DID document. DIDs are used as an authentication mechanism by most StreamTypes.</p>"},{"location":"reference/glossary/#did-methods","title":"DID methods","text":"<p>DID methods are implementations of the DID specification. DID methods must specify a name for the method in the form of a string (see below), a description of where the DID document is stored (or how it is statically generated), and a DID resolver which can return a DID document given a URI that conforms to that particular DID method. There are over 40 DID methods on the W3C's official DID registry. Ceramic can support any DID method if needed, and currently supports the 3ID DID method and the Key DID method. DID URIs look like this:</p> <pre><code>did:&lt;method-name&gt;:&lt;method-specific-identifier&gt;\n</code></pre>"},{"location":"reference/glossary/#did-document","title":"DID document","text":"<p>DID documents are documents which contain metadata about a given DID. At a minimum they should contain cryptographic key material used for signature verification and encryption/decryption. They may be mutable where their keys and content can be changed/rotated (i.e. 3ID DID method) or statically generated where their contents cannot be manually changed (i.e. Key DID method).</p>"},{"location":"reference/glossary/#did-resolver","title":"DID resolver","text":"<p>DID resolvers are software libraries responsible for returning a DID document given a DID string. Each DID method has at least one resolver implementation. For all DID methods supported by Ceramic, the corresponding DID resolver must be included in a Ceramic node. Ceramic uses DID resolvers to verify stream transactions by comparing the signature on the transaction to the controller of the stream. For the transaction to be successfully processed, a public key corresponding to the transaction signature must be present in the DID Document of the DID listed as a controller.</p>"},{"location":"reference/glossary/#did-providers","title":"DID providers","text":"<p>DID providers are software libraries that expose a json-rpc interface which allows for the creation and usage of a DID that conforms to a particular DID method. Usually a DID provider is constructed using a seed that the user controls. When using Ceramic with streams that require DIDs for authentication, applications either need to integrate a DID provider library, which leaves the responsibility of key management up to the application, or a DID wallet, which is a more user-friendly experience.</p>"},{"location":"reference/glossary/#did-wallets","title":"DID wallets","text":"<p>DID wallets are software libraries or end-user applications that wrap DID providers with additional capabilities. 3ID Connect is the most popular DID wallet SDK that allows users create, manage, and use a 3ID DID method with their existing blockchain wallets, and without needing to install any additional software.</p>"},{"location":"reference/glossary/#network","title":"Network","text":""},{"location":"reference/glossary/#clients","title":"Clients","text":"<p>Clients are software libraries that provide developer interfaces to a Ceramic node. Clients are responsible for authenticating users, providing StreamType-specific interfaces for generating genesis commits and signed commits, and providing generic, streamtype-agnostic interfaces for loading or querying streams. A list of Ceramic clients can be found here.</p>"},{"location":"reference/glossary/#nodes","title":"Nodes","text":"<p>Nodes are software libraries that provide core protocol functionality for the Ceramic network. Nodes are responsible for processing stream updates (in the form of signed commits from clients), storing state for the streams that it cares about, responding to queries, networking with other nodes, replicating streams across the network, and sending valid signed commits to an external anchor service for generating anchor commits.</p>"},{"location":"reference/glossary/#anchor-service","title":"Anchor service","text":"<p>A Ceramic Anchor Service (CAS) is a hosted \"layer-2\" solution for generating anchor commits for many different stream transactions in a scalable, low cost manner. Ceramic nodes are responsible for sending anchor requests containing a StreamID and a CommitID to a CAS, which then batches these transactions into a merkle tree, and includes the merkle root into a blockchain platform in a single transaction (currently Ethereum). After the transaction makes its way onto a blockchain, a Ceramic node creates an anchor commit which includes a reference to the blockchain transaction for every anchored stream. A CAS eliminates the need for each stream transaction to have its own corresponding blockchain transaction, which would be slower and more expensive.</p>"},{"location":"reference/glossary/#networks","title":"Networks","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over a dedicated libp2p topic. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another. Currently, Ceramic has three primary networks: mainnet, Clay Testnet, and dev unstable.</p>"},{"location":"reference/glossary/#mainnet","title":"Mainnet","text":"<p>Mainnet is the Ceramic network used for production deployments. For more information on mainnet, see the Networks page.</p>"},{"location":"reference/glossary/#clay-testnet","title":"Clay Testnet","text":"<p>Clay Testnet is a Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. For more information on Clay Testnet, see the Networks page.</p>"},{"location":"reference/glossary/#dev-unstable","title":"Dev Unstable","text":"<p>Dev Unstable is a Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the <code>develop</code> branch of js-ceramic. It should be considered unstable and highly experimental.</p>"},{"location":"reference/glossary/#underlying-technologies","title":"Underlying technologies","text":""},{"location":"reference/glossary/#ipfs","title":"IPFS","text":"<p>IPFS is the Interplanetary File System. Simply put, IPFS is a way to address static content using CIDs and to discover this content over a peer-to-peer network of nodes. Ceramic relies on IPFS for storing the commits that make up streams and discovering this data over the network.</p>"},{"location":"reference/glossary/#cid","title":"CID","text":"<p>A CID (content identifier) is an immutable identifier for a discrete piece of static content stored on IPFS. CIDs are essentially a hash of the content along with metadata that describes how the content is encoded. Ceramic streams consist of multiple CIDs, encoded using dag-jose (and other formats such as dag-cbor), and linked together using IPLD.</p>"},{"location":"reference/glossary/#ipld","title":"IPLD","text":"<p>IPLD (Interplanetary Linked Data) is the data structures layer of IPFS. It is used to link multiple CIDs together into higher-level linked-data structures. Ceramic uses IPLD to create the data structures for streams.</p>"},{"location":"reference/glossary/#dagjose","title":"DagJOSE","text":"<p>DagJOSE is a codec for IPLD which stores content in IPFS using IETF's JOSE (JSON object signing and encryption) format. With DagJOSE, each data object actually consists of two separate but linked CIDs. It supports both signed and encrypted objects. JWS is used for signed objects and it encodes the payload as a CID, which means that the actual payload is a separate IPLD object. JWE is used for encrypted objects, and it requires the ciphertext to be a CID in order to not leak the full cleartext. A separate inline CID is used to encode the entire cleartext. For more information refer to the DagJOSE spec.</p>"},{"location":"reference/glossary/#libp2p","title":"Libp2p","text":"<p>Libp2p is the peer-to-peer networking protocol that is used by Ceramic. It is included as part of the IPFS stack. Ceramic relies on libp2p for discovering data over the network and communicating between nodes. Libp2p is also used by other major decentralized platforms such as Ethereum (Eth2) and Polkadot.</p>"},{"location":"reference/glossary/#ethereum","title":"Ethereum","text":"<p>Ethereum is the world's leading public, permissionless smart contract blockchain platform. Ceramic uses Ethereum for generating the timestamps contained within anchor commits.</p>"},{"location":"reference/accounts/3id-did/","title":"3ID DID libraries","text":"<p>\u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f The 3ID DID Method has been deprecated. Please use DID PKH using DID Session! \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f</p> <p>The 3ID DID libraries provide support for the <code>did:3</code> method as a Ceramic account, which notably uses Ceramic to store DID documents as Ceramic streams, enabling features such as supporting multiple authentication keys and rotating these keys.</p>"},{"location":"reference/accounts/3id-did/#available-libraries","title":"Available libraries","text":"<ul> <li>The 3ID DID resolver allows a DID JSON-RPC client to resolve accounts using the <code>did:3</code> method from the Ceramic network</li> <li>The 3ID DID provider allows applications to create and use 3ID DID accounts to perform transactions</li> <li>3ID Connect exposes a hosted implementation of the 3ID DID provider for use with web applications (recommended)</li> </ul>"},{"location":"reference/accounts/3id-did/#3id-did-resolver","title":"3ID DID resolver","text":"<p>A 3ID DID resolver is needed to resolve DID documents using the <code>did:3</code> method.</p>"},{"location":"reference/accounts/3id-did/#installation","title":"Installation","text":"<pre><code>npm install @ceramicnetwork/3id-did-resolver key-did-resolver\n</code></pre> <p>A Ceramic client is also needed to use this resolver:</p> <pre><code>npm install @ceramicnetwork/http-client\n</code></pre>"},{"location":"reference/accounts/3id-did/#usage","title":"Usage","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\n\nfunction createCeramicWith3ID() {\nconst ceramic = new CeramicClient()\nconst did = new DID({\nresolver: {\n// A Ceramic client instance is needed by the 3ID DID resolver to load DID documents\n...get3IDResolver(ceramic),\n// `did:key` DIDs are used internally by 3ID DIDs, therefore the DID instance must be able to resolve them\n...getKeyResolver(),\n},\n})\n// This will allow the Ceramic client instance to resolve DIDs using the `did:3` method\nceramic.did = did\n}\n</code></pre>"},{"location":"reference/accounts/3id-did/#3id-did-provider","title":"3ID DID provider","text":"<p>The 3ID DID provider module implements a provider to create and manage DIDs using the <code>did:3</code> method, either using a <code>seed</code> or an <code>authId</code> associated to an <code>authSecret</code> (recommended).</p> <p>It is up to applications using the 3ID DID provider to take care of the security of authentication secrets and seeds, whether they are providing a custodial key management, prompting users to input secrets, or alternative solutions.</p>"},{"location":"reference/accounts/3id-did/#installation_1","title":"Installation","text":"<pre><code>npm install @3id/did-provider\n</code></pre>"},{"location":"reference/accounts/3id-did/#permissions-management","title":"Permissions management","text":"<p>The <code>getPermission</code> parameter is always required when creating an instance of <code>ThreeIdProvider</code>. It allows your application to request actions from a 3ID, such as signing and/or decrypting data. When called, this function should prompt the user in the UI asking for permission to the given paths. You would likely need to implement a UI for this.</p> <p>The function is called with one parameter which is the request object. It looks like this:</p> <pre><code>{\ntype: 'authenticate',\norigin: 'https://my.app.origin',\npayload: {\npaths: ['/path/1', '/path/2']\n}\n}\n</code></pre> <p>In the above example the app with origin <code>https://my.app.origin</code> is requesting access to /path/1 and /path/2. If the user approves, the function should return the paths array. If they decline, it will return an empty array. Note that a user may approve only some of the requested paths, which would return an array containing only the approved paths.</p> <p>The most simple <code>getPermission</code> function simply grants all requested permissions.</p> <pre><code>function getPermission(request) {\nreturn Promise.resolve(request.payload.paths)\n}\n</code></pre>"},{"location":"reference/accounts/3id-did/#usage-with-authid-and-secret","title":"Usage with authID and secret","text":"<p>This is the recommended method for using a 3ID DID provider.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\nimport { ThreeIdProvider } from '@3id/did-provider'\n\n// `authSecret` must be a 32-byte long Uint8Array\nasync function authenticateWithSecret(authSecret) {\nconst ceramic = new CeramicClient()\n\nconst threeID = await ThreeIdProvider.create({\nauthId: 'myAuthID',\nauthSecret,\n// See the section above about permissions management\ngetPermission: (request) =&gt; Promise.resolve(request.payload.paths),\n})\n\nconst did = new DID({\nprovider: threeID.getDidProvider(),\nresolver: {\n...get3IDResolver(ceramic),\n...getKeyResolver(),\n},\n})\n\n// Authenticate the DID using the 3ID provider\nawait did.authenticate()\n\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n</code></pre>"},{"location":"reference/accounts/3id-did/#usage-with-seed","title":"Usage with seed","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\nimport { ThreeIdProvider } from '@3id/did-provider'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateWithSecret(seed) {\nconst ceramic = new CeramicClient()\n\nconst threeID = await ThreeIdProvider.create({\nseed,\n// See the section above about permissions management\ngetPermission: (request) =&gt; Promise.resolve(request.payload.paths),\n})\n\nconst did = new DID({\nprovider: threeID.getDidProvider(),\nresolver: {\n...get3IDResolver(ceramic),\n...getKeyResolver(),\n},\n})\n\n// Authenticate the DID using the 3ID provider\nawait did.authenticate()\n\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n</code></pre>"},{"location":"reference/accounts/3id-did/#3id-connect","title":"3ID Connect","text":"<p>3ID Connect is an in-browser 3ID DID provider, using blockchain wallets to create deterministic authentication secrets using to control a DID.</p> <p>Using 3ID Connect, web apps do not need to take care of key custody directly, but rather to use an authentication provider such as <code>EthereumAuthProvider</code> to allow 3ID Connect to generate the necessarry authentication secrets.</p>"},{"location":"reference/accounts/3id-did/#installation_2","title":"Installation","text":"<pre><code>npm install @3id/connect\n</code></pre>"},{"location":"reference/accounts/3id-did/#usage_1","title":"Usage","text":"<p>3ID Connect is a browser-only library, if your app has shared code between browser and server logic, you need to make sure the following code is not executed server-side, otherwise it will not work and may throw errors.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\nimport { EthereumAuthProvider, ThreeIdConnect } from '@3id/connect'\n\n// Create a ThreeIdConnect connect instance as soon as possible in your app to start loading assets\nconst threeID = new ThreeIdConnect()\n\nasync function authenticateWithEthereum(ethereumProvider) {\n// Request accounts from the Ethereum provider\nconst accounts = await ethereumProvider.request({\nmethod: 'eth_requestAccounts',\n})\n// Create an EthereumAuthProvider using the Ethereum provider and requested account\nconst authProvider = new EthereumAuthProvider(ethereumProvider, accounts[0])\n// Connect the created EthereumAuthProvider to the 3ID Connect instance so it can be used to\n// generate the authentication secret\nawait threeID.connect(authProvider)\n\nconst ceramic = new CeramicClient()\nconst did = new DID({\n// Get the DID provider from the 3ID Connect instance\nprovider: threeID.getDidProvider(),\nresolver: {\n...get3IDResolver(ceramic),\n...getKeyResolver(),\n},\n})\n\n// Authenticate the DID using the 3ID provider from 3ID Connect, this will trigger the\n// authentication flow using 3ID Connect and the Ethereum provider\nawait did.authenticate()\n\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n\n// When using extensions such as MetaMask, an Ethereum provider may be injected as `window.ethereum`\nasync function tryAuthenticate() {\nif (window.ethereum == null) {\nthrow new Error('No injected Ethereum provider')\n}\nawait authenticateWithEthereum(window.ethereum)\n}\n</code></pre>"},{"location":"reference/accounts/did-session/","title":"Module: did-session","text":"<p>Manages user account DIDs in web based environments.</p>"},{"location":"reference/accounts/did-session/#purpose","title":"Purpose","text":"<p>Manages, creates and authorizes a DID session key for a user. Returns an authenticated DIDs instance to be used in other Ceramic libraries. Supports did:pkh for blockchain accounts with Sign-In with Ethereum and CACAO for authorization.</p>"},{"location":"reference/accounts/did-session/#installation","title":"Installation","text":"<pre><code>npm install did-session\n</code></pre>"},{"location":"reference/accounts/did-session/#usage","title":"Usage","text":"<p>Authorize and use DIDs where needed. Import the AuthMethod you need, Ethereum accounts are used here for example.</p> <pre><code>import { DIDSession } from 'did-session'\nimport { EthereumWebAuth, getAccountId } from '@didtools/pkh-ethereum'\n\nconst ethProvider = // import/get your web3 eth provider\nconst addresses = await ethProvider.enable()\nconst accountId = await getAccountId(ethProvider, addresses[0])\nconst authMethod = await EthereumWebAuth.getAuthMethod(ethProvider, accountId)\n\nconst session = await DIDSession.authorize(authMethod, { resources: [...]})\n\n// Uses DIDs in ceramic, combosedb &amp; glaze libraries, ie\nconst ceramic = new CeramicClient()\nceramic.did = session.did\n\n// pass ceramic instance where needed\n</code></pre> <p>You can serialize a session to store for later and then re-initialize. Currently sessions are valid for 1 day by default.</p> <pre><code>// Create session as above, store for later\nconst session = await DIDSession.authorize(authMethod, { resources: [...]})\nconst sessionString = session.serialize()\n\n// write/save session string where you want (ie localstorage)\n// ...\n\n// Later re initialize session\nconst session2 = await DIDSession.fromSession(sessionString)\nconst ceramic = new CeramicClient()\nceramic.did = session2.did\n</code></pre> <p>Additional helper functions are available to help you manage a session lifecycle and the user experience.</p> <pre><code>// Check if authorized or created from existing session string\ndidsession.hasSession\n\n// Check if session expired\ndidsession.isExpired\n\n// Get resources session is authorized for\ndidsession.authorizations\n\n// Check number of seconds till expiration, may want to re auth user at a time before expiration\ndidsession.expiresInSecs\n</code></pre>"},{"location":"reference/accounts/did-session/#configuration","title":"Configuration","text":"<p>The resources your app needs to write access to must be passed during authorization. Resources are an array of Model Stream Ids or Streams Ids. Typically you will just pass resources from <code>@composedb</code> libraries as you will already manage your Composites and Models there. For example:</p> <pre><code>import { ComposeClient } from '@composedb/client'\n\n//... Reference above and `@composedb` docs for additional configuration here\n\nconst client = new ComposeClient({ceramic, definition})\nconst resources = client.resources\nconst session = await DIDSession.authorize(authMethod, { resources })\nclient.setDID(session.did)\n</code></pre> <p>By default a session will expire in 1 day. You can change this time by passing the <code>expiresInSecs</code> option to indicate how many seconds from the current time you want this session to expire.</p> <pre><code>const oneWeek = 60 * 60 * 24 * 7\nconst session = await DIDSession.authorize(authMethod, { resources: [...], expiresInSecs: oneWeek })\n</code></pre> <p>A domain/app name is used when making requests, by default in a browser based environment the library will use the domain name of your app. If you are using the library in a non web based environment you will need to pass the <code>domain</code> option otherwise an error will thrown.</p> <pre><code>const session = await DIDSession.authorize(authMethod, { resources: [...], domain: 'YourAppName' })\n</code></pre>"},{"location":"reference/accounts/did-session/#typical-usage-pattern","title":"Typical usage pattern","text":"<p>A typical pattern is to store a serialized session in local storage and load on use if available. Then check that a session is still valid before making writes.</p> <p>Warning: LocalStorage is used for illustrative purposes here and may not be best for your app, as there is a number of known issues with storing secret material in browser storage. The session string allows anyone with access to that string to make writes for that user for the time and resources that session is valid for. How that session string is stored and managed is the responsibility of the application.</p> <pre><code>import { DIDSession } from 'did-session'\nimport type { AuthMethod } from '@didtools/cacao'\nimport { EthereumWebAuth, getAccountId } from '@didtools/pkh-ethereum'\n\nconst ethProvider = // import/get your web3 eth provider\nconst addresses = await ethProvider.enable()\nconst accountId = await getAccountId(ethProvider, addresses[0])\nconst authMethod = await EthereumWebAuth.getAuthMethod(ethProvider, accountId)\n\nconst loadSession = async(authMethod: AuthMethod):Promise&lt;DIDSession&gt; =&gt; {\nconst sessionStr = localStorage.getItem('didsession')\nlet session\n\nif (sessionStr) {\nsession = await DIDSession.fromSession(sessionStr)\n}\n\nif (!session || (session.hasSession &amp;&amp; session.isExpired)) {\nsession = await DIDSession.authorize(authMethod, { resources: [...]})\nlocalStorage.setItem('didsession', session.serialize())\n}\n\nreturn session\n}\n\nconst session = await loadSession(authMethod)\nconst ceramic = new CeramicClient()\nceramic.did = session.did\n\n// pass ceramic instance where needed, ie ceramic, composedb, glaze\n// ...\n\n// before ceramic writes, check if session is still valid, if expired, create new\nif (session.isExpired) {\nconst session = loadSession(authMethod)\nceramic.did = session.did\n}\n\n// continue to write\n</code></pre>"},{"location":"reference/accounts/did-session/#upgrading-from-did-session0xx-to-did-session1xx","title":"Upgrading from <code>did-session@0.x.x</code> to <code>did-session@1.x.x</code>","text":"<p>AuthProviders change to AuthMethod interfaces. Similarly you can import the auth libraries you need. How you configure and manage  these AuthMethods may differ, but each will return an AuthMethod function to be used with did-session.</p> <pre><code>// Before with v0.x.x\n//...\nimport { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'\n\nconst ethProvider = // import/get your web3 eth provider\nconst addresses = await ethProvider.enable()\nconst authProvider = new EthereumAuthProvider(ethProvider, addresses[0])\nconst session = new DIDSession({ authProvider })\nconst did = await session.authorize()\n\n// Now did-session@1.0.0\n...\nimport { EthereumWebAuth, getAccountId } from '@didtools/pkh-ethereum'\n\nconst ethProvider = // import/get your web3 eth provider\nconst addresses = await ethProvider.enable()\nconst accountId = await getAccountId(ethProvider, addresses[0])\nconst authMethod = await EthereumWebAuth.getAuthMethod(ethProvider, accountId)\nconst session = await DIDSession.authorize(authMethod, { resources: [...]})\nconst did = session.did\n</code></pre>"},{"location":"reference/accounts/did-session/#upgrading-from-glazeddid-session-to-did-session","title":"Upgrading from <code>@glazed/did-session</code> to <code>did-session</code>","text":"<p><code>authorize</code> changes to a static method which returns a did-session instance and <code>getDID()</code> becomes a <code>did</code> getter. For example:</p> <pre><code>// Before @glazed/did-session\nconst session = new DIDSession({ authProvider })\nconst did = await session.authorize()\n\n// Now did-session\nconst session = await DIDSession.authorize(authMethod, { resources: [...]})\nconst did = session.did\n</code></pre> <p>Requesting resources are required now when authorizing, before wildcard (access all) was the default. You can continue to use wildcard by passing the following * below. Wildcard is typically only used with <code>@glazed</code> libraries and/or tile documents and it is best to switch over when possible, as the wildcard option may be * deprecated in the future. When using with composites/models you should request the minimum needed resources instead.</p> <pre><code>const session = await DIDSession.authorize(authMethod, { resources: [`ceramic://*`]})\nconst did = session.did\n</code></pre>"},{"location":"reference/accounts/did-session/#class-didsession","title":"Class: DIDSession","text":""},{"location":"reference/accounts/did-session/#constructors","title":"Constructors","text":""},{"location":"reference/accounts/did-session/#constructor","title":"constructor","text":"<p>\u2022 new DIDSession(<code>params</code>)</p>"},{"location":"reference/accounts/did-session/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>SessionParams</code>"},{"location":"reference/accounts/did-session/#accessors","title":"Accessors","text":""},{"location":"reference/accounts/did-session/#authorizations","title":"authorizations","text":"<p>\u2022 <code>get</code> authorizations(): <code>string</code>[]</p> <p>Get the list of resources a session is authorized for</p>"},{"location":"reference/accounts/did-session/#returns","title":"Returns","text":"<p><code>string</code>[]</p>"},{"location":"reference/accounts/did-session/#cacao","title":"cacao","text":"<p>\u2022 <code>get</code> cacao(): <code>Cacao</code></p> <p>Get the session CACAO</p>"},{"location":"reference/accounts/did-session/#returns_1","title":"Returns","text":"<p><code>Cacao</code></p>"},{"location":"reference/accounts/did-session/#did","title":"did","text":"<p>\u2022 <code>get</code> did(): <code>DID</code></p> <p>Get DID instance, if authorized</p>"},{"location":"reference/accounts/did-session/#returns_2","title":"Returns","text":"<p><code>DID</code></p>"},{"location":"reference/accounts/did-session/#expireinsecs","title":"expireInSecs","text":"<p>\u2022 <code>get</code> expireInSecs(): <code>number</code></p> <p>Number of seconds until a session expires</p>"},{"location":"reference/accounts/did-session/#returns_3","title":"Returns","text":"<p><code>number</code></p>"},{"location":"reference/accounts/did-session/#hassession","title":"hasSession","text":"<p>\u2022 <code>get</code> hasSession(): <code>boolean</code></p>"},{"location":"reference/accounts/did-session/#returns_4","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/accounts/did-session/#id","title":"id","text":"<p>\u2022 <code>get</code> id(): <code>string</code></p> <p>DID string associated to the session instance. session.id == session.getDID().parent</p>"},{"location":"reference/accounts/did-session/#returns_5","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/accounts/did-session/#isexpired","title":"isExpired","text":"<p>\u2022 <code>get</code> isExpired(): <code>boolean</code></p> <p>Determine if a session is expired or not</p>"},{"location":"reference/accounts/did-session/#returns_6","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/accounts/did-session/#methods","title":"Methods","text":""},{"location":"reference/accounts/did-session/#isauthorized","title":"isAuthorized","text":"<p>\u25b8 isAuthorized(<code>resources?</code>): <code>boolean</code></p> <p>Determine if session is available and optionally if authorized for given resources</p>"},{"location":"reference/accounts/did-session/#parameters_1","title":"Parameters","text":"Name Type <code>resources?</code> <code>string</code>[]"},{"location":"reference/accounts/did-session/#returns_7","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/accounts/did-session/#serialize","title":"serialize","text":"<p>\u25b8 serialize(): <code>string</code></p> <p>Serialize session into string, can store and initalize the same session again while valid</p>"},{"location":"reference/accounts/did-session/#returns_8","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/accounts/did-session/#authorize","title":"authorize","text":"<p>\u25b8 <code>Static</code> authorize(<code>authMethod</code>, <code>authOpts?</code>): <code>Promise</code>&lt;<code>DIDSession</code>&gt;</p> <p>Request authorization for session</p>"},{"location":"reference/accounts/did-session/#parameters_2","title":"Parameters","text":"Name Type <code>authMethod</code> <code>AuthMethod</code> <code>authOpts</code> <code>AuthOpts</code>"},{"location":"reference/accounts/did-session/#returns_9","title":"Returns","text":"<p><code>Promise</code>&lt;<code>DIDSession</code>&gt;</p>"},{"location":"reference/accounts/did-session/#fromsession","title":"fromSession","text":"<p>\u25b8 <code>Static</code> fromSession(<code>session</code>): <code>Promise</code>&lt;<code>DIDSession</code>&gt;</p> <p>Initialize a session from a serialized session string</p>"},{"location":"reference/accounts/did-session/#parameters_3","title":"Parameters","text":"Name Type <code>session</code> <code>string</code>"},{"location":"reference/accounts/did-session/#returns_10","title":"Returns","text":"<p><code>Promise</code>&lt;<code>DIDSession</code>&gt;</p>"},{"location":"reference/accounts/did-session/#initdid","title":"initDID","text":"<p>\u25b8 <code>Static</code> initDID(<code>didKey</code>, <code>cacao</code>): <code>Promise</code>&lt;<code>DID</code>&gt;</p>"},{"location":"reference/accounts/did-session/#parameters_4","title":"Parameters","text":"Name Type <code>didKey</code> <code>DID</code> <code>cacao</code> <code>Cacao</code>"},{"location":"reference/accounts/did-session/#returns_11","title":"Returns","text":"<p><code>Promise</code>&lt;<code>DID</code>&gt;</p>"},{"location":"reference/accounts/key-did/","title":"Key DID libraries","text":"<p>The Key DID libraries include the resolver and multiple providers to provide a simple way for developers to get started using the DID client with the <code>did:key</code> method.</p>"},{"location":"reference/accounts/key-did/#available-libraries","title":"Available libraries","text":"<ul> <li>The Key DID resolver allows a DID JSON-RPC client to resolve accounts using the <code>did:key</code> method</li> <li>The Key DID provider ED25519 allows applications to create and use Key DID accounts for ED25519 keypairs. This provider supports encryption.</li> <li>The Key DID provider secp256k1 allows applications to create and use Key DID accounts for secp256k1 keypairs. This provider does not supports encryption.</li> </ul>"},{"location":"reference/accounts/key-did/#key-did-resolver","title":"Key DID resolver","text":"<p>The <code>key-did-resolver</code> module is needed to resolve DID documents using the <code>did:key</code> method.</p>"},{"location":"reference/accounts/key-did/#installation","title":"Installation","text":"<pre><code>npm install key-did-resolver\n</code></pre>"},{"location":"reference/accounts/key-did/#usage","title":"Usage","text":"<pre><code>import { DID } from 'dids'\nimport { getResolver } from 'key-did-resolver'\n\nasync function resolveDID() {\nconst did = new DID({ resolver: getResolver() })\nreturn await did.resolve('did:key:...')\n}\n</code></pre>"},{"location":"reference/accounts/key-did/#key-did-providers","title":"Key DID providers","text":"<p>Different libraries implement a provider for the <code>did:key</code> method based on different cryptographic primitives. These providers may have different possibilities, for example <code>key-did-provider-ed25519</code> supports encryption while <code>key-did-provider-secp256k1</code> does not.</p>"},{"location":"reference/accounts/key-did/#key-did-provider-ed25519","title":"Key DID provider ED25519","text":"<p>This is the recommended provider for the <code>key:did</code> method in most cases.</p>"},{"location":"reference/accounts/key-did/#installation_1","title":"Installation","text":"<pre><code>npm install key-did-provider-ed25519\n</code></pre>"},{"location":"reference/accounts/key-did/#usage_1","title":"Usage","text":"<pre><code>import { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateDID(seed) {\nconst provider = new Ed25519Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\nawait did.authenticate()\nreturn did\n}\n</code></pre>"},{"location":"reference/accounts/key-did/#key-did-provider-secp256k1","title":"Key DID provider secp256k1","text":"<p>This provider does not support encryption, so using methods such as <code>createJWE</code> on the <code>DID</code> instance is not supported.</p>"},{"location":"reference/accounts/key-did/#installation_2","title":"Installation","text":"<pre><code>npm install key-did-provider-secp256k1\n</code></pre>"},{"location":"reference/accounts/key-did/#usage_2","title":"Usage","text":"<pre><code>import { DID } from 'dids'\nimport { Secp256k1Provider } from 'key-did-provider-secp256k1'\nimport { getResolver } from 'key-did-resolver'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateDID(seed) {\nconst provider = new Secp256k1Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\nawait did.authenticate()\nreturn did\n}\n</code></pre>"},{"location":"reference/accounts/nft-did/","title":"NFT DID","text":""},{"location":"reference/accounts/safe-did/","title":"Safe DID","text":""},{"location":"reference/core-clients/ceramic-http/","title":"Ceramic HTTP client","text":"<p>The Ceramic HTTP client library can be used in browsers and Node.js to connect your application to a Ceramic node. It is actively maintained and supports the latest Ceramic features.</p> <p></p>"},{"location":"reference/core-clients/ceramic-http/#things-to-know","title":"Things to know","text":"<ul> <li>The HTTP client currently supports loading CAIP-10 links (CIP-7) and Tile document (CIP-8) streams.</li> <li>The client is read-only by default, to enable transactions a DID client needs to be attached to the Ceramic client instance.</li> <li>Ceramic streams can be identified by a stream ID or a commit ID. A stream ID is generated when creating the stream and can be used to load the latest version of the stream, while a commit ID represents a specific version of the stream.</li> </ul>"},{"location":"reference/core-clients/ceramic-http/#installation","title":"Installation","text":"<pre><code>npm install @ceramicnetwork/http-client\n</code></pre>"},{"location":"reference/core-clients/ceramic-http/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/core-clients/ceramic-http/#load-a-single-stream","title":"Load a single stream","text":"<pre><code>// Import the client\nimport { CeramicClient } from '@ceramicnetwork/http-client'\n\n// Connect to a Ceramic node\nconst ceramic = new CeramicClient('https://your-ceramic-node.com')\n\n// The `id` argument can be a stream ID (to load the latest version)\n// or a commit ID (to load a specific version)\nasync function load(id) {\nreturn await ceramic.loadStream(id)\n}\n</code></pre>"},{"location":"reference/core-clients/ceramic-http/#load-multiple-streams","title":"Load multiple streams","text":"<p>Rather than using the <code>loadStream</code> method multiple times with <code>Promise.all()</code> to load multiple streams at once, a more efficient way for loading multiple streams is to use the <code>multiQuery</code> method.</p> <pre><code>// Import the client\nimport { CeramicClient } from '@ceramicnetwork/http-client'\n\n// Connect to a Ceramic node\nconst ceramic = new CeramicClient('https://your-ceramic-node.com')\n\n// The `ids` argument can contain an arry of stream IDs (to load the latest version)\n// or commit IDs (to load a specific version)\nasync function loadMulti(ids = []) {\nconst queries = ids.map((streamId) =&gt; ({ streamId }))\n// This will return an Object of stream ID keys to stream values\nreturn await ceramic.multiQuery(queries)\n}\n</code></pre>"},{"location":"reference/core-clients/ceramic-http/#enable-transactions","title":"Enable transactions","text":"<p>In order to create and update streams, the Ceramic client instance must be able to sign transaction payloads by using an authenticated DID instance. The DID client documentation describes the process of authenticating and attaching a DID instance to the Ceramic instance.</p>"},{"location":"reference/core-clients/ceramic-http/#interact-with-json-data","title":"Interact with JSON data","text":"<p>The Tile document client provides APIs to interact specifically with Tile document streams (CIP-8).</p>"},{"location":"reference/core-clients/ceramic-http/#interact-with-crypto-account-links","title":"Interact with crypto account links","text":"<p>The CAIP-10 links client provides APIs to interact specifically with CAIP-10 links streams (CIP-7).</p>"},{"location":"reference/core-clients/did-jsonrpc/","title":"DID JSON-RPC client","text":"<p>DID JSON-RPC client provides a simple JS API for interacting with Ceramic accounts.</p>"},{"location":"reference/core-clients/did-jsonrpc/#things-to-know","title":"Things to know","text":"<ul> <li>Provides the DID object, which must be authenticated, then mounted on the Ceramic object to perform transactions.</li> <li>For Ceramic nodes, the DID client acts as a way to resolve and verify transaction signatures</li> <li>For Ceramic clients, the DID client serves as a way to create an account, authenticate, sign, encrypt</li> <li>If your project requires transactions, you need to install this package or one that offers similar EIP-2844 API support.</li> <li>The DID client library can be used in both browser and Node.js environments.</li> <li>It supports any DID wallet provider that adheres to the EIP-2844 interface.</li> <li>Communicating between a Ceramic client and any account provider.</li> <li>Ceramic does not work without a DID client, as it is how all participants are identified and how transactions and messages are signed and verified.</li> </ul>"},{"location":"reference/core-clients/did-jsonrpc/#installation","title":"Installation","text":"<pre><code>npm install dids\n</code></pre> <p>The <code>DID</code> class provides the interface on top of underlying account libraries. The next step is to set up your account system, which requires you to make some important decisions about your account model and approach to key management. This process consists of three steps: choosing your account types, installing a provider, and installing resolver(s).</p>"},{"location":"reference/core-clients/did-jsonrpc/#choose-your-account-types","title":"Choose your account types","text":"<p>Choosing an account type can significantly impact your users' identity and data interoperability.  For example, some account types are fixed to a single public key (Key DID, PHK DID), so the data is siloed to that key.  In contrast, others (3ID DID) have mutable key management schemes that can support multiple authorized signing keys and works cross-chain with blockchain wallets. Visit each account to learn more about its capabilities.</p>"},{"location":"reference/core-clients/did-jsonrpc/#pkh-did","title":"PKH DID","text":"<p>Based on Sign-in with Ethereum, or similar standards in other blockchain ecosystems. Good for users + most popular. Relies on existing wallet infrastructure.</p>"},{"location":"reference/core-clients/did-jsonrpc/#key-did","title":"Key DID","text":"<p>Simple, self-contained DID method.</p>"},{"location":"reference/core-clients/did-jsonrpc/#nft-did","title":"NFT DID","text":"<p>Experimental DID method using NFT ownership for authentication.</p>"},{"location":"reference/core-clients/did-jsonrpc/#safe-did","title":"Safe DID","text":"<p>Experimental DID method using a Gnosis Safe for authentication.</p>"},{"location":"reference/core-clients/did-jsonrpc/#install-account-resolvers","title":"Install account resolvers","text":"<p>The next step is to install resolver libraries for all account types that you may need to read and verify data (signatures). This includes at least the resolver for the provider or wallet chosen in the previous step. However, most projects install all resolvers to be safe:</p> Account Resolver libraries Maintainer 3ID DID <code>@ceramicnetwork/3id-did-resolver</code> 3Box Labs Key DID <code>key-did-resolver</code> 3Box Labs"},{"location":"reference/core-clients/did-jsonrpc/#install-account-providers","title":"Install account providers","text":"<p>Install providers to manage accounts and sign transactions. Once you have chosen one or more account types, you'll need to install the providers for these account types. These will enable the client-side creation and use of accounts within your application. If your application uses Ceramic in a read-only manner without transactions, you do not need to install a provider.</p>"},{"location":"reference/core-clients/did-jsonrpc/#using-web-wallets","title":"Using web wallets","text":"<p>However, the providers listed above are low-level, run locally, and burden developers with UX issues related to secret key management and transaction signing. Instead of using a local provider, you can alternatively use a wallet system. Wallets wrap providers with additional user experience features related to signing and key management and can be used in place of a provider. The benefit is multiple applications can access the same wallet and key management system, so users have a continuous experience between applications.</p> Account Wallet Benefits Drawbacks 3ID DID <code>3ID Connect</code> \u2705 Sign with blockchain wallets, including MetaMask\u2705 Connect multiple blockchain accounts to one Ceramic account\u2705 Implements 3ID DID\u2705 Works cross-chain\u2705 Sleek UI \u274c Risks <p>Most user-facing applications use the 3ID Connect wallet instead of using a provider.</p>"},{"location":"reference/core-clients/did-jsonrpc/#create-your-own-wallet","title":"Create your own wallet","text":"<p>One option is installing and setting up one or more account providers that run locally. Note that these local signers have different wallet support</p> Account Supported Key Types Provider libraries 3ID DID Ed25519 <code>3id-did-provider</code> Key DID Ed25519 <code>key-did-provider-ed25519</code> Key DID Secp256k1 <code>key-did-provider-secp256k1</code> <p>Note that NFT DID and Safe DID do not have a signer because they are compatible with all other providers.</p>"},{"location":"reference/core-clients/did-jsonrpc/#setup-your-project","title":"Setup your project","text":"<p>You should have installed DID.js and set up your account system, including authentication to perform transactions. When you include everything in your project, it should look like this. Note that the exact code will vary by your setup, including provider and wallet. Consult your provider's documentation for authentication specifics.</p> <pre><code>// Import DID client\nimport { DID } from 'dids'\n\n// Add account system\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// Connect to a Ceramic node\nconst API_URL = 'https://your-ceramic-node.com'\n\n// Create the Ceramic object\nconst ceramic = new CeramicClient(API_URL)\n\n// \u2191 With this setup, you can perform read-only queries.\n// \u2193 Continue to authenticate the account and perform transactions.\n\nasync function authenticateCeramic(seed) {\n// Activate the account by somehow getting its seed.\n// See further down this page for more details on\n// seed format, generation, and key management.\nconst provider = new Ed25519Provider(seed)\n// Create the DID object\nconst did = new DID({ provider, resolver: getResolver() })\n// Authenticate with the provider\nawait did.authenticate()\n// Mount the DID object to your Ceramic object\nceramic.did = did\n}\n</code></pre>"},{"location":"reference/core-clients/did-jsonrpc/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/core-clients/did-jsonrpc/#authenticate-the-user","title":"Authenticate the user","text":"<p>This will flow will vary slightly depending on which account provider library you use. Please see the documentation specific to your provider library.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function createJWS(seed) {\nconst provider = new Ed25519Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\n// Authenticate the DID with the provider\nawait did.authenticate()\n// This will throw an error if the DID instance is not authenticated\nconst jws = await did.createJWS({ hello: 'world' })\n}\n</code></pre>"},{"location":"reference/core-clients/did-jsonrpc/#enable-ceramic-transactions","title":"Enable Ceramic transactions","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\nconst provider = new Ed25519Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\n// Authenticate the DID with the provider\nawait did.authenticate()\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n</code></pre>"},{"location":"reference/core-clients/did-jsonrpc/#resolve-a-did-document","title":"Resolve a DID document","text":"<pre><code>import { DID } from 'dids'\nimport { getResolver } from 'key-did-resolver'\n\n// See https://github.com/decentralized-identity/did-resolver\nconst did = new DID({ resolver: getResolver() })\n\n// Resolve a DID document\nawait did.resolve('did:key:...')\n</code></pre>"},{"location":"reference/core-clients/did-jsonrpc/#store-signed-data-on-ipfs-using-dagjws","title":"Store signed data on IPFS using DagJWS","text":"<p>The DagJWS functionality of the DID library can be used in conjunction with IPFS.</p> <pre><code>const payload = { some: 'data' }\n\n// sign the payload as dag-jose\nconst { jws, linkedBlock } = await did.createDagJWS(payload)\n\n// put the JWS into the ipfs dag\nconst jwsCid = await ipfs.dag.put(jws, {\nformat: 'dag-jose',\nhashAlg: 'sha2-256',\n})\n\n// put the payload into the ipfs dag\nconst block = await ipfs.block.put(linkedBlock, { cid: jws.link })\n\n// get the value of the payload using the payload cid\nconsole.log((await ipfs.dag.get(jws.link)).value)\n// output:\n// &gt; { some: 'data' }\n\n// alternatively get it using the ipld path from the JWS cid\nconsole.log((await ipfs.dag.get(jwsCid, { path: '/link' })).value)\n// output:\n// &gt; { some: 'data' }\n\n// get the jws from the dag\nconsole.log((await ipfs.dag.get(jwsCid)).value)\n// output:\n// &gt; {\n// &gt;   payload: 'AXESINDmZIeFXbbpBQWH1bXt7F2Ysg03pRcvzsvSc7vMNurc',\n// &gt;   signatures: [\n// &gt;     {\n// &gt;       protected: 'eyJraWQiOiJkaWQ6Mzp1bmRlZmluZWQ_dmVyc2lvbj0wI3NpZ25pbmciLCJhbGciOiJFUzI1NksifQ',\n// &gt;       signature: 'pNz3i10YMlv-BiVfqBbHvHQp5NH3x4TAHQ5oqSmNBUx1DH_MONa_VBZSP2o9r9epDdbRRBLQjrIeigdDWoXrBQ'\n// &gt;     }\n// &gt;   ],\n// &gt;   link: CID(bafyreigq4zsipbk5w3uqkbmh2w2633c5tcza2n5fc4x45s6soo54ynxk3q)\n// &gt; }\n</code></pre>"},{"location":"reference/core-clients/did-jsonrpc/#how-it-works","title":"How it Works","text":"<p>As can be observed above, the createDagJWS method takes the payload, encodes it using dag-cbor, and computes its CID. It then uses this CID as the payload of the JWS that is then signed. The JWS that was just created can be put into ipfs using the dag-jose codec. Returned is also the encoded block of the payload. This can be put into ipfs using ipfs.block.put. Alternatively, ipfs.dag.put(payload) would have the same effect.</p>"},{"location":"reference/core-clients/did-jsonrpc/#store-encrypted-data-on-ipfs-with-dagjwe","title":"Store encrypted data on IPFS with DagJWE","text":"<p>The DagJWE functionality allows us to encrypt IPLD data to one or multiple DIDs. The resulting JWE object can then be put into ipfs using the dag-jose codec. A user that is authenticated can at a later point decrypt this object.</p> <pre><code>const cleartext = { some: 'data', coolLink: new CID('bafyqacnbmrqxgzdgdeaui') }\n\n// encrypt the cleartext object\nconst jwe = await did.createDagJWE(cleartext, [\n'did:3:bafy89h4f9...',\n'did:key:za234...',\n])\n\n// put the JWE into the ipfs dag\nconst jweCid = await ipfs.dag.put(jwe, {\nformat: 'dag-jose',\nhashAlg: 'sha2-256',\n})\n\n// get the jwe from the dag and decrypt it\nconst dagJWE = await ipfs.dag.get(jweCid)\nconsole.log(await did.decryptDagJWE(dagJWE))\n// output:\n// &gt; { some: 'data' }\n</code></pre>"},{"location":"reference/glaze/","title":"Glaze Suite","text":"<p>Glaze suite includes a collection of tools for building applications on Ceramic, including data model management tools, runtime libraries for user-centric data storage and retrieval, and client-side tools for caching data from the network. Glaze modules can be used separately, but are best when used together.</p> <p></p> <p> Before reading further and getting started using Glaze packages, you should be familiar with other Ceramic concepts previously presented, such as DIDs, authentication, schemas, streams and stream types.</p>"},{"location":"reference/glaze/#data-model-management","title":"Data model management","text":""},{"location":"reference/glaze/#deploy-from-javascript","title":"Deploy from JavaScript \u2192","text":"<p>The devtools module provides JavaScript APIs for managing and deploying the data models used by your Ceramic application.</p>"},{"location":"reference/glaze/#deploy-from-the-cli","title":"Deploy from the CLI \u2192","text":"<p>The Glaze CLI provides a set of command-line tools for managing and deploying the data models used by your Ceramic application.</p>"},{"location":"reference/glaze/#build-with-data-models","title":"Build with data models","text":""},{"location":"reference/glaze/#user-centric-storage","title":"User-centric storage \u2192","text":"<p>The DID DataStore module provides read and write APIs allowing applications to interact with user data based on data model. DID DataStore also makes it possible for applications to discover all information about a user in one place, forming the basis for user-centric data composability on Ceramic.</p>"},{"location":"reference/glaze/#data-model-aliasing","title":"Data model aliasing \u2192","text":"<p>The DataModel module provides human-readable aliasing for data models at runtime, making it easier to use the DID DataStore API.</p>"},{"location":"reference/glaze/#client-side-caching","title":"Client-side caching","text":""},{"location":"reference/glaze/#tile-loader","title":"Tile loader \u2192","text":"<p>The tile loader module provides client-side batching and caching for Ceramic data, improving the performance of retrieving data from the network in order to populate your application.</p>"},{"location":"reference/glaze/cli/","title":"Glaze CLI","text":""},{"location":"reference/glaze/cli/#purpose","title":"Purpose","text":"<p>The Glaze CLI allows to interact with Ceramic nodes, notably to help support DataModel lifecycle operations, such as the creation, edition and deployment of models.</p>"},{"location":"reference/glaze/cli/#installation","title":"Installation","text":"<pre><code>npm install --global @glazed/cli\n</code></pre> <p>The CLI is then accessible as <code>glaze</code>. Run <code>glaze help</code> to list the available commands.</p>"},{"location":"reference/glaze/cli/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/glaze/cli/#create-a-key-did","title":"Create a key DID","text":"<p>CLI commands performing stream mutations require the 32-byte hexadecimal-encoded seed of a key DID to be provided, either as the <code>--key</code> flag or the <code>DID_KEY</code> environment variable:</p> <pre><code>glaze did:create\n</code></pre> <p>The expected output will be similar to the following, with <code>...</code> used as placeholder for brievety:</p> <pre><code>\u2714 Created DID did:key:z6Mk... with seed ab...f0\n</code></pre> <p>The seed can then be used when running other commands:</p> <pre><code>glaze [command] --key=ab...f0\nDID_KEY=ab...f0 glaze [command]\n</code></pre>"},{"location":"reference/glaze/cli/#create-a-local-model","title":"Create a local model","text":"<p>Creating a local model can be done using the <code>model:create</code> command:</p> <pre><code>glaze model:create my-model\n</code></pre> <p>Note that this model is only stored on your local file system, it will not be available externally.</p>"},{"location":"reference/glaze/cli/#add-a-schema-to-a-local-model","title":"Add a schema to a local model","text":"<p>Schemas can be added to the model, either by using a Stream already present on the given Ceramic node:</p> Using an existing schemaCreating a new schema <pre><code>glaze model:add my-model schema MySchema ceramic://k2...ab\n</code></pre> <pre><code>glaze model:add my-model schema MySchema '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"MySchema\",\"type\":\"object\",\"properties\":{}}' --key=ab...f0\n</code></pre> <p>The <code>model:add</code> command can be used in a similar way to add definitions (<code>model:add my-model definition ...</code>) and tiles (<code>model:add my-model tile ...</code>).</p>"},{"location":"reference/glaze/cli/#import-an-existing-model","title":"Import an existing model","text":"<p>Existing models can be imported in a local model either using JSON files or locally installed packages (that can be imported by Node) using the <code>model:import</code> command:</p> Using a local fileUsing a package name <pre><code>glaze model:import my-model ./model-to-import.json\n</code></pre> <pre><code>glaze model:import my-model package-name-of-model\n</code></pre>"},{"location":"reference/glaze/cli/#export-a-local-model","title":"Export a local model","text":"<p>A local model can be exported to a JSON file using the <code>model:export</code> command:</p> <pre><code>glaze model:export my-model ./my-model.json\n</code></pre>"},{"location":"reference/glaze/cli/#deploy-a-model-to-ceramic","title":"Deploy a model to Ceramic","text":"<p>The <code>model:deploy</code> command can be used to deploy all the streams used by a given model:</p> Deploying a local modelDeploying a model fileDeploying a model package <pre><code>glaze model:deploy my-model\n</code></pre> <pre><code>glaze model:deploy ./my-model.json\n</code></pre> <pre><code>glaze model:deploy package-name-of-model\n</code></pre> <p>Optionally, a second argment can be provided to output the deployed model object to a JSON file:</p> <pre><code>glaze model:deploy my-model ./deployed-model.json\n</code></pre> <p>This output file can then be used by the DataModel runtime.</p>"},{"location":"reference/glaze/cli/#deploy-idx-models","title":"Deploy IDX models","text":"<p>In this example, we will import and deploy the datamodels defined by the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications.</p> <p>First, we need to install these datamodels using npm:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <p>We can then import them when using the CLI in a folder where these npm packages can be resolved from, using the steps described in other examples above:</p> <pre><code>glaze model:create idx\nglaze model:import idx @datamodels/identity-profile-basic\nglaze model:import idx @datamodels/identity-accounts-crypto\nglaze model:import idx @datamodels/identity-accounts-web\nglaze model:deploy idx\n</code></pre>"},{"location":"reference/glaze/classes/datamodel.DataModel/","title":"Class: DataModel&lt;ModelTypes, ModelAliases&gt;","text":"<p>datamodel.DataModel</p> <p>The DataModel runtime provides APIs for interacting with datamodel aliases in applications and libraries. The <code>ModelManager</code> provides complementary APIs for managing datamodels during development.</p> <p>It is exported by the <code>datamodel</code> module.</p> <pre><code>import { DataModel } from '@glazed/datamodel'\n</code></pre>"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> <code>ModelAliases</code> extends <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt; = <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/glaze/classes/datamodel.DataModel/#constructors","title":"Constructors","text":""},{"location":"reference/glaze/classes/datamodel.DataModel/#constructor","title":"constructor","text":"<p>\u2022 new DataModel&lt;<code>ModelTypes</code>, <code>ModelAliases</code>&gt;(<code>params</code>)</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; <code>ModelAliases</code> extends <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt; = <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>DataModelParams</code>&lt;<code>ModelAliases</code>&gt;"},{"location":"reference/glaze/classes/datamodel.DataModel/#accessors","title":"Accessors","text":""},{"location":"reference/glaze/classes/datamodel.DataModel/#aliases","title":"aliases","text":"<p>\u2022 <code>get</code> aliases(): <code>ModelAliases</code></p> <p><code>Model aliases</code> provided in constructor.</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns","title":"Returns","text":"<p><code>ModelAliases</code></p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#loader","title":"loader","text":"<p>\u2022 <code>get</code> loader(): <code>TileLoader</code></p> <p><code>TileLoader</code> instance used internally.</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_1","title":"Returns","text":"<p><code>TileLoader</code></p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#methods","title":"Methods","text":""},{"location":"reference/glaze/classes/datamodel.DataModel/#createtile","title":"createTile","text":"<p>\u25b8 createTile&lt;<code>Alias</code>, <code>ContentType</code>&gt;(<code>schemaAlias</code>, <code>content</code>, <code>options?</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p> <p>Create a TileDocument using a schema identified by the given <code>schemaAlias</code>.</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>ModelTypes</code>[<code>\"schemas\"</code>][<code>Alias</code>]"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_1","title":"Parameters","text":"Name Type <code>schemaAlias</code> <code>Alias</code> <code>content</code> <code>ContentType</code> <code>options</code> <code>CreateOptions</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_2","title":"Returns","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#getdefinitionid","title":"getDefinitionID","text":"<p>\u25b8 getDefinitionID&lt;<code>Alias</code>&gt;(<code>alias</code>): <code>null</code> | <code>string</code></p> <p>Returns the definition stream ID for a given alias, if present in local model aliases.</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_3","title":"Type parameters","text":"Name Type <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_2","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_3","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#getschemaurl","title":"getSchemaURL","text":"<p>\u25b8 getSchemaURL&lt;<code>Alias</code>&gt;(<code>alias</code>): <code>null</code> | <code>string</code></p> <p>Returns the schema stream URL for a given alias, if present in local model aliases.</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_4","title":"Type parameters","text":"Name Type <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_3","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_4","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#gettileid","title":"getTileID","text":"<p>\u25b8 getTileID&lt;<code>Alias</code>&gt;(<code>alias</code>): <code>null</code> | <code>string</code></p> <p>Returns the tile stream ID for a given alias, if present in local model aliases.</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_5","title":"Type parameters","text":"Name Type <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_4","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_5","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#loadtile","title":"loadTile","text":"<p>\u25b8 loadTile&lt;<code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>): <code>Promise</code>&lt;<code>null</code> | <code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p> <p>Load the TileDocument identified by the given <code>alias</code>.</p>"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_6","title":"Type parameters","text":"Name Type <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>ModelTypes</code>[<code>\"schemas\"</code>][<code>ModelTypes</code>[<code>\"tiles\"</code>][<code>Alias</code>]]"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_5","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code>"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/","title":"Class: ModelManager","text":"<p>devtools.ModelManager</p> <p>The ModelManager class provides APIs for managing a data model so it can be used at runtime using the <code>DataModel</code> runtime.</p> <p>The ModelManager class is exported by the <code>devtools</code> module.</p> <pre><code>import { ModelManager } from '@glazed/devtools'\n</code></pre>"},{"location":"reference/glaze/classes/devtools.ModelManager/#constructors","title":"Constructors","text":""},{"location":"reference/glaze/classes/devtools.ModelManager/#constructor","title":"constructor","text":"<p>\u2022 new ModelManager(<code>config</code>)</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters","title":"Parameters","text":"Name Type <code>config</code> <code>ModelManagerConfig</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#accessors","title":"Accessors","text":""},{"location":"reference/glaze/classes/devtools.ModelManager/#definitions","title":"definitions","text":"<p>\u2022 <code>get</code> definitions(): <code>string</code>[]</p> <p>Stream IDs of definitions included in the model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns","title":"Returns","text":"<p><code>string</code>[]</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#model","title":"model","text":"<p>\u2022 <code>get</code> model(): <code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;</p> <p><code>Managed model</code> used internally.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_1","title":"Returns","text":"<p><code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#schemas","title":"schemas","text":"<p>\u2022 <code>get</code> schemas(): <code>string</code>[]</p> <p>Stream IDs of schemas included in the model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_2","title":"Returns","text":"<p><code>string</code>[]</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#tiles","title":"tiles","text":"<p>\u2022 <code>get</code> tiles(): <code>string</code>[]</p> <p>Stream IDs of tiles included in the model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_3","title":"Returns","text":"<p><code>string</code>[]</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#methods","title":"Methods","text":""},{"location":"reference/glaze/classes/devtools.ModelManager/#addjsonmodel","title":"addJSONModel","text":"<p>\u25b8 addJSONModel(<code>encoded</code>): <code>void</code></p> <p>Add a <code>JSON-encoded managed model</code> to the internal model used by the instance.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_1","title":"Parameters","text":"Name Type <code>encoded</code> <code>EncodedManagedModel</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_4","title":"Returns","text":"<p><code>void</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#addmodel","title":"addModel","text":"<p>\u25b8 addModel(<code>model</code>): <code>void</code></p> <p>Add a <code>managed model</code> to the internal model used by the instance.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_2","title":"Parameters","text":"Name Type <code>model</code> <code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_5","title":"Returns","text":"<p><code>void</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#create","title":"create","text":"<p>\u25b8 create&lt;<code>T</code>, <code>Content</code>&gt;(<code>type</code>, <code>alias</code>, <code>content</code>, <code>meta?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Create a new stream of the given type and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#type-parameters","title":"Type parameters","text":"Name Type <code>T</code> extends keyof <code>CreateContentType</code> <code>Content</code> <code>CreateContentType</code>[<code>T</code>]"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_3","title":"Parameters","text":"Name Type <code>type</code> <code>T</code> <code>alias</code> <code>string</code> <code>content</code> <code>Content</code> <code>meta?</code> <code>Partial</code>&lt;<code>StreamMetadata</code>&gt;"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#createdefinition","title":"createDefinition","text":"<p>\u25b8 createDefinition(<code>alias</code>, <code>definition</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Create a new definition stream and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_4","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code> <code>definition</code> <code>Definition</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_7","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#createschema","title":"createSchema","text":"<p>\u25b8 createSchema(<code>alias</code>, <code>schema</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Create a new schema stream and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_5","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code> <code>schema</code> <code>Schema</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_8","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#createtile","title":"createTile","text":"<p>\u25b8 createTile&lt;<code>T</code>&gt;(<code>alias</code>, <code>contents</code>, <code>meta?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Create a new tile stream and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#type-parameters_1","title":"Type parameters","text":"Name Type <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_6","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code> <code>contents</code> <code>T</code> <code>meta</code> <code>Partial</code>&lt;<code>StreamMetadata</code>&gt;"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_9","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#deploy","title":"deploy","text":"<p>\u25b8 deploy(): <code>Promise</code>&lt;<code>ModelData</code>&lt;<code>string</code>&gt;&gt;</p> <p>Deploy the managed model to the Ceramic node and return the <code>types.ModelAliases</code> to be used by the <code>DataModel</code> runtime.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_10","title":"Returns","text":"<p><code>Promise</code>&lt;<code>ModelData</code>&lt;<code>string</code>&gt;&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#getdefinition","title":"getDefinition","text":"<p>\u25b8 getDefinition(<code>id</code>): <code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p> <p>Get the definition <code>managed entry</code> for a given ID.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_7","title":"Parameters","text":"Name Type <code>id</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_11","title":"Returns","text":"<p><code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#getdefinitionid","title":"getDefinitionID","text":"<p>\u25b8 getDefinitionID(<code>alias</code>): <code>null</code> | <code>string</code></p> <p>Get the ID of given definition alias, if present in the model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_8","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_12","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschema","title":"getSchema","text":"<p>\u25b8 getSchema(<code>id</code>): <code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p> <p>Get the <code>managed schema</code> for a given ID.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_9","title":"Parameters","text":"Name Type <code>id</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_13","title":"Returns","text":"<p><code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschemabyalias","title":"getSchemaByAlias","text":"<p>\u25b8 getSchemaByAlias(<code>alias</code>): <code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p> <p>Get the <code>managed schema</code> for a given alias.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_10","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_14","title":"Returns","text":"<p><code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschemaid","title":"getSchemaID","text":"<p>\u25b8 getSchemaID(<code>alias</code>): <code>null</code> | <code>string</code></p> <p>Get the ID of given schema alias, if present in the model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_11","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_15","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschemaurl","title":"getSchemaURL","text":"<p>\u25b8 getSchemaURL(<code>id</code>): <code>null</code> | <code>string</code></p> <p>Get the schema commit URL for a given ID.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_12","title":"Parameters","text":"Name Type <code>id</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_16","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#gettile","title":"getTile","text":"<p>\u25b8 getTile(<code>id</code>): <code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p> <p>Get the tile <code>managed entry</code> for a given ID.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_13","title":"Parameters","text":"Name Type <code>id</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_17","title":"Returns","text":"<p><code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#gettileid","title":"getTileID","text":"<p>\u25b8 getTileID(<code>alias</code>): <code>null</code> | <code>string</code></p> <p>Get the ID of given tile alias, if present in the model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_14","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_18","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#hasdefinitionalias","title":"hasDefinitionAlias","text":"<p>\u25b8 hasDefinitionAlias(<code>alias</code>): <code>boolean</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_15","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_19","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#hasschemaalias","title":"hasSchemaAlias","text":"<p>\u25b8 hasSchemaAlias(<code>alias</code>): <code>boolean</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_16","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_20","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#hastilealias","title":"hasTileAlias","text":"<p>\u25b8 hasTileAlias(<code>alias</code>): <code>boolean</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_17","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_21","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadcommits","title":"loadCommits","text":"<p>\u25b8 loadCommits(<code>id</code>): <code>Promise</code>&lt;<code>DagJWSResult</code>[]&gt;</p> <p>Load a stream commits.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_18","title":"Parameters","text":"Name Type <code>id</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_22","title":"Returns","text":"<p><code>Promise</code>&lt;<code>DagJWSResult</code>[]&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadschema","title":"loadSchema","text":"<p>\u25b8 loadSchema(<code>id</code>, <code>alias?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load a schema stream and other schemas it depends on.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_19","title":"Parameters","text":"Name Type <code>id</code> <code>string</code> | <code>StreamRef</code> <code>alias?</code> <code>string</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_23","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadschemadependencies","title":"loadSchemaDependencies","text":"<p>\u25b8 loadSchemaDependencies(<code>schema</code>): <code>Promise</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>string</code>[]&gt;&gt;</p> <p>Extract and load a schema's dependencies.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_20","title":"Parameters","text":"Name Type <code>schema</code> <code>Schema</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_24","title":"Returns","text":"<p><code>Promise</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>string</code>[]&gt;&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadstream","title":"loadStream","text":"<p>\u25b8 loadStream(<code>streamID</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt;</p> <p>Load a stream, ensuring it can be used in a data model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_21","title":"Parameters","text":"Name Type <code>streamID</code> <code>string</code> | <code>StreamRef</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_25","title":"Returns","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#tojson","title":"toJSON","text":"<p>\u25b8 toJSON(): <code>EncodedManagedModel</code></p> <p>Returns the <code>JSON-encoded managed model</code> so it can be easily stored, shared and reused with the <code>fromJSON</code> static method.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_26","title":"Returns","text":"<p><code>EncodedManagedModel</code></p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#usedeployed","title":"useDeployed","text":"<p>\u25b8 useDeployed&lt;<code>T</code>, <code>ID</code>&gt;(<code>type</code>, <code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load an already deployed stream of the given type from the Ceramic node and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#type-parameters_2","title":"Type parameters","text":"Name Type <code>T</code> extends keyof <code>UseDeployedIDType</code> <code>ID</code> <code>UseDeployedIDType</code>[<code>T</code>]"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_22","title":"Parameters","text":"Name Type <code>type</code> <code>T</code> <code>alias</code> <code>string</code> <code>id</code> <code>ID</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_27","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#usedeployeddefinition","title":"useDeployedDefinition","text":"<p>\u25b8 useDeployedDefinition(<code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load an already deployed definition stream from the Ceramic node and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_23","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code> <code>id</code> <code>string</code> | <code>StreamID</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_28","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#usedeployedschema","title":"useDeployedSchema","text":"<p>\u25b8 useDeployedSchema(<code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load an already deployed schema stream from the Ceramic node and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_24","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code> <code>id</code> <code>string</code> | <code>StreamRef</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_29","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#usedeployedtile","title":"useDeployedTile","text":"<p>\u25b8 useDeployedTile(<code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load an already deployed tile stream from the Ceramic node and add it to the managed model.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_25","title":"Parameters","text":"Name Type <code>alias</code> <code>string</code> <code>id</code> <code>string</code> | <code>StreamID</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_30","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#fromjson","title":"fromJSON","text":"<p>\u25b8 <code>Static</code> fromJSON(<code>params</code>): <code>ModelManager</code></p> <p>Create a ModelManager instance from a <code>JSON-encoded managed model</code>.</p>"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_26","title":"Parameters","text":"Name Type <code>params</code> <code>FromJSONParams</code>"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_31","title":"Returns","text":"<p><code>ModelManager</code></p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/","title":"Class: DIDDataStore&lt;ModelTypes, Alias&gt;","text":"<p>did-datastore.DIDDataStore</p> <p>The DIDDataStore class provides simple APIs to interact with data records associated to a DID.</p> <p>It is exported by the <code>did-datastore</code> module.</p> <pre><code>import { DIDDataStore } from '@glazed/did-datastore'\n</code></pre>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>ModelTypeAliases</code> <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#constructors","title":"Constructors","text":""},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#constructor","title":"constructor","text":"<p>\u2022 new DIDDataStore&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>DIDDataStoreParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#accessors","title":"Accessors","text":""},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#authenticated","title":"authenticated","text":"<p>\u2022 <code>get</code> authenticated(): <code>boolean</code></p> <p>Returns whether a DID instance is attached to the Ceramic client instance used internally or not.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#ceramic","title":"ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicApi</code></p> <p>Ceramic client instance used internally.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_1","title":"Returns","text":"<p><code>CeramicApi</code></p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#id","title":"id","text":"<p>\u2022 <code>get</code> id(): <code>string</code></p> <p>Returns the DID string currently authenticated on the Ceramic instance used internally, or throws an error if not authenticated.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_2","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#loader","title":"loader","text":"<p>\u2022 <code>get</code> loader(): <code>TileLoader</code></p> <p><code>TileLoader</code> instance used internally.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_3","title":"Returns","text":"<p><code>TileLoader</code></p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#model","title":"model","text":"<p>\u2022 <code>get</code> model(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p> <p><code>DataModel</code> runtime instance used internally.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_4","title":"Returns","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#methods","title":"Methods","text":""},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#get","title":"get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Get the record contents.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_1","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>did?</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_5","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getdefinition","title":"getDefinition","text":"<p>\u25b8 getDefinition(<code>id</code>): <code>Promise</code>&lt;<code>DefinitionWithID</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;&gt;</p> <p>Load and validate a definition by its ID.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_2","title":"Parameters","text":"Name Type <code>id</code> <code>string</code> | <code>StreamID</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>DefinitionWithID</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getdefinitionid","title":"getDefinitionID","text":"<p>\u25b8 getDefinitionID(<code>aliasOrID</code>): <code>string</code></p> <p>Get the definition ID for the given alias.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_3","title":"Parameters","text":"Name Type <code>aliasOrID</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_7","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getindex","title":"getIndex","text":"<p>\u25b8 getIndex(<code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>IdentityIndex</code>&gt;</p> <p>Load the full index contents.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_4","title":"Parameters","text":"Name Type <code>did</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_8","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>IdentityIndex</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getmultiple","title":"getMultiple","text":"<p>\u25b8 getMultiple&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>dids</code>): <code>Promise</code>&lt;(<code>null</code> | <code>ContentType</code>)[]&gt;</p> <p>Get the record contents for multiple DIDs at once.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_3","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_5","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>dids</code> <code>string</code>[]"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_9","title":"Returns","text":"<p><code>Promise</code>&lt;(<code>null</code> | <code>ContentType</code>)[]&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getrecord","title":"getRecord","text":"<p>\u25b8 getRecord&lt;<code>ContentType</code>&gt;(<code>definitionID</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load a record contents for the given definition ID.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_4","title":"Type parameters","text":"Name Type <code>ContentType</code> <code>unknown</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_6","title":"Parameters","text":"Name Type <code>definitionID</code> <code>string</code> <code>did?</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_10","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getrecorddocument","title":"getRecordDocument","text":"<p>\u25b8 getRecordDocument(<code>definitionID</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>TileDoc</code>&gt;</p> <p>Load a record TileDocument for the given definition ID.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_7","title":"Parameters","text":"Name Type <code>definitionID</code> <code>string</code> <code>did?</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_11","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>TileDoc</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getrecordid","title":"getRecordID","text":"<p>\u25b8 getRecordID(<code>definitionID</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>string</code>&gt;</p> <p>Load a record ID in the index for the given definition ID.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_8","title":"Parameters","text":"Name Type <code>definitionID</code> <code>string</code> <code>did?</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_12","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>string</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#has","title":"has","text":"<p>\u25b8 has(<code>key</code>, <code>did?</code>): <code>Promise</code>&lt;<code>boolean</code>&gt;</p> <p>Returns whether a record exists in the index or not.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_9","title":"Parameters","text":"Name Type <code>key</code> <code>Alias</code> <code>did?</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_13","title":"Returns","text":"<p><code>Promise</code>&lt;<code>boolean</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#iterator","title":"iterator","text":"<p>\u25b8 iterator(<code>did?</code>): <code>AsyncIterableIterator</code>&lt;<code>Entry</code>&gt;</p> <p>Asynchronously iterate over the entries of the index, loading one record at a time.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_10","title":"Parameters","text":"Name Type <code>did?</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_14","title":"Returns","text":"<p><code>AsyncIterableIterator</code>&lt;<code>Entry</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#merge","title":"merge","text":"<p>\u25b8 merge&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>, <code>options?</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Perform a shallow (one level) merge of the record contents.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_5","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_11","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>content</code> <code>ContentType</code> <code>options</code> <code>CreateOptions</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_15","title":"Returns","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#remove","title":"remove","text":"<p>\u25b8 remove(<code>key</code>, <code>controller?</code>): <code>Promise</code>&lt;<code>void</code>&gt;</p> <p>Remove a record from the index.</p> <p>Notice: this does not change the contents of the record itself, only the index.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_12","title":"Parameters","text":"Name Type <code>key</code> <code>Alias</code> <code>controller</code> <code>string</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_16","title":"Returns","text":"<p><code>Promise</code>&lt;<code>void</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#set","title":"set","text":"<p>\u25b8 set&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>, <code>options?</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Set the record contents.</p> <p>Warning: calling this method replaces any existing contents in the record, use <code>merge</code> if you want to only change some fields.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_6","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_13","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>content</code> <code>ContentType</code> <code>options</code> <code>CreateOptions</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_17","title":"Returns","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#setall","title":"setAll","text":"<p>\u25b8 setAll&lt;<code>Contents</code>&gt;(<code>contents</code>, <code>options?</code>): <code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p> <p>Set the contents of multiple records at once. The index only gets updated after all wanted records have been written.</p> <p>Warning: calling this method replaces any existing contents in the records.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_7","title":"Type parameters","text":"Name Type <code>Contents</code> extends <code>DefinitionsContentTypes</code>&lt;<code>ModelTypes</code>, <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_14","title":"Parameters","text":"Name Type <code>contents</code> <code>Contents</code> <code>options</code> <code>CreateOptions</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_18","title":"Returns","text":"<p><code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#setdefaults","title":"setDefaults","text":"<p>\u25b8 setDefaults&lt;<code>Contents</code>&gt;(<code>contents</code>, <code>options?</code>): <code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p> <p>Set the contents of multiple records if they are not already set in the index.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_8","title":"Type parameters","text":"Name Type <code>Contents</code> extends <code>DefinitionsContentTypes</code>&lt;<code>ModelTypes</code>, <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_15","title":"Parameters","text":"Name Type <code>contents</code> <code>Contents</code> <code>options</code> <code>CreateOptions</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_19","title":"Returns","text":"<p><code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#setrecord","title":"setRecord","text":"<p>\u25b8 setRecord(<code>definitionID</code>, <code>content</code>, <code>options?</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Set the contents of a record for the given definition ID.</p>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_16","title":"Parameters","text":"Name Type <code>definitionID</code> <code>string</code> <code>content</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; <code>options</code> <code>CreateOptions</code>"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_20","title":"Returns","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/","title":"Class: TileLoader","text":"<p>tile-loader.TileLoader</p> <p>A TileLoader extends DataLoader to provide batching and caching functionalities for loading TileDocument streams.</p> <p>It is exported by the <code>tile-loader</code> module.</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n</code></pre>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#hierarchy","title":"Hierarchy","text":"<ul> <li><code>DataLoader</code>&lt;<code>TileKey</code>, <code>TileDocument</code>&gt;</li> </ul> <p>\u21b3 <code>TileLoader</code></p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#constructors","title":"Constructors","text":""},{"location":"reference/glaze/classes/tile_loader.TileLoader/#constructor","title":"constructor","text":"<p>\u2022 new TileLoader(<code>params</code>)</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>TileLoaderParams</code>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#overrides","title":"Overrides","text":"<p>DataLoader&lt;TileKey, TileDocument\\&gt;.constructor</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#methods","title":"Methods","text":""},{"location":"reference/glaze/classes/tile_loader.TileLoader/#cache","title":"cache","text":"<p>\u25b8 cache(<code>stream</code>): <code>boolean</code></p> <p>Add a TileDocument to the local cache, if enabled.</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_1","title":"Parameters","text":"Name Type <code>stream</code> <code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#create","title":"create","text":"<p>\u25b8 create&lt;<code>T</code>&gt;(<code>content</code>, <code>metadata?</code>, <code>options?</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p> <p>Create a new TileDocument and add it to the cache, if enabled.</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#type-parameters","title":"Type parameters","text":"Name Type <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_2","title":"Parameters","text":"Name Type <code>content</code> <code>T</code> <code>metadata?</code> <code>TileMetadataArgs</code> <code>options?</code> <code>CreateOpts</code>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns_1","title":"Returns","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#deterministic","title":"deterministic","text":"<p>\u25b8 deterministic&lt;<code>T</code>&gt;(<code>metadata</code>, <code>options?</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>undefined</code> | <code>null</code> | <code>T</code>&gt;&gt;</p> <p>Create or load a deterministic TileDocument based on its metadata.</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#type-parameters_1","title":"Type parameters","text":"Name Type <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_3","title":"Parameters","text":"Name Type <code>metadata</code> <code>TileMetadataArgs</code> <code>options?</code> <code>CreateOpts</code>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns_2","title":"Returns","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>undefined</code> | <code>null</code> | <code>T</code>&gt;&gt;</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#load","title":"load","text":"<p>\u25b8 load&lt;<code>T</code>&gt;(<code>key</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p> <p>Load a TileDocument from the cache (if enabled) or remotely.</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#type-parameters_2","title":"Type parameters","text":"Name Type <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_4","title":"Parameters","text":"Name Type <code>key</code> <code>TileKey</code>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns_3","title":"Returns","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#overrides_1","title":"Overrides","text":"<p>DataLoader.load</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#update","title":"update","text":"<p>\u25b8 update&lt;<code>T</code>&gt;(<code>streamID</code>, <code>content?</code>, <code>metadata?</code>, <code>options?</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>undefined</code> | <code>null</code> | <code>T</code>&gt;&gt;</p> <p>Update a TileDocument after loading the stream remotely, bypassing the cache.</p>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#type-parameters_3","title":"Type parameters","text":"Name Type <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_5","title":"Parameters","text":"Name Type <code>streamID</code> <code>string</code> | <code>StreamID</code> <code>content?</code> <code>T</code> <code>metadata?</code> <code>TileMetadataArgs</code> <code>options?</code> <code>UpdateOpts</code>"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns_4","title":"Returns","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>undefined</code> | <code>null</code> | <code>T</code>&gt;&gt;</p>"},{"location":"reference/glaze/modules/datamodel/","title":"Module: datamodel","text":"<p>Aliases for Ceramic stream references.</p>"},{"location":"reference/glaze/modules/datamodel/#purpose","title":"Purpose","text":"<p>The <code>datamodel</code> module exports a <code>DataModel</code> class for runtime interactions with a published data model, using aliases for Ceramic stream IDs.</p>"},{"location":"reference/glaze/modules/datamodel/#installation","title":"Installation","text":"<pre><code>npm install @glazed/datamodel\n</code></pre>"},{"location":"reference/glaze/modules/datamodel/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/glaze/modules/datamodel/#get-the-id-of-a-known-alias","title":"Get the ID of a known alias","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\n\nconst ceramic = new CeramicClient()\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {\nmyDefinition: 'k2...ef',\n},\ntiles: {},\n}\nconst model = new DataModel({ ceramic, aliases })\n\nfunction getMySchemaURL() {\nreturn model.getSchemaURL('MySchema') // 'ceramic://k2...ab'\n}\n\nfunction getMyDefinitionID() {\nreturn model.getDefinitionID('myDefinition') // 'k2...ef'\n}\n</code></pre>"},{"location":"reference/glaze/modules/datamodel/#load-a-tile-by-alias","title":"Load a tile by alias","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\n\nconst ceramic = new CeramicClient()\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {},\ntiles: {\nmyTile: 'k2...cd',\n},\n}\nconst model = new DataModel({ ceramic, aliases })\n\nasync function loadMyTile() {\nreturn await model.loadTile('myTile')\n}\n</code></pre>"},{"location":"reference/glaze/modules/datamodel/#create-a-tile-with-a-schema-alias","title":"Create a tile with a schema alias","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\n\nconst ceramic = new CeramicClient()\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {},\ntiles: {},\n}\nconst model = new DataModel({ ceramic, aliases })\n\nasync function createTileWithMySchema(content) {\nreturn await model.createTile('MySchema', content)\n}\n</code></pre>"},{"location":"reference/glaze/modules/datamodel/#classes","title":"Classes","text":"<ul> <li>DataModel</li> </ul>"},{"location":"reference/glaze/modules/datamodel/#type-aliases","title":"Type aliases","text":""},{"location":"reference/glaze/modules/datamodel/#createoptions","title":"CreateOptions","text":"<p>\u01ac CreateOptions: <code>CreateOpts</code> &amp; { <code>controller?</code>: <code>string</code>  }</p>"},{"location":"reference/glaze/modules/datamodel/#datamodelparams","title":"DataModelParams","text":"<p>\u01ac DataModelParams&lt;<code>Aliases</code>&gt;: <code>Object</code></p>"},{"location":"reference/glaze/modules/datamodel/#type-parameters","title":"Type parameters","text":"Name <code>Aliases</code>"},{"location":"reference/glaze/modules/datamodel/#type-declaration","title":"Type declaration","text":"Name Type Description <code>aliases</code> <code>Aliases</code> The runtime <code>model aliases</code> to use <code>cache?</code> <code>TileCache</code> | <code>boolean</code> <code>TileLoader</code> cache parameter, only used if <code>loader</code> is not provided <code>ceramic?</code> <code>CeramicApi</code> A Ceramic client instance, only used if <code>loader</code> is not provided <code>loader?</code> <code>TileLoader</code> A <code>TileLoader</code> instance to use, must be provided if <code>ceramic</code> is not provided"},{"location":"reference/glaze/modules/devtools/","title":"Module: devtools","text":"<p>Development tools library.</p>"},{"location":"reference/glaze/modules/devtools/#purpose","title":"Purpose","text":"<p>The <code>devtools</code> library provides APIs to help support common use-cases when building applications on top of Ceramic, notably as a complement to the runtime Glaze libraries. It is meant to be used by developers in scripts or other tools such as the CLI, not as a runtime library.</p> <p>The <code>ModelManager</code> class notably allows developers to create, update and deploy data models to be used with the <code>DataModel</code> runtime.</p>"},{"location":"reference/glaze/modules/devtools/#installation","title":"Installation","text":"<pre><code>npm install --dev @glazed/devtools\n</code></pre>"},{"location":"reference/glaze/modules/devtools/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/glaze/modules/devtools/#add-an-existing-schema-to-a-model","title":"Add an existing schema to a model","text":"<p>An existing schema can be added using the <code>useDeployedSchema</code> method, as shown below.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager({ ceramic })\n\n// Set the alias (human-readable name) and stream reference (stream or commit ID or URL) of the\n// schema to add to the model. The schema must be already present on the Ceramic node.\nawait manager.useDeployedSchema('MySchema', 'ceramic://k2...ab')\n</code></pre> <p>The <code>useDeployedDefinition</code> and <code>useDeployedTile</code> methods can be used similarly to add definitions and tiles to the model.</p>"},{"location":"reference/glaze/modules/devtools/#create-and-add-a-schema-to-a-model","title":"Create and add a schema to a model","text":"<p>Using the <code>createSchema</code> method allows to create the schema on the Ceramic node and add it to the model. Note that using this method creates a new schema every time it is called, therefore generating different stream IDs.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager({ ceramic })\n\n// Set the alias (human-readable name) and JSON schema contents\nawait manager.createSchema('MySchema', {\n$schema: 'http://json-schema.org/draft-07/schema#',\ntitle: 'MySchema',\ntype: 'object',\nproperties: {\n...\n},\n})\n</code></pre> <p>The <code>createDefinition</code> and <code>createTile</code> methods can be used similarly to add definitions and tiles to the model.</p>"},{"location":"reference/glaze/modules/devtools/#export-a-model-to-json","title":"Export a model to JSON","text":"<p>A managed model can be serialized to JSON, making it portable and reusable, with the <code>toJSON</code> method.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager({ ceramic })\n\nawait manager.useDeployedSchema('MySchema', 'ceramic://k2...ab')\nconst encodedModel = await manager.toJSON()\n</code></pre>"},{"location":"reference/glaze/modules/devtools/#import-a-model-from-json","title":"Import a model from JSON","text":"<p>A managed model serialized using the <code>toJSON</code> method can be deserialized with the <code>fromJSON</code> static method.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager({ ceramic })\n\nawait manager.useDeployedSchema('MySchema', 'ceramic://k2...ab')\nconst encodedModel = await manager.toJSON()\n\n// The `clonedManager` instance will contain the same model as the `manager` instance\nconst clonedManager = ModelManager.fromJSON({ ceramic, model: encodedModel })\n</code></pre>"},{"location":"reference/glaze/modules/devtools/#deploy-a-model-to-ceramic","title":"Deploy a model to Ceramic","text":"<p>In order to use a model at runtime in an application, it is important to ensure all the streams used by the model are present in the Ceramic network. This can be achieved by calling the <code>deploy</code> method, which returns the aliases of the model that can be used at runtime by a <code>DataModel</code> instance.</p> <pre><code>import { readFile, writeFile } from 'node:fs/promises'\nimport { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\n// The encoded model could be imported from the file system for example\nconst bytes = await readFile(new URL('encoded-model.json', import.meta.url))\nconst encodedModel = JSON.parse(bytes.toString())\n\nconst ceramic = new CeramicClient()\nconst manager = ModelManager.fromJSON({ ceramic, model: encodedModel })\n\n// The deployed model aliases could then be exported to be used at runtime\nconst aliases = await manager.deploy()\nawait writeFile(new URL('model-aliases.json', import.meta.url), JSON.stringify(aliases))\n</code></pre>"},{"location":"reference/glaze/modules/devtools/#use-existing-models","title":"Use existing models","text":"<p>A model can be created by combining other models. For example, using the models for the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications provided by the following packages:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\nimport { model as basicProfileModel } from '@datamodels/identity-profile-basic'\nimport { model as cryptoAccountsModel } from '@datamodels/identity-accounts-crypto'\nimport { model as webAccountsModel } from '@datamodels/identity-accounts-web'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager({ ceramic })\n\n// Add the imported models to the manager\nmanager.addJSONModel(basicProfileModel)\nmanager.addJSONModel(cryptoAccountsModel)\nmanager.addJSONModel(webAccountsModel)\n\n// Once deployed, the streams are available on the Ceramic node\nawait manager.deploy()\n</code></pre>"},{"location":"reference/glaze/modules/devtools/#classes","title":"Classes","text":"<ul> <li>ModelManager</li> </ul>"},{"location":"reference/glaze/modules/devtools/#type-aliases","title":"Type aliases","text":""},{"location":"reference/glaze/modules/devtools/#fromjsonparams","title":"FromJSONParams","text":"<p>\u01ac FromJSONParams: <code>Object</code></p>"},{"location":"reference/glaze/modules/devtools/#type-declaration","title":"Type declaration","text":"Name Type Description <code>ceramic</code> <code>CeramicApi</code> Ceramic client instance <code>model</code> <code>EncodedManagedModel</code> <code>JSON-encoded managed model</code> to use"},{"location":"reference/glaze/modules/devtools/#modelmanagerconfig","title":"ModelManagerConfig","text":"<p>\u01ac ModelManagerConfig: <code>Object</code></p>"},{"location":"reference/glaze/modules/devtools/#type-declaration_1","title":"Type declaration","text":"Name Type Description <code>ceramic</code> <code>CeramicApi</code> Ceramic client instance <code>model?</code> <code>ManagedModel</code> Optional <code>managed model</code> to use"},{"location":"reference/glaze/modules/devtools/#functions","title":"Functions","text":""},{"location":"reference/glaze/modules/devtools/#deployencodedmodel","title":"deployEncodedModel","text":"<p>\u25b8 deployEncodedModel(<code>ceramic</code>, <code>model</code>): <code>Promise</code>&lt;<code>ModelAliases</code>&gt;</p> <p>Deploy a <code>JSON-encoded managed model</code> to the given Ceramic node.</p>"},{"location":"reference/glaze/modules/devtools/#parameters","title":"Parameters","text":"Name Type <code>ceramic</code> <code>CeramicApi</code> <code>model</code> <code>EncodedManagedModel</code>"},{"location":"reference/glaze/modules/devtools/#returns","title":"Returns","text":"<p><code>Promise</code>&lt;<code>ModelAliases</code>&gt;</p>"},{"location":"reference/glaze/modules/devtools/#deploymodel","title":"deployModel","text":"<p>\u25b8 deployModel(<code>ceramic</code>, <code>model</code>, <code>createOpts?</code>, <code>commitOpts?</code>): <code>Promise</code>&lt;<code>ModelAliases</code>&gt;</p> <p>Deploy a managed model to the given Ceramic node.</p>"},{"location":"reference/glaze/modules/devtools/#parameters_1","title":"Parameters","text":"Name Type <code>ceramic</code> <code>CeramicApi</code> <code>model</code> <code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt; <code>createOpts?</code> <code>CreateOpts</code> <code>commitOpts?</code> <code>UpdateOpts</code>"},{"location":"reference/glaze/modules/devtools/#returns_1","title":"Returns","text":"<p><code>Promise</code>&lt;<code>ModelAliases</code>&gt;</p>"},{"location":"reference/glaze/modules/devtools/#issecureschema","title":"isSecureSchema","text":"<p>\u25b8 isSecureSchema&lt;<code>T</code>&gt;(<code>schema</code>): <code>boolean</code></p>"},{"location":"reference/glaze/modules/devtools/#type-parameters","title":"Type parameters","text":"Name Type <code>T</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/glaze/modules/devtools/#parameters_2","title":"Parameters","text":"Name Type <code>schema</code> <code>UncheckedJSONSchemaType</code>&lt;<code>T</code>, <code>false</code>&gt;"},{"location":"reference/glaze/modules/devtools/#returns_2","title":"Returns","text":"<p><code>boolean</code></p>"},{"location":"reference/glaze/modules/did_datastore/","title":"Module: did-datastore","text":"<p>Associate data records to a DID.</p>"},{"location":"reference/glaze/modules/did_datastore/#purpose","title":"Purpose","text":"<p>The <code>did-datastore</code> module exports a <code>DIDDataStore</code> class allowing to associate Ceramic tiles to a DID in a deterministic way by implementing the Identity Index (IDX) protocol described in the CIP-11 specification.</p>"},{"location":"reference/glaze/modules/did_datastore/#installation","title":"Installation","text":"<pre><code>npm install @glazed/did-datastore\n</code></pre>"},{"location":"reference/glaze/modules/did_datastore/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/glaze/modules/did_datastore/#read-the-contents-of-a-record","title":"Read the contents of a record","text":"<p>The <code>DIDDataStore</code> instance uses a <code>DataModel</code> instance to support aliases for definitions.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {\nmyDefinition: 'k2...ef',\n},\ntiles: {},\n}\nconst model = new DataModel({ ceramic, aliases })\nconst dataStore = new DIDDataStore({ ceramic, model })\n\nasync function getMyDefinitionRecord(did) {\nreturn await dataStore.get('myDefinition', did)\n}\n</code></pre>"},{"location":"reference/glaze/modules/did_datastore/#use-a-deployed-model-aliases-object","title":"Use a deployed model aliases object","text":"<p>Instead of using a <code>DataModel</code> instance, it is possible to provide a deployed model aliases object directly.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {\nmyDefinition: 'k2...ef',\n},\ntiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, model: aliases })\n\nasync function getMyDefinitionRecord(did) {\nreturn await dataStore.get('myDefinition', did)\n}\n</code></pre>"},{"location":"reference/glaze/modules/did_datastore/#use-a-tileloader-instance","title":"Use a TileLoader instance","text":"<p>The <code>DIDDataStore</code> instance uses a <code>TileLoader</code> instance internally to batch queries. It is possible to provide an instance to use instead, for example to share it with other functions.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic })\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {\nmyDefinition: 'k2...ef',\n},\ntiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, loader, model: aliases })\n\nasync function getMyDefinitionRecord(did) {\nreturn await dataStore.get('myDefinition', did)\n}\n</code></pre>"},{"location":"reference/glaze/modules/did_datastore/#set-the-contents-of-a-record","title":"Set the contents of a record","text":"<p>It is possible to set the contents of a record when the Ceramic instance is authenticated using the <code>set</code> method.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {\nmyDefinition: 'k2...ef',\n},\ntiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, model: aliases })\n\nasync function setMyDefinitionRecord(content) {\n// This will throw an error if the Ceramic instance is not authenticated\nreturn await dataStore.set('myDefinition', content)\n}\n</code></pre>"},{"location":"reference/glaze/modules/did_datastore/#merge-the-contents-of-a-record","title":"Merge the contents of a record","text":"<p>Rather than completely replacing the contents of a record using the <code>set</code> method, the <code>merge</code> method can be used to only replace the specified fields.</p> <p>The <code>merge</code> method only applies a shallow (one level) replacement, if you need a deep merge or more complex logic, you should implement it directly using the <code>get</code> and <code>set</code> methods.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://k2...ab',\n},\ndefinitions: {\nmyDefinition: 'k2...ef',\n},\ntiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, model: aliases })\n\nasync function setMyDefinitionRecord(content) {\n// This will only replace the fields present in the input `content` object, other fields\n// already present in the record will not be affected\nreturn await dataStore.merge('myDefinition', content)\n}\n</code></pre>"},{"location":"reference/glaze/modules/did_datastore/#classes","title":"Classes","text":"<ul> <li>DIDDataStore</li> </ul>"},{"location":"reference/glaze/modules/did_datastore/#type-aliases","title":"Type aliases","text":""},{"location":"reference/glaze/modules/did_datastore/#createoptions","title":"CreateOptions","text":"<p>\u01ac CreateOptions: <code>Object</code></p>"},{"location":"reference/glaze/modules/did_datastore/#type-declaration","title":"Type declaration","text":"Name Type Description <code>controller?</code> <code>string</code> Optional controller for the record <code>pin?</code> <code>boolean</code> Pin the created record stream (default)"},{"location":"reference/glaze/modules/did_datastore/#diddatastoreparams","title":"DIDDataStoreParams","text":"<p>\u01ac DIDDataStoreParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>"},{"location":"reference/glaze/modules/did_datastore/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>ModelTypeAliases</code>"},{"location":"reference/glaze/modules/did_datastore/#type-declaration_1","title":"Type declaration","text":"Name Type Description <code>cache?</code> <code>TileCache</code> | <code>boolean</code> <code>TileLoader</code> cache parameter, only used if <code>loader</code> is not provided <code>ceramic</code> <code>CeramicApi</code> A Ceramic client instance <code>id?</code> <code>string</code> Fallback DID to use when not explicitly set in method calls <code>loader?</code> <code>TileLoader</code> An optional <code>TileLoader</code> instance to use <code>model</code> <code>DataModel</code>&lt;<code>ModelTypes</code>&gt; | <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt; A <code>DataModel</code> instance or <code>runtime model aliases</code> to use"},{"location":"reference/glaze/modules/did_datastore/#definitioncontenttype","title":"DefinitionContentType","text":"<p>\u01ac DefinitionContentType&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;: <code>ModelTypes</code>[<code>\"schemas\"</code>][<code>ModelTypes</code>[<code>\"definitions\"</code>][<code>Alias</code>]]</p>"},{"location":"reference/glaze/modules/did_datastore/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/glaze/modules/did_datastore/#definitionwithid","title":"DefinitionWithID","text":"<p>\u01ac DefinitionWithID&lt;<code>Config</code>&gt;: <code>Definition</code>&lt;<code>Config</code>&gt; &amp; { <code>id</code>: <code>StreamID</code>  }</p>"},{"location":"reference/glaze/modules/did_datastore/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Config</code> extends <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;"},{"location":"reference/glaze/modules/did_datastore/#definitionscontenttypes","title":"DefinitionsContentTypes","text":"<p>\u01ac DefinitionsContentTypes&lt;<code>ModelTypes</code>, <code>Fallback</code>&gt;: <code>Object</code></p>"},{"location":"reference/glaze/modules/did_datastore/#type-parameters_3","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> <code>Fallback</code> <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;"},{"location":"reference/glaze/modules/did_datastore/#index-signature","title":"Index signature","text":"<p>\u25aa [Key: <code>string</code>]: typeof <code>Key</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] ? <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, typeof <code>Key</code>&gt; : <code>Fallback</code></p>"},{"location":"reference/glaze/modules/did_datastore/#entry","title":"Entry","text":"<p>\u01ac Entry: <code>Object</code></p>"},{"location":"reference/glaze/modules/did_datastore/#type-declaration_2","title":"Type declaration","text":"Name Type Description <code>id</code> <code>string</code> Record ID (Ceramic StreamID) <code>key</code> <code>string</code> Key (definition ID) identifying the record ID in the index <code>record</code> <code>unknown</code> Record contents"},{"location":"reference/glaze/modules/tile_loader/","title":"Module: tile-loader","text":"<p>Batching and caching for Ceramic streams.</p>"},{"location":"reference/glaze/modules/tile_loader/#purpose","title":"Purpose","text":"<p>The <code>tile-loader</code> module exports a <code>TileLoader</code> class providing batching and caching for Tile load and creation in order to improve client-side performance.</p>"},{"location":"reference/glaze/modules/tile_loader/#installation","title":"Installation","text":"<pre><code>npm install @glazed/tile-loader\n</code></pre>"},{"location":"reference/glaze/modules/tile_loader/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/glaze/modules/tile_loader/#batch-stream-loads","title":"Batch stream loads","text":"<p>Batching consists in the process of combining multiple concurrent queries to a Ceramic node into a single one.</p> <p>Using a loader instance in the following example, the two streams will be loaded with a single request to the Ceramic node:</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic })\n\nasync function loadStreams() {\nconst [stream1, stream2] = await Promise.all([\nloader.load('k2...ab'),\nloader.load('k2...cd'),\n])\n}\n</code></pre>"},{"location":"reference/glaze/modules/tile_loader/#cache-loaded-streams","title":"Cache loaded streams","text":"<p>Caching consists in keeping track of streams loaded from a Ceramic node.</p> <p>Caching is disabled by default and may not be suited for your use-cases, make sure you carefully consider the trade-offs before enabling it. Streams loaded from the cache may be out of date from the state on the Ceramic network, so applications should be designed accordingly.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic, cache: true })\n\nasync function loadStream() {\n// Load the stream at some point in your app\nconst stream = await loader.load('k2...ab')\n}\n\nasync function alsoLoadStream() {\n// Maybe the same stream needs to be loaded at a different time or in another part of your app\nconst streamAgain = await loader.load('k2...ab')\n}\n</code></pre>"},{"location":"reference/glaze/modules/tile_loader/#use-a-custom-cache","title":"Use a custom cache","text":"<p>When setting the <code>cache</code> option to <code>true</code> in the loader constructor, the cache will live as long as the loader instance. This means any individual stream will only ever get loaded once, and persist in memory until the loader instance is deleted.</p> <p>It is possible to provide a custom cache implementation in the loader constructor to customize this behavior, for example in order to limit memory usage by restricting the number of streams kept in the cache, or discarding loaded streams after a given period of time.</p> <p>A custom cache must implement a subset of the <code>Map</code> interface, defined by the <code>TileCache</code> interface.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\n// The cache must implement a subset of the Map interface\nconst cache = new Map()\nconst loader = new TileLoader({ ceramic, cache })\n\nasync function load(id) {\n// The loader will cache the request as soon as the load() method is called, so the stored\n// value is a Promise of a TileDocument\nreturn await loader.load(id)\n}\n\nfunction getFromCache(id) {\nreturn cache.get(id) // Promise&lt;TileDocument&gt;\n}\n</code></pre>"},{"location":"reference/glaze/modules/tile_loader/#create-and-cache-a-stream","title":"Create and cache a stream","text":"<p>The <code>create</code> method adds the created stream to the internal cache of the loader. This has no effect if the cache is disabled.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic, cache: true })\n\nasync function createAndLoad() {\nconst stream = await loader.create({ hello: world })\n// The following call will returne the stream from the cache\nawait loader.load(stream.id)\n}\n</code></pre>"},{"location":"reference/glaze/modules/tile_loader/#load-a-deterministic-stream","title":"Load a deterministic stream","text":"<p>Using the <code>deterministic</code> method of a loader instance allows to load such streams while benefiting from the batching and caching functionalities of the loader.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic, cache: true })\n\nasync function load() {\n// The following call will load the latest version of the stream based on its metadata\nconst stream = await loader.deterministic({ controllers: ['did:key:...'], family: 'test' })\n}\n</code></pre>"},{"location":"reference/glaze/modules/tile_loader/#classes","title":"Classes","text":"<ul> <li>TileLoader</li> </ul>"},{"location":"reference/glaze/modules/tile_loader/#type-aliases","title":"Type aliases","text":""},{"location":"reference/glaze/modules/tile_loader/#tilecache","title":"TileCache","text":"<p>\u01ac TileCache: <code>Object</code></p>"},{"location":"reference/glaze/modules/tile_loader/#type-declaration","title":"Type declaration","text":"Name Type <code>clear</code> () =&gt; <code>any</code> <code>delete</code> (<code>id</code>: <code>string</code>) =&gt; <code>any</code> <code>get</code> (<code>id</code>: <code>string</code>) =&gt; <code>void</code> | <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt; <code>set</code> (<code>id</code>: <code>string</code>, <code>value</code>: <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt;) =&gt; <code>any</code>"},{"location":"reference/glaze/modules/tile_loader/#tilekey","title":"TileKey","text":"<p>\u01ac TileKey: <code>CommitID</code> | <code>StreamID</code> | <code>TileQuery</code> | <code>string</code></p>"},{"location":"reference/glaze/modules/tile_loader/#tileloaderparams","title":"TileLoaderParams","text":"<p>\u01ac TileLoaderParams: <code>Object</code></p>"},{"location":"reference/glaze/modules/tile_loader/#type-declaration_1","title":"Type declaration","text":"Name Type Description <code>cache?</code> <code>TileCache</code> | <code>boolean</code> A supported cache implementation, <code>true</code> to use the default implementation or <code>false</code> to disable the cache (default) <code>ceramic</code> <code>CeramicApi</code> A Ceramic client instance <code>multiqueryTimeout?</code> <code>number</code> MultiQuery request timeout in milliseconds"},{"location":"reference/glaze/modules/tile_loader/#tilequery","title":"TileQuery","text":"<p>\u01ac TileQuery: <code>Omit</code>&lt;<code>MultiQuery</code>, <code>\"paths\"</code> | <code>\"atTime\"</code>&gt;</p> <p>Omit <code>path</code> and <code>atTime</code> from MultiQuery as the cache needs to be deterministic based on the ID.</p>"},{"location":"reference/glaze/modules/tile_loader/#functions","title":"Functions","text":""},{"location":"reference/glaze/modules/tile_loader/#getdeterministicquery","title":"getDeterministicQuery","text":"<p>\u25b8 getDeterministicQuery(<code>metadata</code>): <code>Promise</code>&lt;<code>TileQuery</code>&gt;</p> <p>Create a <code>TileQuery</code> for a determinitic TileDocument based on its metadata.</p>"},{"location":"reference/glaze/modules/tile_loader/#parameters","title":"Parameters","text":"Name Type <code>metadata</code> <code>TileMetadataArgs</code>"},{"location":"reference/glaze/modules/tile_loader/#returns","title":"Returns","text":"<p><code>Promise</code>&lt;<code>TileQuery</code>&gt;</p>"},{"location":"reference/glaze/modules/types/","title":"Module: types","text":"<p>Common types used by Glaze packages.</p>"},{"location":"reference/glaze/modules/types/#type-aliases","title":"Type aliases","text":""},{"location":"reference/glaze/modules/types/#castmodelto","title":"CastModelTo","text":"<p>\u01ac CastModelTo&lt;<code>Model</code>, <code>ToType</code>&gt;: <code>Model</code> extends <code>ModelData</code>&lt;<code>any</code>&gt; ? <code>MapModelTypes</code>&lt;<code>Model</code>, <code>ToType</code>&gt; : <code>ModelData</code>&lt;<code>ToType</code>&gt;</p> <p>Utility type for mapping a model structure to a given type.</p>"},{"location":"reference/glaze/modules/types/#type-parameters","title":"Type parameters","text":"Name Type <code>Model</code> extends <code>ModelData</code>&lt;<code>any</code>&gt; | <code>void</code> <code>ToType</code> <code>ToType</code>"},{"location":"reference/glaze/modules/types/#encodeddagjws","title":"EncodedDagJWS","text":"<p>\u01ac EncodedDagJWS: <code>Object</code></p> <p>JSON-encoded DAG-JWS.</p>"},{"location":"reference/glaze/modules/types/#type-declaration","title":"Type declaration","text":"Name Type <code>link?</code> <code>string</code> <code>payload</code> <code>string</code> <code>signatures</code> <code>JWSSignature</code>[]"},{"location":"reference/glaze/modules/types/#encodeddagjwsresult","title":"EncodedDagJWSResult","text":"<p>\u01ac EncodedDagJWSResult: <code>Object</code></p> <p>JSON-encoded DAG-JWS result representing a Ceramic stream commit.</p>"},{"location":"reference/glaze/modules/types/#type-declaration_1","title":"Type declaration","text":"Name Type <code>jws</code> <code>EncodedDagJWS</code> <code>linkedBlock</code> <code>string</code>"},{"location":"reference/glaze/modules/types/#encodedmanagedmodel","title":"EncodedManagedModel","text":"<p>\u01ac EncodedManagedModel: <code>ManagedModel</code>&lt;<code>EncodedDagJWSResult</code>&gt;</p> <p>JSON-encoded version of the <code>ManagedModel</code>, used by the <code>ModelManager</code>.</p>"},{"location":"reference/glaze/modules/types/#manageddoc","title":"ManagedDoc","text":"<p>\u01ac ManagedDoc&lt;<code>CommitType</code>&gt;: <code>Object</code></p> <p>Shared structure for representing streams used in a <code>ManagedModel</code>.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_1","title":"Type parameters","text":"Name Type <code>CommitType</code> <code>DagJWSResult</code>"},{"location":"reference/glaze/modules/types/#type-declaration_2","title":"Type declaration","text":"Name Type <code>alias</code> <code>string</code> <code>commits</code> <code>CommitType</code>[] <code>version</code> <code>string</code>"},{"location":"reference/glaze/modules/types/#managedentry","title":"ManagedEntry","text":"<p>\u01ac ManagedEntry&lt;<code>CommitType</code>&gt;: <code>ManagedDoc</code>&lt;<code>CommitType</code>&gt; &amp; { <code>schema</code>: <code>ManagedID</code>  }</p> <p>Structure for representing streams having a schema dependency, used in a <code>ManagedModel</code>.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_2","title":"Type parameters","text":"Name Type <code>CommitType</code> <code>DagJWSResult</code>"},{"location":"reference/glaze/modules/types/#managedid","title":"ManagedID","text":"<p>\u01ac ManagedID: <code>string</code></p> <p>ID of a stream used in a <code>ManagedModel</code>.</p>"},{"location":"reference/glaze/modules/types/#managedmodel","title":"ManagedModel","text":"<p>\u01ac ManagedModel&lt;<code>CommitType</code>&gt;: <code>Object</code></p> <p>Structure used internally by the <code>ModelManager</code> to represent a data model.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_3","title":"Type parameters","text":"Name Type <code>CommitType</code> <code>DagJWSResult</code>"},{"location":"reference/glaze/modules/types/#type-declaration_3","title":"Type declaration","text":"Name Type <code>definitions</code> <code>Record</code>&lt;<code>ManagedID</code>, <code>ManagedEntry</code>&lt;<code>CommitType</code>&gt;&gt; <code>schemas</code> <code>Record</code>&lt;<code>ManagedID</code>, <code>ManagedSchema</code>&lt;<code>CommitType</code>&gt;&gt; <code>tiles</code> <code>Record</code>&lt;<code>ManagedID</code>, <code>ManagedEntry</code>&lt;<code>CommitType</code>&gt;&gt;"},{"location":"reference/glaze/modules/types/#managedschema","title":"ManagedSchema","text":"<p>\u01ac ManagedSchema&lt;<code>CommitType</code>&gt;: <code>ManagedDoc</code>&lt;<code>CommitType</code>&gt; &amp; { <code>dependencies</code>: <code>Record</code>&lt;<code>string</code>, <code>ManagedID</code>[]&gt;  }</p> <p>Structure for representing schema streams and their dependencies, used in a <code>ManagedModel</code>.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_4","title":"Type parameters","text":"Name Type <code>CommitType</code> <code>DagJWSResult</code>"},{"location":"reference/glaze/modules/types/#mapmodeltypes","title":"MapModelTypes","text":"<p>\u01ac MapModelTypes&lt;<code>Model</code>, <code>ToType</code>&gt;: <code>Object</code></p> <p>Utility type for mapping a model structure of a given type to another.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_5","title":"Type parameters","text":"Name Type <code>Model</code> extends <code>ModelData</code>&lt;<code>any</code>&gt; <code>ToType</code> <code>ToType</code>"},{"location":"reference/glaze/modules/types/#type-declaration_4","title":"Type declaration","text":"Name Type <code>definitions</code> <code>Record</code>&lt;keyof <code>Model</code>[<code>\"definitions\"</code>], <code>ToType</code>&gt; <code>schemas</code> <code>Record</code>&lt;keyof <code>Model</code>[<code>\"schemas\"</code>], <code>ToType</code>&gt; <code>tiles</code> <code>Record</code>&lt;keyof <code>Model</code>[<code>\"tiles\"</code>], <code>ToType</code>&gt;"},{"location":"reference/glaze/modules/types/#modelaliases","title":"ModelAliases","text":"<p>\u01ac ModelAliases&lt;<code>Model</code>&gt;: <code>CastModelTo</code>&lt;<code>Model</code>, <code>string</code>&gt;</p> <p>Data model aliases created by <code>deploying a managed model</code> and used at runtime by the <code>DataModel</code> class.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_6","title":"Type parameters","text":"Name Type <code>Model</code> extends <code>ModelData</code>&lt;<code>any</code>&gt; | <code>void</code> = <code>void</code>"},{"location":"reference/glaze/modules/types/#modeldata","title":"ModelData","text":"<p>\u01ac ModelData&lt;<code>T</code>&gt;: <code>Object</code></p> <p>Generic structure for storing model data.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_7","title":"Type parameters","text":"Name <code>T</code>"},{"location":"reference/glaze/modules/types/#type-declaration_5","title":"Type declaration","text":"Name Type <code>definitions</code> <code>Record</code>&lt;<code>string</code>, <code>T</code>&gt; <code>schemas</code> <code>Record</code>&lt;<code>string</code>, <code>T</code>&gt; <code>tiles</code> <code>Record</code>&lt;<code>string</code>, <code>T</code>&gt;"},{"location":"reference/glaze/modules/types/#modeltypealiases","title":"ModelTypeAliases","text":"<p>\u01ac ModelTypeAliases&lt;<code>Schemas</code>, <code>Definitions</code>, <code>Tiles</code>&gt;: <code>Object</code></p> <p>Model aliases relations between schemas and the definitions and tiles using them.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_8","title":"Type parameters","text":"Name Type <code>Schemas</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; <code>Definitions</code> extends <code>Record</code>&lt;<code>string</code>, keyof <code>Schemas</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt; <code>Tiles</code> extends <code>Record</code>&lt;<code>string</code>, keyof <code>Schemas</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;"},{"location":"reference/glaze/modules/types/#type-declaration_6","title":"Type declaration","text":"Name Type <code>definitions</code> <code>Definitions</code> <code>schemas</code> <code>Schemas</code> <code>tiles</code> <code>Tiles</code>"},{"location":"reference/glaze/modules/types/#modeltypestoaliases","title":"ModelTypesToAliases","text":"<p>\u01ac ModelTypesToAliases&lt;<code>TypeAliases</code>&gt;: <code>MapModelTypes</code>&lt;<code>TypeAliases</code>, <code>string</code>&gt;</p> <p>Utility type to cast <code>ModelTypeAliases</code> to <code>ModelAliases</code>.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_9","title":"Type parameters","text":"Name Type <code>TypeAliases</code> extends <code>ModelTypeAliases</code>"},{"location":"reference/glaze/modules/types/#schema","title":"Schema","text":"<p>\u01ac Schema&lt;<code>T</code>&gt;: <code>JSONSchemaType</code>&lt;<code>T</code>&gt; &amp; { <code>$comment?</code>: <code>string</code> ; <code>title?</code>: <code>string</code>  }</p> <p>JSON schema declaration, used for validating Ceramic streams.</p>"},{"location":"reference/glaze/modules/types/#type-parameters_10","title":"Type parameters","text":"Name Type <code>T</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/javascript/blockchain/","title":"Add support for a new blockchain","text":"<p>Deprecation Notice</p> <p>This guide is no longer the recommended way to add support for your blockchain and we are not accepting PRs at this moment for blockchains added in this way. The recommend way is now described here. </p> <p>This document contains a guide on how to add support for a new blockchain to the <code>CAIP10Link</code> StreamType, and to use it for authentication in Ceramic.</p>"},{"location":"reference/javascript/blockchain/#ceramic-and-blockchain-accounts","title":"Ceramic and blockchain accounts","text":"<p>Ceramic interacts with blockchain accounts in two ways: authentication and linking.</p>"},{"location":"reference/javascript/blockchain/#authentication","title":"Authentication","text":"<p>3ID Connect (using <code>3id-did-provider</code>) creates <code>3id</code> (Ceramic flavour of DID) private keys based on an externally-provided entropy. It could be provided by a blockchain account by merely signing a well-known message. From a user's standpoint, it is authentication into Ceramic through her blockchain account, be it on Ethereum, Filecoin, EOS, Cosmos or something else. Same signature (=same entropy) generates same Ceramic DID.</p>"},{"location":"reference/javascript/blockchain/#linking","title":"Linking","text":"<p>In addition to generating a DID a user could also link additional blockchain accounts to a Ceramic DID. It establishes a relation <code>blockchain account \u2192 DID</code> that allows one to discover a DID (and associated data like a social profile and data) based on just a blockchain account. Additionally, a link serves as a proof-of-ownership by DID over the blockchain account. This is useful for dApp personalization and UX: one sees familiar names instead of <code>0xgibberish</code>.</p> <p>Below one additional process is mentioned: validation. It checks if proof-of-ownership in the link is formally correct, i.e., a well-known payload is really signed by the account that is declared in the link.</p>"},{"location":"reference/javascript/blockchain/#adding-a-new-blockchain","title":"Adding a new blockchain","text":"<p>To add a new blockchain to Ceramic one has to implement both linking and validation. We use CAIP-10 to represent accounts in a blockchain agnostic way. If the blockchain you want to add isn't already part of the CAIP standards you should make sure to add it there.</p>"},{"location":"reference/javascript/blockchain/#linking_1","title":"Linking","text":"<p>To add a new blockchain, one has to implement a new class implementing AuthProvider, put it into the <code>@ceramicnetwork/blockchain-utils-linking</code> package and export it. The auth provider sits between 3id-connect (or 3ID DID Provider) and your blockchain account provider. In case of Ethereum, it might be MetaMask. It is responsible mainly for:</p> <ul> <li>authentication (<code>#authenticate</code>): provide deterministic entropy</li> <li>creating link (<code>#createLink</code>): create a LinkProof object which associates the specified AccountID with a DID</li> </ul> <p>The auth provider is expected to know which blockchain account it currently serves. It reports it via <code>#accountId</code>. To reuse the same internal settings, e.g. a connection to a blockchain provider, but with a different account, the auth provider should have a <code>#withAddress</code> method.</p> <p>Let's look at each method required to be implemented by the AuthProvider interface:</p>"},{"location":"reference/javascript/blockchain/#authenticate","title":"<code>authenticate()</code>","text":"<p>The <code>authenticate</code> function allows a blockchain account to be added as an authentication method (authMethod) to a 3ID. This means using your blockchain account you will always be able to access that 3ID and derive its 3ID Keychain for use, for example in 3ID Connect.</p>"},{"location":"reference/javascript/blockchain/#parameters","title":"Parameters","text":"<ul> <li><code>message</code>: string, can be any string</li> <li><code>AccountID</code>: an instance of a CAIP-10 AccountID</li> <li><code>provider</code>: specific to your blockchain. This is any standard signer or provider defined for your blockchain. Ideally your ecosystem has a widely-accepted standard interface so that this module can support signing by most accounts.</li> </ul>"},{"location":"reference/javascript/blockchain/#returns","title":"Returns","text":"<ul> <li><code>entropy</code>: a hex string representing 32 bytes of entropy, prefixed by <code>0x</code></li> </ul> <p>The entropy returned by a given AccountID must always be the same.</p>"},{"location":"reference/javascript/blockchain/#createlink","title":"<code>createLink()</code>","text":"<p>The <code>createLink</code> function allows a blockchain account to create a verifiable link proof that publicly binds the blockchain account to a given DID. In Ceramic, these these link proofs can be used to create <code>CAIP10Link</code> streams which allow anyone to look up the DID linked to your blockchain account, and then resolve any other public info linked to your DID. The StreamIDs of your CAIP10Links can be stored in the IDX Crypto Accounts records for simple lookup.</p> <p>This function consumes similar arguments as described above. It also consumes the DID string that is being linked. This function is implemented such that when the given AccountID signs a message including the given DID with the given provider, a <code>LinkProof</code> is returned.</p>"},{"location":"reference/javascript/blockchain/#accountid","title":"<code>accountId()</code>","text":"<p>The <code>accountId</code> method should return currently used account in the CAIP-10 format.</p>"},{"location":"reference/javascript/blockchain/#withaccount","title":"<code>withAccount()</code>","text":"<p>The <code>withAccount</code> method should return a new instance of the auth provider that serves a new account.</p>"},{"location":"reference/javascript/blockchain/#validation","title":"Validation","text":"<p>Validation is the counterpart of linking that checks if the signature contained in a <code>LinkProof</code> corresponds to the declared account.</p> <p>To add support for a new blockchain:</p> <ul> <li>add a new file named after your blockchain to <code>@ceramicnetwork/blockchain-utils-validation</code> package</li> <li>this file should expose an implementation of the <code>BlockchainHandler</code> interface, having:</li> <li>CAIP-2 <code>namespace</code> for your blockchain</li> <li>a <code>validateLink</code> function that checks if the linking signature was created by the account declared in the <code>LinkProof</code> argument</li> <li>add the newly created <code>BlockchainHandler</code> to the <code>handlers</code> list in index.ts</li> </ul>"},{"location":"reference/javascript/blockchain/#validatelink","title":"<code>validateLink()</code>","text":"<p>The <code>validateLink</code> function validates a given LinkProof. This allows anyone to easily verify LinkProofs and for Ceramic to validate CAIP10Links. The function consumes a LinkProof and returns the LinkProof if valid, otherwise it returns null. Valid typically means that the given signature in the LinkProof is valid over the given message and is created by the given account.</p> <p>Make sure that <code>validateLink</code> can validate links created by <code>AuthProvider#createLink</code>.</p>"},{"location":"reference/javascript/blockchain/#currently-supported-blockchains","title":"Currently supported blockchains","text":"<p>Below you can see a table which lists supported blockchains and their provider objects. If you add support for a new chain, please make a PR here.</p> Blockchain CAIP-2 namespace Supported providers Notes Cosmos cosmos @tendermint/sig The Cosmos wallet provider interface is still being standardized and is subject to change. Not fully supported. Ethereum eip155 MetaMask-like Ethereum provider Filecoin fil Filecoin Wallet Provider Not fully supported. EOS eosio @smontero/eosio-local-provider Not fully supported. Polkadot polkadot @polkadot{.js} extention api Doesn't support the <code>authenticate</code> method yet. Not fully supported. Tezos tezos @taquito/taquito Not fully supported. Near near @near/near-api-js CAIP in draft form. Not fully supported."},{"location":"reference/javascript/packages/","title":"JavaScript API References","text":"<p>This page contains a list of all packages and modules included in the Ceramic TypeScript implementation. Click into individual packages for detailed documentation on its APIs and types.</p>"},{"location":"reference/javascript/packages/#node","title":"Node","text":""},{"location":"reference/javascript/packages/#core","title":"Core","text":"<p><code>@ceramicnetwork/core</code>: Implementation of the Ceramic protocol, exposed using a simple JS API.</p>"},{"location":"reference/javascript/packages/#common","title":"Common","text":"<p><code>@ceramicnetwork/common</code>: Common Ceramic types and utilities.</p>"},{"location":"reference/javascript/packages/#streamid","title":"StreamID","text":"<p><code>@ceramicnetwork/streamid</code>: Utility for encoding and decoding StreamIDs and CommitIDs.</p>"},{"location":"reference/javascript/packages/#streamtype-tile-handler","title":"StreamType: Tile Handler","text":"<p><code>@ceramicnetwork/stream-tile-handler</code>: Handler implementation for the TileDocument StreamType.</p>"},{"location":"reference/javascript/packages/#streamtype-caip10link-handler","title":"StreamType: Caip10Link Handler","text":"<p><code>@ceramicnetwork/stream-caip10-link-handler</code>: Handler implementation for the Caip10Link StreamType.</p>"},{"location":"reference/javascript/packages/#pinning","title":"Pinning","text":"<p><code>@ceramicnetwork/pinning-aggregation</code>: Aggregation of backends for pinning stream content and state.</p>"},{"location":"reference/javascript/packages/#pinning-ipfs-backend","title":"Pinning: IPFS Backend","text":"<p><code>@ceramicnetwork/pinning-ipfs-backend</code>: Backend for pinning IPFS records on IPFS.</p>"},{"location":"reference/javascript/packages/#pinning-powergate-backend","title":"Pinning: Powergate Backend","text":"<p><code>@ceramicnetwork/pinning-powergate-backend</code>: Backend for pinning IPFS records on Filecoin via a Powergate service.</p>"},{"location":"reference/javascript/packages/#logger","title":"Logger","text":"<p><code>@ceramicnetwork/logger</code>: Utilities for logging.</p>"},{"location":"reference/javascript/packages/#clients","title":"Clients","text":""},{"location":"reference/javascript/packages/#http-client","title":"HTTP Client","text":"<p><code>@ceramicnetwork/http-client</code>: HTTP client for Ceramic.</p>"},{"location":"reference/javascript/packages/#cli","title":"CLI","text":"<p><code>@ceramicnetwork/cli</code>: Command line interface for Ceramic.</p>"},{"location":"reference/javascript/packages/#streamtype-tile","title":"StreamType: Tile","text":"<p><code>@ceramicnetwork/stream-tile</code>: Implementation of the TileDocument StreamType.</p>"},{"location":"reference/javascript/packages/#streamtype-caip10link","title":"StreamType: Caip10Link","text":"<p><code>@ceramicnetwork/stream-caip10-link</code>: Implementation of the Caip10Link StreamType.</p>"},{"location":"reference/javascript/packages/#dids","title":"DIDs","text":""},{"location":"reference/javascript/packages/#js-did","title":"JS DID","text":"<p><code>js-did</code>: Interface for interacting with DIDs.</p>"},{"location":"reference/javascript/packages/#3id-did-resolver","title":"3ID DID Resolver","text":"<p><code>@ceramicnetwork/3id-did-resolver</code>: Resolver for the 3ID DID method.</p>"},{"location":"reference/javascript/packages/#key-did-resolver","title":"Key DID Resolver","text":"<p><code>key-did-resolver</code>: Resolver for the Key DID method.</p>"},{"location":"reference/javascript/packages/#blockchain-utils-linking","title":"Blockchain Utils: Linking","text":"<p><code>@ceramicnetwork/blockchain-utils-linking</code>: Utility functions for linking blockchain accounts to DIDs.</p>"},{"location":"reference/javascript/packages/#blockchain-utils-validation","title":"Blockchain Utils: Validation","text":"<p><code>@ceramicnetwork/blockchain-utils-validation</code>: Utility functions to validate links of blockchain accounts linked a DID</p>"},{"location":"reference/self-id/","title":"Self.ID SDK","text":"<p>Self.ID is a framework that makes it easy to build Web3 applications with Ethereum-based authentication and composable, user-centric data storage and retrieval.</p>"},{"location":"reference/self-id/#why-selfid","title":"Why Self.ID?","text":"<p>\u2705 Easy setup</p> <p>Self.ID is a simple SDK requiring minimal configuration that provides access to the full Ceramic stack with support for popular environments such as <code>React</code> and <code>web</code>. The Self.ID SDK uses Glaze suite middleware, PKH DID blockchain accounts, DID Session authentication, and Ceramic HTTP client.</p> <p>\u2705 Login with Web3</p> <p>Self.ID is compatible with Ethereum accounts and EVM-based wallet authentication, so users don't have to install new wallets or create new accounts in order to use Ceramic.</p> <p>\u2705 Composable, user-centric data management</p> <p>The SDK includes some of the most popular Ceramic data models out-of-the-box, such as user profiles, linked crypto accounts, and linked Web2 accounts, giving your application automatic storage and retrieval composability with a rich set of existing users and data to bootstrap your application.</p> <p>\u2705 Extensible data models</p> <p>You're not limited to just the data models provided by Self.ID! You can create new data models or import ones from the Data Models Registry to add additional data features to your application.</p>"},{"location":"reference/self-id/#building-with-react","title":"Building with React","text":""},{"location":"reference/self-id/#using-the-framework","title":"Using the Framework \u2192","text":"<p>The Framework is the highest-level abstraction provided by the Self.ID SDK, designed specifically to power React applications. It leverages most other packages of the Self.ID SDK, and in most cases is the module you should use if you're building with React.</p>"},{"location":"reference/self-id/#building-with-javascript","title":"Building with JavaScript","text":""},{"location":"reference/self-id/#using-the-web-module","title":"Using the Web module \u2192","text":"<p>The Web module provides user authentication, data storage, and retrieval for browser-based applications.</p>"},{"location":"reference/self-id/#using-the-core-module","title":"Using the Core module \u2192","text":"<p>The Core module only provides data retrieval for Node and browser-based applications.</p>"},{"location":"reference/self-id/classes/core.Core/","title":"Class: Core&lt;ModelTypes, Alias&gt;","text":"<p>core.Core</p> <p>Core client for the Self.ID SDK, exported by the <code>core</code> module.</p> <pre><code>import { Core } from '@self.id/core'\n</code></pre>"},{"location":"reference/self-id/classes/core.Core/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code> <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/core.Core/#constructors","title":"Constructors","text":""},{"location":"reference/self-id/classes/core.Core/#constructor","title":"constructor","text":"<p>\u2022 new Core&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>"},{"location":"reference/self-id/classes/core.Core/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>CoreModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/core.Core/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/classes/core.Core/#accessors","title":"Accessors","text":""},{"location":"reference/self-id/classes/core.Core/#ceramic","title":"ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicClient</code></p> <p>Ceramic HTTP Client instance used internally.</p>"},{"location":"reference/self-id/classes/core.Core/#returns","title":"Returns","text":"<p><code>CeramicClient</code></p>"},{"location":"reference/self-id/classes/core.Core/#datamodel","title":"dataModel","text":"<p>\u2022 <code>get</code> dataModel(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p> <p>DataModel runtime instance used internally.</p>"},{"location":"reference/self-id/classes/core.Core/#returns_1","title":"Returns","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>"},{"location":"reference/self-id/classes/core.Core/#datastore","title":"dataStore","text":"<p>\u2022 <code>get</code> dataStore(): <code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p> <p>DID DataStore instance used internally.</p>"},{"location":"reference/self-id/classes/core.Core/#returns_2","title":"Returns","text":"<p><code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>"},{"location":"reference/self-id/classes/core.Core/#resolver","title":"resolver","text":"<p>\u2022 <code>get</code> resolver(): <code>Resolver</code></p> <p>DID resolver instance used internally.</p>"},{"location":"reference/self-id/classes/core.Core/#returns_3","title":"Returns","text":"<p><code>Resolver</code></p>"},{"location":"reference/self-id/classes/core.Core/#tileloader","title":"tileLoader","text":"<p>\u2022 <code>get</code> tileLoader(): <code>TileLoader</code></p> <p>Tile loader instance used internally.</p>"},{"location":"reference/self-id/classes/core.Core/#returns_4","title":"Returns","text":"<p><code>TileLoader</code></p>"},{"location":"reference/self-id/classes/core.Core/#methods","title":"Methods","text":""},{"location":"reference/self-id/classes/core.Core/#get","title":"get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>id</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load the record content for a given definition alias and account.</p> <p>Uses <code>toDID</code> to resolve the account.</p>"},{"location":"reference/self-id/classes/core.Core/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/core.Core/#parameters_1","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>id</code> <code>string</code>"},{"location":"reference/self-id/classes/core.Core/#returns_5","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/self-id/classes/core.Core/#getaccountdid","title":"getAccountDID","text":"<p>\u25b8 getAccountDID(<code>account</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load the DID string for a given CAIP-10 account using a CAIP-10 link, or throw an error if not linked.</p>"},{"location":"reference/self-id/classes/core.Core/#parameters_2","title":"Parameters","text":"Name Type <code>account</code> <code>string</code>"},{"location":"reference/self-id/classes/core.Core/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/core.Core/#todid","title":"toDID","text":"<p>\u25b8 toDID(<code>accountOrDID</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Turn a DID or CAIP-10 string into a DID string.</p> <p>If the input is a DID string, it will be returned as-is, otherwise <code>getAccountDID</code> will be used.</p>"},{"location":"reference/self-id/classes/core.Core/#parameters_3","title":"Parameters","text":"Name Type <code>accountOrDID</code> <code>string</code>"},{"location":"reference/self-id/classes/core.Core/#returns_7","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/core.PublicID/","title":"Class: PublicID&lt;ModelTypes, Alias&gt;","text":"<p>core.PublicID</p> <p>A PublicID instance provides a client associated to a specific DID.</p> <p>It is exported by the <code>core</code> module.</p> <pre><code>import { PublicID } from '@self.id/core'\n</code></pre>"},{"location":"reference/self-id/classes/core.PublicID/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code> <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/core.PublicID/#constructors","title":"Constructors","text":""},{"location":"reference/self-id/classes/core.PublicID/#constructor","title":"constructor","text":"<p>\u2022 new PublicID&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>"},{"location":"reference/self-id/classes/core.PublicID/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>CoreModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/core.PublicID/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>PublicIDParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/classes/core.PublicID/#accessors","title":"Accessors","text":""},{"location":"reference/self-id/classes/core.PublicID/#id","title":"id","text":"<p>\u2022 <code>get</code> id(): <code>string</code></p> <p>DID string associated to the PublicID instance.</p>"},{"location":"reference/self-id/classes/core.PublicID/#returns","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/self-id/classes/core.PublicID/#methods","title":"Methods","text":""},{"location":"reference/self-id/classes/core.PublicID/#get","title":"get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load the record contents for a given definition alias.</p>"},{"location":"reference/self-id/classes/core.PublicID/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/core.PublicID/#parameters_1","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code>"},{"location":"reference/self-id/classes/core.PublicID/#returns_1","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/self-id/classes/react.ReactClient/","title":"Class: ReactClient&lt;ModelTypes&gt;","text":"<p>react.ReactClient</p> <p>ReactClient extends the <code>Core class</code> with authentication support in browser environments.</p> <p>It is exported by the <code>react</code> module.</p> <pre><code>import { ReactClient } from '@self.id/react'\n</code></pre>"},{"location":"reference/self-id/classes/react.ReactClient/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/classes/react.ReactClient/#hierarchy","title":"Hierarchy","text":"<ul> <li><code>Core</code>&lt;<code>ModelTypes</code>&gt;</li> </ul> <p>\u21b3 <code>ReactClient</code></p>"},{"location":"reference/self-id/classes/react.ReactClient/#constructors","title":"Constructors","text":""},{"location":"reference/self-id/classes/react.ReactClient/#constructor","title":"constructor","text":"<p>\u2022 new ReactClient&lt;<code>ModelTypes</code>&gt;(<code>params</code>)</p>"},{"location":"reference/self-id/classes/react.ReactClient/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/classes/react.ReactClient/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/classes/react.ReactClient/#overrides","title":"Overrides","text":"<p>Core&lt;ModelTypes\\&gt;.constructor</p>"},{"location":"reference/self-id/classes/react.ReactClient/#accessors","title":"Accessors","text":""},{"location":"reference/self-id/classes/react.ReactClient/#ceramic","title":"ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicClient</code></p> <p>Ceramic HTTP Client instance used internally.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#returns","title":"Returns","text":"<p><code>CeramicClient</code></p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from","title":"Inherited from","text":"<p>Core.ceramic</p>"},{"location":"reference/self-id/classes/react.ReactClient/#datamodel","title":"dataModel","text":"<p>\u2022 <code>get</code> dataModel(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p> <p>DataModel runtime instance used internally.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_1","title":"Returns","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from_1","title":"Inherited from","text":"<p>Core.dataModel</p>"},{"location":"reference/self-id/classes/react.ReactClient/#datastore","title":"dataStore","text":"<p>\u2022 <code>get</code> dataStore(): <code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p> <p>DID DataStore instance used internally.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_2","title":"Returns","text":"<p><code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from_2","title":"Inherited from","text":"<p>Core.dataStore</p>"},{"location":"reference/self-id/classes/react.ReactClient/#resolver","title":"resolver","text":"<p>\u2022 <code>get</code> resolver(): <code>Resolver</code></p> <p>DID resolver instance used internally.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_3","title":"Returns","text":"<p><code>Resolver</code></p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from_3","title":"Inherited from","text":"<p>Core.resolver</p>"},{"location":"reference/self-id/classes/react.ReactClient/#tileloader","title":"tileLoader","text":"<p>\u2022 <code>get</code> tileLoader(): <code>TileLoader</code></p> <p>Tile loader instance used internally.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_4","title":"Returns","text":"<p><code>TileLoader</code></p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from_4","title":"Inherited from","text":"<p>Core.tileLoader</p>"},{"location":"reference/self-id/classes/react.ReactClient/#methods","title":"Methods","text":""},{"location":"reference/self-id/classes/react.ReactClient/#authenticate","title":"authenticate","text":"<p>\u25b8 authenticate(<code>authProvider</code>): <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;&gt;</p> <p>Create a <code>SelfID</code> instance using the given <code>authProvider</code> and attach the associated DID instance to the internal Ceramic client instance.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#parameters_1","title":"Parameters","text":"Name Type <code>authProvider</code> <code>EthereumAuthProvider</code>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_5","title":"Returns","text":"<p><code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;&gt;</p>"},{"location":"reference/self-id/classes/react.ReactClient/#get","title":"get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>id</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load the record content for a given definition alias and account.</p> <p>Uses <code>toDID</code> to resolve the account.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/react.ReactClient/#parameters_2","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>id</code> <code>string</code>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from_5","title":"Inherited from","text":"<p>Core.get</p>"},{"location":"reference/self-id/classes/react.ReactClient/#getaccountdid","title":"getAccountDID","text":"<p>\u25b8 getAccountDID(<code>account</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load the DID string for a given CAIP-10 account using a CAIP-10 link, or throw an error if not linked.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#parameters_3","title":"Parameters","text":"Name Type <code>account</code> <code>string</code>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_7","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from_6","title":"Inherited from","text":"<p>Core.getAccountDID</p>"},{"location":"reference/self-id/classes/react.ReactClient/#todid","title":"toDID","text":"<p>\u25b8 toDID(<code>accountOrDID</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Turn a DID or CAIP-10 string into a DID string.</p> <p>If the input is a DID string, it will be returned as-is, otherwise <code>getAccountDID</code> will be used.</p>"},{"location":"reference/self-id/classes/react.ReactClient/#parameters_4","title":"Parameters","text":"Name Type <code>accountOrDID</code> <code>string</code>"},{"location":"reference/self-id/classes/react.ReactClient/#returns_8","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/react.ReactClient/#inherited-from_7","title":"Inherited from","text":"<p>Core.toDID</p>"},{"location":"reference/self-id/classes/react.RequestClient/","title":"Class: RequestClient&lt;ModelTypes, Alias&gt;","text":"<p>react.RequestClient</p> <p>The RequestClient extends the <code>Core</code> class as a server-side client for prefetching and serializing records so they can be hydrated on the browser side.</p> <p>It is exported by the <code>react</code> module.</p> <pre><code>import { RequestClient } from '@self.id/react'\n</code></pre>"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code> <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/react.RequestClient/#hierarchy","title":"Hierarchy","text":"<ul> <li><code>Core</code>&lt;<code>ModelTypes</code>&gt;</li> </ul> <p>\u21b3 <code>RequestClient</code></p>"},{"location":"reference/self-id/classes/react.RequestClient/#constructors","title":"Constructors","text":""},{"location":"reference/self-id/classes/react.RequestClient/#constructor","title":"constructor","text":"<p>\u2022 new RequestClient&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/react.RequestClient/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>RequestClientParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/classes/react.RequestClient/#overrides","title":"Overrides","text":"<p>Core&lt;ModelTypes\\&gt;.constructor</p>"},{"location":"reference/self-id/classes/react.RequestClient/#accessors","title":"Accessors","text":""},{"location":"reference/self-id/classes/react.RequestClient/#ceramic","title":"ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicClient</code></p> <p>Ceramic HTTP Client instance used internally.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#returns","title":"Returns","text":"<p><code>CeramicClient</code></p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from","title":"Inherited from","text":"<p>Core.ceramic</p>"},{"location":"reference/self-id/classes/react.RequestClient/#datamodel","title":"dataModel","text":"<p>\u2022 <code>get</code> dataModel(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p> <p>DataModel runtime instance used internally.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_1","title":"Returns","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_1","title":"Inherited from","text":"<p>Core.dataModel</p>"},{"location":"reference/self-id/classes/react.RequestClient/#datastore","title":"dataStore","text":"<p>\u2022 <code>get</code> dataStore(): <code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p> <p>DID DataStore instance used internally.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_2","title":"Returns","text":"<p><code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_2","title":"Inherited from","text":"<p>Core.dataStore</p>"},{"location":"reference/self-id/classes/react.RequestClient/#resolver","title":"resolver","text":"<p>\u2022 <code>get</code> resolver(): <code>Resolver</code></p> <p>DID resolver instance used internally.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_3","title":"Returns","text":"<p><code>Resolver</code></p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_3","title":"Inherited from","text":"<p>Core.resolver</p>"},{"location":"reference/self-id/classes/react.RequestClient/#tileloader","title":"tileLoader","text":"<p>\u2022 <code>get</code> tileLoader(): <code>TileLoader</code></p> <p>Tile loader instance used internally.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_4","title":"Returns","text":"<p><code>TileLoader</code></p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_4","title":"Inherited from","text":"<p>Core.tileLoader</p>"},{"location":"reference/self-id/classes/react.RequestClient/#viewerid","title":"viewerID","text":"<p>\u2022 <code>get</code> viewerID(): <code>null</code> | <code>string</code></p> <p>Viewer ID associated to the request, if found in cookie string.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_5","title":"Returns","text":"<p><code>null</code> | <code>string</code></p>"},{"location":"reference/self-id/classes/react.RequestClient/#methods","title":"Methods","text":""},{"location":"reference/self-id/classes/react.RequestClient/#get","title":"get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>id</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load the record content for a given definition alias and account.</p> <p>Uses <code>toDID</code> to resolve the account.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_1","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>id</code> <code>string</code>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_5","title":"Inherited from","text":"<p>Core.get</p>"},{"location":"reference/self-id/classes/react.RequestClient/#getaccountdid","title":"getAccountDID","text":"<p>\u25b8 getAccountDID(<code>account</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load the DID string for a given CAIP-10 account using a CAIP-10 link, or throw an error if not linked.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_2","title":"Parameters","text":"Name Type <code>account</code> <code>string</code>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_7","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_6","title":"Inherited from","text":"<p>Core.getAccountDID</p>"},{"location":"reference/self-id/classes/react.RequestClient/#getstate","title":"getState","text":"<p>\u25b8 getState(): <code>RequestState</code></p> <p>Return a serialized request state possibly containing the current viewer ID and prefetched records so they can be injected on the browser side, notably in the <code>Provider</code>.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_8","title":"Returns","text":"<p><code>RequestState</code></p>"},{"location":"reference/self-id/classes/react.RequestClient/#prefetch","title":"prefetch","text":"<p>\u25b8 prefetch&lt;<code>Key</code>&gt;(<code>key</code>, <code>id?</code>): <code>Promise</code>&lt;<code>boolean</code>&gt;</p> <p>Prefetch loading a record so it can be exported using <code>getState</code>.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters_3","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_3","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>id</code> <code>null</code> | <code>string</code>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_9","title":"Returns","text":"<p><code>Promise</code>&lt;<code>boolean</code>&gt;</p>"},{"location":"reference/self-id/classes/react.RequestClient/#todid","title":"toDID","text":"<p>\u25b8 toDID(<code>accountOrDID</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Turn a DID or CAIP-10 string into a DID string.</p> <p>If the input is a DID string, it will be returned as-is, otherwise <code>getAccountDID</code> will be used.</p>"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_4","title":"Parameters","text":"Name Type <code>accountOrDID</code> <code>string</code>"},{"location":"reference/self-id/classes/react.RequestClient/#returns_10","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_7","title":"Inherited from","text":"<p>Core.toDID</p>"},{"location":"reference/self-id/classes/web.SelfID/","title":"Class: SelfID&lt;ModelTypes, Alias&gt;","text":"<p>web.SelfID</p> <p>A SelfID instance provides a client for an authenticated DID. Beyond loading records, it also allows to mutate them.</p> <p>It is exported by the <code>web</code> module.</p> <pre><code>import { SelfID } from '@self.id/web'\n</code></pre>"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code> <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/web.SelfID/#constructors","title":"Constructors","text":""},{"location":"reference/self-id/classes/web.SelfID/#constructor","title":"constructor","text":"<p>\u2022 new SelfID&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]"},{"location":"reference/self-id/classes/web.SelfID/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>SelfIDParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/classes/web.SelfID/#accessors","title":"Accessors","text":""},{"location":"reference/self-id/classes/web.SelfID/#client","title":"client","text":"<p>\u2022 <code>get</code> client(): <code>WebClient</code>&lt;<code>ModelTypes</code>&gt;</p> <p>WebClient instance used internally.</p>"},{"location":"reference/self-id/classes/web.SelfID/#returns","title":"Returns","text":"<p><code>WebClient</code>&lt;<code>ModelTypes</code>&gt;</p>"},{"location":"reference/self-id/classes/web.SelfID/#did","title":"did","text":"<p>\u2022 <code>get</code> did(): <code>DID</code></p> <p>DID instance used internally.</p>"},{"location":"reference/self-id/classes/web.SelfID/#returns_1","title":"Returns","text":"<p><code>DID</code></p>"},{"location":"reference/self-id/classes/web.SelfID/#id","title":"id","text":"<p>\u2022 <code>get</code> id(): <code>string</code></p> <p>DID string associated to the SelfID instance.</p>"},{"location":"reference/self-id/classes/web.SelfID/#returns_2","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/self-id/classes/web.SelfID/#methods","title":"Methods","text":""},{"location":"reference/self-id/classes/web.SelfID/#get","title":"get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load the record contents for a given definition alias.</p>"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/web.SelfID/#parameters_1","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code>"},{"location":"reference/self-id/classes/web.SelfID/#returns_3","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/self-id/classes/web.SelfID/#merge","title":"merge","text":"<p>\u25b8 merge&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Merge the record contents for a given definition alias. If no content exists, the record will be created.</p> <p>\u26a0\ufe0f This method only performs a shallow (one level) merge using Object.assign. For a deep merge or a specific merging strategy, you will need to implement custom logic.</p>"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_3","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/web.SelfID/#parameters_2","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>content</code> <code>ContentType</code>"},{"location":"reference/self-id/classes/web.SelfID/#returns_4","title":"Returns","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>"},{"location":"reference/self-id/classes/web.SelfID/#set","title":"set","text":"<p>\u25b8 set&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Set the record contents for a given definition alias.</p> <p>\u26a0\ufe0f Using this method will replace any existing content. If you only want to write some fields and leave existing ones unchanged, you can use the <code>merge</code> method instead.</p>"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_4","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/web.SelfID/#parameters_3","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>content</code> <code>ContentType</code>"},{"location":"reference/self-id/classes/web.SelfID/#returns_5","title":"Returns","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>"},{"location":"reference/self-id/classes/web.SelfID/#authenticate","title":"authenticate","text":"<p>\u25b8 <code>Static</code> authenticate&lt;<code>ModelTypes</code>&gt;(<code>params</code>): <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;&gt;</p> <p>Create a SelfID instance by authenticating using the given provider.</p>"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_5","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/classes/web.SelfID/#parameters_4","title":"Parameters","text":"Name Type <code>params</code> <code>AuthenticateParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/classes/web.SelfID/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/","title":"Class: WebClient&lt;ModelTypes&gt;","text":"<p>web.WebClient</p> <p>WebClient extends the <code>Core class</code> with authentication support in browser environments.</p> <p>It is exported by the <code>web</code> module.</p> <pre><code>import { WebClient } from '@self.id/web'\n</code></pre>"},{"location":"reference/self-id/classes/web.WebClient/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/classes/web.WebClient/#hierarchy","title":"Hierarchy","text":"<ul> <li><code>Core</code>&lt;<code>ModelTypes</code>&gt;</li> </ul> <p>\u21b3 <code>WebClient</code></p>"},{"location":"reference/self-id/classes/web.WebClient/#constructors","title":"Constructors","text":""},{"location":"reference/self-id/classes/web.WebClient/#constructor","title":"constructor","text":"<p>\u2022 new WebClient&lt;<code>ModelTypes</code>&gt;(<code>params</code>)</p>"},{"location":"reference/self-id/classes/web.WebClient/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/classes/web.WebClient/#parameters","title":"Parameters","text":"Name Type <code>params</code> <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/classes/web.WebClient/#overrides","title":"Overrides","text":"<p>Core&lt;ModelTypes\\&gt;.constructor</p>"},{"location":"reference/self-id/classes/web.WebClient/#accessors","title":"Accessors","text":""},{"location":"reference/self-id/classes/web.WebClient/#ceramic","title":"ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicClient</code></p> <p>Ceramic HTTP Client instance used internally.</p>"},{"location":"reference/self-id/classes/web.WebClient/#returns","title":"Returns","text":"<p><code>CeramicClient</code></p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from","title":"Inherited from","text":"<p>Core.ceramic</p>"},{"location":"reference/self-id/classes/web.WebClient/#datamodel","title":"dataModel","text":"<p>\u2022 <code>get</code> dataModel(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p> <p>DataModel runtime instance used internally.</p>"},{"location":"reference/self-id/classes/web.WebClient/#returns_1","title":"Returns","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_1","title":"Inherited from","text":"<p>Core.dataModel</p>"},{"location":"reference/self-id/classes/web.WebClient/#datastore","title":"dataStore","text":"<p>\u2022 <code>get</code> dataStore(): <code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p> <p>DID DataStore instance used internally.</p>"},{"location":"reference/self-id/classes/web.WebClient/#returns_2","title":"Returns","text":"<p><code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_2","title":"Inherited from","text":"<p>Core.dataStore</p>"},{"location":"reference/self-id/classes/web.WebClient/#resolver","title":"resolver","text":"<p>\u2022 <code>get</code> resolver(): <code>Resolver</code></p> <p>DID resolver instance used internally.</p>"},{"location":"reference/self-id/classes/web.WebClient/#returns_3","title":"Returns","text":"<p><code>Resolver</code></p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_3","title":"Inherited from","text":"<p>Core.resolver</p>"},{"location":"reference/self-id/classes/web.WebClient/#threeid","title":"threeId","text":"<p>\u2022 <code>get</code> threeId(): <code>ThreeIdConnect</code></p> <p>3ID Connect instance used internally.</p>"},{"location":"reference/self-id/classes/web.WebClient/#returns_4","title":"Returns","text":"<p><code>ThreeIdConnect</code></p>"},{"location":"reference/self-id/classes/web.WebClient/#tileloader","title":"tileLoader","text":"<p>\u2022 <code>get</code> tileLoader(): <code>TileLoader</code></p> <p>Tile loader instance used internally.</p>"},{"location":"reference/self-id/classes/web.WebClient/#returns_5","title":"Returns","text":"<p><code>TileLoader</code></p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_4","title":"Inherited from","text":"<p>Core.tileLoader</p>"},{"location":"reference/self-id/classes/web.WebClient/#methods","title":"Methods","text":""},{"location":"reference/self-id/classes/web.WebClient/#authenticate","title":"authenticate","text":"<p>\u25b8 authenticate(<code>authProvider</code>, <code>attachToCeramic?</code>): <code>Promise</code>&lt;<code>DID</code>&gt;</p> <p>Create and authenticate a DID instance using the given <code>authProvider</code>.</p> <p>By default, this also attaches the created DID instance to the internal Ceramic client instance. This behavior can be disabled by setting <code>attachToCeramic</code> to <code>false</code>.</p>"},{"location":"reference/self-id/classes/web.WebClient/#parameters_1","title":"Parameters","text":"Name Type Default value <code>authProvider</code> <code>EthereumAuthProvider</code> <code>undefined</code> <code>attachToCeramic</code> <code>boolean</code> <code>true</code>"},{"location":"reference/self-id/classes/web.WebClient/#returns_6","title":"Returns","text":"<p><code>Promise</code>&lt;<code>DID</code>&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/#connect","title":"connect","text":"<p>\u25b8 connect(<code>authProvider</code>): <code>Promise</code>&lt;<code>DID</code>&gt;</p> <p>Create a DID instance using the given <code>authProvider</code>.</p> <p>\u26a0\ufe0f This method does not attempt to authenticate immediately, use <code>authenticate</code> instead if this is the wanted behavior.</p>"},{"location":"reference/self-id/classes/web.WebClient/#parameters_2","title":"Parameters","text":"Name Type <code>authProvider</code> <code>EthereumAuthProvider</code>"},{"location":"reference/self-id/classes/web.WebClient/#returns_7","title":"Returns","text":"<p><code>Promise</code>&lt;<code>DID</code>&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/#get","title":"get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>id</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load the record content for a given definition alias and account.</p> <p>Uses <code>toDID</code> to resolve the account.</p>"},{"location":"reference/self-id/classes/web.WebClient/#type-parameters_2","title":"Type parameters","text":"Name Type <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;"},{"location":"reference/self-id/classes/web.WebClient/#parameters_3","title":"Parameters","text":"Name Type <code>key</code> <code>Key</code> <code>id</code> <code>string</code>"},{"location":"reference/self-id/classes/web.WebClient/#returns_8","title":"Returns","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_5","title":"Inherited from","text":"<p>Core.get</p>"},{"location":"reference/self-id/classes/web.WebClient/#getaccountdid","title":"getAccountDID","text":"<p>\u25b8 getAccountDID(<code>account</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Load the DID string for a given CAIP-10 account using a CAIP-10 link, or throw an error if not linked.</p>"},{"location":"reference/self-id/classes/web.WebClient/#parameters_4","title":"Parameters","text":"Name Type <code>account</code> <code>string</code>"},{"location":"reference/self-id/classes/web.WebClient/#returns_9","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_6","title":"Inherited from","text":"<p>Core.getAccountDID</p>"},{"location":"reference/self-id/classes/web.WebClient/#todid","title":"toDID","text":"<p>\u25b8 toDID(<code>accountOrDID</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Turn a DID or CAIP-10 string into a DID string.</p> <p>If the input is a DID string, it will be returned as-is, otherwise <code>getAccountDID</code> will be used.</p>"},{"location":"reference/self-id/classes/web.WebClient/#parameters_5","title":"Parameters","text":"Name Type <code>accountOrDID</code> <code>string</code>"},{"location":"reference/self-id/classes/web.WebClient/#returns_10","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_7","title":"Inherited from","text":"<p>Core.toDID</p>"},{"location":"reference/self-id/modules/3box_legacy/","title":"Module: 3box-legacy","text":"<p>Load legacy 3Box profiles.</p>"},{"location":"reference/self-id/modules/3box_legacy/#purpose","title":"Purpose","text":"<p>The<code>3box-legacy</code> module provides utility functions to load legacy 3Box profiles.</p>"},{"location":"reference/self-id/modules/3box_legacy/#installation","title":"Installation","text":"<pre><code>npm install @self.id/3box-legacy\n</code></pre>"},{"location":"reference/self-id/modules/3box_legacy/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/self-id/modules/3box_legacy/#load-a-legacy-3box-profile-as-a-selfid-basic-profile","title":"Load a legacy 3Box profile as a Self.ID basic profile","text":"<pre><code>import { getLegacy3BoxProfileAsBasicProfile } from '@self.id/3box-legacy'\n\nasync function getProfile() {\n// Ethereum address to load the profile of\nconst address = '0x123efad...'\nreturn await getLegacy3BoxProfileAsBasicProfile(address)\n}\n</code></pre>"},{"location":"reference/self-id/modules/3box_legacy/#functions","title":"Functions","text":""},{"location":"reference/self-id/modules/3box_legacy/#getlegacy3boxprofileasbasicprofile","title":"getLegacy3BoxProfileAsBasicProfile","text":"<p>\u25b8 getLegacy3BoxProfileAsBasicProfile(<code>address</code>, <code>fetchFunc?</code>): <code>Promise</code>&lt;<code>BasicProfile</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/3box_legacy/#parameters","title":"Parameters","text":"Name Type <code>address</code> <code>string</code> <code>fetchFunc?</code> (<code>input</code>: <code>RequestInfo</code>, <code>init?</code>: <code>RequestInit</code>) =&gt; <code>Promise</code>&lt;<code>Response</code>&gt;"},{"location":"reference/self-id/modules/3box_legacy/#returns","title":"Returns","text":"<p><code>Promise</code>&lt;<code>BasicProfile</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/3box_legacy/#loadlegacy3boxprofile","title":"loadLegacy3BoxProfile","text":"<p>\u25b8 loadLegacy3BoxProfile&lt;<code>T</code>&gt;(<code>address</code>, <code>fetchFunc?</code>): <code>Promise</code>&lt;<code>T</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/3box_legacy/#type-parameters","title":"Type parameters","text":"Name Type <code>T</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/self-id/modules/3box_legacy/#parameters_1","title":"Parameters","text":"Name Type Default value <code>address</code> <code>string</code> <code>undefined</code> <code>fetchFunc</code> (<code>input</code>: <code>RequestInfo</code>, <code>init?</code>: <code>RequestInit</code>) =&gt; <code>Promise</code>&lt;<code>Response</code>&gt; <code>crossFetch</code>"},{"location":"reference/self-id/modules/3box_legacy/#returns_1","title":"Returns","text":"<p><code>Promise</code>&lt;<code>T</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/3box_legacy/#transformprofile","title":"transformProfile","text":"<p>\u25b8 transformProfile(<code>profile</code>): <code>BasicProfile</code></p>"},{"location":"reference/self-id/modules/3box_legacy/#parameters_2","title":"Parameters","text":"Name Type <code>profile</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;"},{"location":"reference/self-id/modules/3box_legacy/#returns_2","title":"Returns","text":"<p><code>BasicProfile</code></p>"},{"location":"reference/self-id/modules/core/","title":"Module: core","text":"<p>Read public records in Node and browsers environments.</p>"},{"location":"reference/self-id/modules/core/#purpose","title":"Purpose","text":"<p>The <code>core</code> module of the Self.ID SDK exports the <code>Core</code> and <code>PublicID</code> classes to provide APIs for reading public records in Node and browsers environments.</p> <p>It can therefore be used both client-side and server-side by applications wanting to access records associated to a DID on a Ceramic network.</p>"},{"location":"reference/self-id/modules/core/#installation","title":"Installation","text":"<pre><code>npm install @self.id/core\n</code></pre>"},{"location":"reference/self-id/modules/core/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/self-id/modules/core/#read-the-basic-profile-of-a-known-did","title":"Read the basic profile of a known DID","text":"<pre><code>import { Core } from '@self.id/core'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n\nasync function getProfile() {\n// Replace by the wanted DID string\nconst did = 'did:3:...'\nreturn await core.get('basicProfile', did)\n}\n</code></pre>"},{"location":"reference/self-id/modules/core/#connect-to-a-custom-ceramic-node","title":"Connect to a custom Ceramic node","text":"<pre><code>import { Core } from '@self.id/core'\n\n// You can provide the URL of a custom node as the `ceramic` parameter\nconst core = new Core({ ceramic: 'https://ceramic-clay.3boxlabs.com' })\n</code></pre>"},{"location":"reference/self-id/modules/core/#use-a-custom-data-model","title":"Use a custom data model","text":"<pre><code>import { Core } from '@self.id/core'\n\nconst aliases = {\ndefinitions: {\nbasicProfile: 'kjzl6cwe1jw145cjbeko9kil8g9bxszjhyde21ob8epxuxkaon1izyqsu8wgcic',\nnotes: 'kjzl6cwe1jw14688v7zhf5eo1uiblt0thkgdedb5gaiq99isj224g6v8uza2r4m',\n},\nschemas: {\nBasicProfile: 'ceramic://k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio',\nNote: 'ceramic://k3y52l7qbv1fryg3uy4gz50pj3ivni18h6younsgd2kb5u7mivx3h258m01tkwk5c',\nNotes: 'ceramic://k3y52l7qbv1frxk024s7ds2456qo3rwa02k31uf98loz8lm1lodlgv3eeqh4cxgjk',\n},\ntiles: {\nplaceholderNote: 'kjzl6cwe1jw148snra9bmyf32y5pj2ysnvenqx59k7n2lz3gnri72axvp25fo1v',\n},\n}\nconst core = new Core({ ceramic: 'testnet-clay', aliases })\n\nasync function getNotes(did) {\nreturn await core.get('notes', did)\n}\n</code></pre>"},{"location":"reference/self-id/modules/core/#use-a-publicid-instance","title":"Use a PublicID instance","text":"<pre><code>import { Core, PublicID } from '@self.id/core'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n// Replace the `id` parameter by the wanted DID string\nconst currentUser = new PublicID({ core, id: 'did:3:...' })\n\nasync function getCurrentUserProfile() {\nreturn await currentUser.get('basicProfile')\n}\n</code></pre>"},{"location":"reference/self-id/modules/core/#classes","title":"Classes","text":"<ul> <li>Core</li> <li>PublicID</li> </ul>"},{"location":"reference/self-id/modules/core/#type-aliases","title":"Type aliases","text":""},{"location":"reference/self-id/modules/core/#ceramicnetwork","title":"CeramicNetwork","text":"<p>\u01ac CeramicNetwork: <code>\"local\"</code> | <code>\"mainnet-gateway\"</code> | <code>\"testnet-clay\"</code> | <code>\"testnet-clay-gateway\"</code></p> <p>Configured Ceramic endpoints:</p> <ul> <li>\"local\" -&gt; http://localhost:7007</li> <li>\"mainnet-gateway\" -&gt; https://gateway.ceramic.network (read-only)</li> <li>\"testnet-clay\" -&gt; https://ceramic-clay.3boxlabs.com</li> <li>\"testnet-clay-gateway\" -&gt; https://gateway-clay.ceramic.network (read-only)</li> </ul>"},{"location":"reference/self-id/modules/core/#coremodeltypes","title":"CoreModelTypes","text":"<p>\u01ac CoreModelTypes: <code>ModelTypeAliases</code>&lt;{ <code>AlsoKnownAs</code>: <code>AlsoKnownAs</code> ; <code>BasicProfile</code>: <code>BasicProfile</code> ; <code>CryptoAccounts</code>: <code>CryptoAccountLinks</code>  }, { <code>alsoKnownAs</code>: <code>\"AlsoKnownAs\"</code> ; <code>basicProfile</code>: <code>\"BasicProfile\"</code> ; <code>cryptoAccounts</code>: <code>\"CryptoAccounts\"</code>  }&gt;</p> <p>Default model types provided by the Self.ID SDK.</p>"},{"location":"reference/self-id/modules/core/#coreparams","title":"CoreParams","text":"<p>\u01ac CoreParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>"},{"location":"reference/self-id/modules/core/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/core/#type-declaration","title":"Type declaration","text":"Name Type Description <code>aliases?</code> <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt; Data model aliases to use instead of the default ones. <code>cache?</code> <code>TileCache</code> | <code>boolean</code> Cache interface to use or <code>true</code> to use a default cache. If <code>false</code> or undefined (default), no cache is used. <code>ceramic</code> <code>CeramicNetwork</code> | <code>string</code> Predefined <code>CeramicNetwork</code> configuration value of Ceramic server URL. <code>loader?</code> <code>TileLoader</code> Tile loader instance to use. If provided, the <code>cache</code> parameter will be ignored."},{"location":"reference/self-id/modules/core/#publicidparams","title":"PublicIDParams","text":"<p>\u01ac PublicIDParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>"},{"location":"reference/self-id/modules/core/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/core/#type-declaration_1","title":"Type declaration","text":"Name Type Description <code>core</code> <code>Core</code>&lt;<code>ModelTypes</code>&gt; <code>Core</code> instance to use. <code>id</code> <code>string</code> DID string."},{"location":"reference/self-id/modules/framework/","title":"Module: framework","text":"<p>React framework for decentralized apps.</p>"},{"location":"reference/self-id/modules/framework/#purpose","title":"Purpose","text":"<p>The <code>framework</code> module is the highest-level abstraction provided by the Self.ID SDK, aimed at helping developers to quickly get started with building decentralized apps using Ceramic with React.</p> <p>The framework is built on top of the <code>core</code>, <code>web</code> and <code>react</code> modules to provide APIs to easily authenticate users, keep track of the current user and interact with both public (read-only) and user-owned (mutable) records.</p>"},{"location":"reference/self-id/modules/framework/#installation","title":"Installation","text":"<pre><code>npm install @self.id/framework\n</code></pre>"},{"location":"reference/self-id/modules/framework/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/self-id/modules/framework/#configure-the-provider","title":"Configure the Provider","text":"<p>The <code>Provider</code> component must be added at the root of the application tree in order to use the hooks described below. It can be used to provide a custom configuration for the Self.ID clients, authentication, state and UI options.</p> <pre><code>import { Provider } from '@self.id/framework'\n\nfunction App({ children }) {\nreturn &lt;Provider client={{ ceramic: 'testnet-clay' }}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre>"},{"location":"reference/self-id/modules/framework/#authenticate-the-user","title":"Authenticate the user","text":"<p>The framework provides a React hook to easily initiate an authentication flow for the Viewer (the \"current user\" of the app). This flow is made of the following steps:</p> <p>The user authentication flow consists of the following steps:</p> <ol> <li>An Ethereum authentication provider is created using the Ethereum provider.</li> <li>The auth flow with 3ID Connect starts, using the Ethereum authentication provider.</li> <li>A <code>SelfID</code> instance is created and stored in application state.</li> </ol> <p>Once this flow is successfully applied, the Viewer's cookie is set to the authenticated DID and writing records associated to the Viewer becomes possible.</p> <pre><code>import { EthereumAuthProvider, useViewerConnection } from '@self.id/framework'\n\n// A simple button to initiate the connection flow. A Provider must be present at a higher level\n// in the component tree for the `useViewerConnection()` hook to work.\nfunction ConnectButton() {\nconst [connection, connect, disconnect] = useViewerConnection()\n\nreturn connection.status === 'connected' ? (\n&lt;button\nonClick={() =&gt; {\ndisconnect()\n}}&gt;\nDisconnect ({connection.selfID.id})\n&lt;/button&gt;\n) : 'ethereum' in window ? (\n&lt;button\ndisabled={connection.status === 'connecting'}\nonClick={async () =&gt; {\nconst accounts = await window.ethereum.request({\nmethod: 'eth_requestAccounts',\n})\nawait connect(new EthereumAuthProvider(window.ethereum, accounts[0]))\n}}&gt;\nConnect\n&lt;/button&gt;\n) : (\n&lt;p&gt;\nAn injected Ethereum provider such as{' '}\n&lt;a href=\"https://metamask.io/\"&gt;MetaMask&lt;/a&gt; is needed to authenticate.\n&lt;/p&gt;\n)\n}\n</code></pre>"},{"location":"reference/self-id/modules/framework/#auth-session-management","title":"Auth Session Management","text":"<p>Reference did-session for more examples of managing the session for a user. Following code expands on example above. </p> <pre><code>// ...\nconst [connection, connect, disconnect] = useViewerConnection()\n// ...\n// get session string you serialized and stored before, check if still valid (or how much longer)\nconst sessionStr = ...\nconst selfid = await connect(new EthereumAuthProvider(window.ethereum, accounts[0]), sessionStr)\n// ...\n// get session to serialize and store \nconst session = selfid.client.session //or connection.selfID.client.session\nsession.serialize()\n// ...\n</code></pre>"},{"location":"reference/self-id/modules/framework/#interact-with-a-viewer-record","title":"Interact with a viewer record","text":"<p>The <code>useViewerRecord</code> hook loads the record for a given definition in the index of the current viewer, with the following variants:</p> <ul> <li>If no viewer is set, no record can be loaded</li> <li>If the viewer is not authenticated, the record gets loaded but cannot be mutated</li> <li>If the viewer is authenticated, the record gets loaded and be mutated</li> </ul> <pre><code>import { useViewerRecord } from '@self.id/framework'\n\n// Load and display the record contents\nfunction ShowViewerName() {\nconst record = useViewerRecord('basicProfile')\n\nconst text = record.isLoading\n? 'Loading...'\n: record.content\n? `Hello ${record.content.name || 'stranger'}`\n: 'No profile to load'\nreturn &lt;p&gt;{text}&lt;/p&gt;\n}\n\n// Mutate the record\nfunction SetViewerName() {\nconst record = useViewerRecord('basicProfile')\n\nreturn (\n&lt;button\ndisabled={!record.isMutable || record.isMutating}\nonClick={async () =&gt; {\nawait record.merge({ name: 'Alice' })\n}}&gt;\nSet name\n&lt;/button&gt;\n)\n}\n</code></pre>"},{"location":"reference/self-id/modules/framework/#read-a-public-record","title":"Read a public record","text":"<p>The <code>usePublicRecord</code> hook is similar to the <code>useViewerRecord</code> hook described above, but reading from the index of an explicitly provided account rather than the viewer. Public records are read-only, <code>useViewerRecord</code> must be used in  case mutations are needed.</p> <pre><code>import { usePublicRecord } from '@self.id/framework'\n\nfunction ShowProfileName({ did }) {\nconst record = usePublicRecord('basicProfile', did)\n\nconst text = record.isLoading\n? 'Loading...'\n: record.content\n? `Hello ${record.content.name || 'stranger'}`\n: 'No profile to load'\nreturn &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>"},{"location":"reference/self-id/modules/framework/#upgrading-from-03x-to-04x","title":"Upgrading from 0.3.x to 0.4.x","text":"<p>Version <code>0.4.x</code> switched the default authentication method and libray from 3id-connect with 3ID DIDs to did-session with PKH DIDs. If you wish to upgrade and still use 3id-connect you can pass a flag and configure your provider as follows. There are no other changes in <code>v0.4.x</code>, making upgrading not required at the moment if you dont wish too change auth methods, but PKH DIDs will be the recommended account going forward. </p> <pre><code>import { Provider } from '@self.id/framework'\n\nfunction App({ children }) {\nreturn &lt;Provider client={{ ceramic: 'testnet-clay' }} threeidConnect={true}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre> <p>**Switching authentication methods with out consideration will change DIDs for users and result in any prior data not being resolved. **</p>"},{"location":"reference/self-id/modules/framework/#server-side-prefetching","title":"Server-side prefetching","text":"<p>Server-side rendering can be used to improve the user experience for the first load of an app or page. The framework exports a <code>RequestClient</code> class from the <code>@self.id/react</code> package that can be used to fetch wanted records on the server in order to have them immediately available by the <code>usePublicRecord</code> and <code>useViewerRecord</code> hooks.</p> <p>The following example shows how this can be used in a Next.js page, using the <code>ShowViewerName</code> component created in the previous example:</p> <pre><code>import { Provider, RequestClient } from '@self.id/framework'\n\nexport const getServerSideProps = async (ctx) =&gt; {\nconst client = new RequestClient({\nceramic: 'testnet-clay',\n// Inject the cookie from the request headers to parse the viewerID\ncookie: ctx.req.headers.cookie,\n})\nif (client.viewerID != null) {\n// If the viewerID is set, fetch its profile\nawait client.prefetch('basicProfile', client.viewerID)\n}\nreturn { props: { state: client.getState() } }\n}\n\n// Use the state prop injected by the server\nexport default function Home({ state }) {\nreturn (\n&lt;Provider state={state}&gt;\n&lt;ShowViewerName /&gt;\n&lt;/Provider&gt;\n)\n}\n</code></pre>"},{"location":"reference/self-id/modules/framework/#re-exported-classes","title":"Re-exported classes","text":"<ul> <li><code>core.Core</code></li> <li><code>core.PublicID</code></li> <li><code>react.ReactClient</code></li> <li><code>react.RequestClient</code></li> <li><code>web.SelfID</code></li> <li><code>EthereumAuthProvider</code> from 3ID Connect</li> </ul>"},{"location":"reference/self-id/modules/framework/#type-aliases","title":"Type aliases","text":""},{"location":"reference/self-id/modules/framework/#connectnetwork","title":"ConnectNetwork","text":"<p>\u01ac ConnectNetwork: <code>\"dev-unstable\"</code> | <code>\"mainnet\"</code> | <code>\"testnet-clay\"</code></p> <p>Ceramic networks supported by 3ID Connect.</p>"},{"location":"reference/self-id/modules/framework/#dimensions","title":"Dimensions","text":"<p>\u01ac Dimensions: <code>Object</code></p>"},{"location":"reference/self-id/modules/framework/#type-declaration","title":"Type declaration","text":"Name Type <code>height</code> <code>number</code> <code>width</code> <code>number</code>"},{"location":"reference/self-id/modules/framework/#providerprops","title":"ProviderProps","text":"<p>\u01ac ProviderProps&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>"},{"location":"reference/self-id/modules/framework/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/framework/#type-declaration_1","title":"Type declaration","text":"Name Type Description <code>children</code> <code>ReactNode</code> - <code>client?</code> <code>ReactClient</code>&lt;<code>ModelTypes</code>&gt; | <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt; An instance of <code>ReactClient</code> or <code>client configuration parameters</code>. <code>queryOptions?</code> <code>QueryObserverOptions</code> Custom options for the internal react-query configuration. <code>state?</code> <code>RequestState</code> <code>RequestState</code> emitted by a <code>RequestClient</code> instance."},{"location":"reference/self-id/modules/framework/#publicrecord","title":"PublicRecord","text":"<p>\u01ac PublicRecord&lt;<code>ContentType</code>&gt;: <code>Object</code></p> <p>A PublicRecord provides an interface for interacting with record stored on Ceramic, associated to a given DID string.</p>"},{"location":"reference/self-id/modules/framework/#type-parameters_1","title":"Type parameters","text":"Name <code>ContentType</code>"},{"location":"reference/self-id/modules/framework/#type-declaration_2","title":"Type declaration","text":"Name Type Description <code>content?</code> <code>ContentType</code> Record contents, if loaded. <code>error?</code> <code>unknown</code> Possible error raised when attempting to load the record. <code>isError</code> <code>boolean</code> <code>true</code> when the record failed to load, <code>false</code> otherwise. <code>isLoading</code> <code>boolean</code> <code>true</code> when the record is being loaded, <code>false</code> otherwise."},{"location":"reference/self-id/modules/framework/#requestclientparams","title":"RequestClientParams","text":"<p>\u01ac RequestClientParams&lt;<code>ModelTypes</code>&gt;: <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>cookie?</code>: <code>string</code>  }</p>"},{"location":"reference/self-id/modules/framework/#type-parameters_2","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/framework/#requeststate","title":"RequestState","text":"<p>\u01ac RequestState: <code>Object</code></p>"},{"location":"reference/self-id/modules/framework/#type-declaration_3","title":"Type declaration","text":"Name Type Description <code>hydrate?</code> <code>DehydratedState</code> Serialized records to hydrate. <code>viewerID?</code> <code>string</code> | <code>null</code> Viewer ID extracted from cookie value."},{"location":"reference/self-id/modules/framework/#viewerconnectedcontainerprops","title":"ViewerConnectedContainerProps","text":"<p>\u01ac ViewerConnectedContainerProps: <code>Object</code></p>"},{"location":"reference/self-id/modules/framework/#type-declaration_4","title":"Type declaration","text":"Name Type <code>children</code> <code>ReactNode</code> <code>renderFallback?</code> (<code>connectionState</code>: <code>ViewerConnectionState</code>&lt;<code>ModelTypes</code>&gt;) =&gt; <code>null</code> | <code>Element</code>"},{"location":"reference/self-id/modules/framework/#viewerconnectionstate","title":"ViewerConnectionState","text":"<p>\u01ac ViewerConnectionState&lt;<code>ModelTypes</code>&gt;: { <code>status</code>: <code>\"idle\"</code>  } | { <code>promise</code>: <code>Abortable</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt; ; <code>provider</code>: <code>EthereumAuthProvider</code> ; <code>status</code>: <code>\"connecting\"</code>  } | { <code>selfID</code>: <code>SelfID</code>&lt;<code>ModelTypes</code>&gt; ; <code>status</code>: <code>\"connected\"</code>  } | { <code>error</code>: <code>Error</code> ; <code>status</code>: <code>\"failed\"</code>  }</p> <p>The viewer connection can be in one of the following states, identified by <code>status</code>:</p> <ul> <li><code>idle</code>: no connection has been attempted.</li> <li><code>connecting</code>: attempting to connect using the attached <code>provider</code>. The attached <code>promise</code> can be used to track the connection attempt.</li> <li><code>connected</code>: successfully connected with the attached <code>selfID</code>.</li> <li><code>failed</code>: connection attempted failed with the attached <code>error</code>.</li> </ul>"},{"location":"reference/self-id/modules/framework/#type-parameters_3","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/framework/#viewerrecord","title":"ViewerRecord","text":"<p>\u01ac ViewerRecord&lt;<code>ContentType</code>&gt;: { <code>content?</code>: <code>never</code> ; <code>error?</code>: <code>never</code> ; <code>isError</code>: <code>false</code> ; <code>isLoadable</code>: <code>false</code> ; <code>isLoading</code>: <code>false</code> ; <code>isMutable</code>: <code>false</code> ; <code>isMutating</code>: <code>false</code> ; <code>merge?</code>: <code>never</code> ; <code>set?</code>: <code>never</code>  } | { <code>content?</code>: <code>ContentType</code> ; <code>error?</code>: <code>unknown</code> ; <code>isError</code>: <code>boolean</code> ; <code>isLoadable</code>: <code>true</code> ; <code>isLoading</code>: <code>boolean</code> ; <code>isMutable</code>: <code>boolean</code> ; <code>isMutating</code>: <code>boolean</code> ; <code>merge</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt; ; <code>set</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt;  }</p> <p>A ViewerRecord provides an interface for interacting with record stored on Ceramic, depending on the current <code>ViewerID</code> value:</p> <ul> <li>If <code>null</code>, no interaction is possible with the record.</li> <li>If it is an instance of <code>PublicID</code>, only reads are possible.</li> <li>If it is an instance of <code>SelfID</code>, all interactions (reads and mutations) are possible.</li> </ul> <p>The ViewerRecord object contains the following properties:</p> <ul> <li><code>isLoadable</code>: <code>false</code> if the viewer ID is <code>null</code>, <code>true</code> otherwise.</li> <li><code>isLoading</code>: <code>true</code> when the record is being loaded, <code>false</code> otherwise.</li> <li><code>content</code>: the record contents, if loaded.</li> <li><code>isError</code>: <code>true</code> when the record failed to load, <code>false</code> otherwise.</li> <li><code>error</code>: possible error raised when attempting to load the record.</li> <li><code>isMutable</code>: <code>true</code> if the viewer ID is an instance of <code>SelfID</code>, <code>false</code> otherwise.</li> <li><code>isMutating</code>: <code>true</code> when the record is being mutated as the result of calling the ViewerRecord object <code>merge</code> or <code>set</code> function, <code>false</code> otherwise.</li> <li><code>set</code>: function used to replace the record contents using the <code>set</code> method, only available if <code>isMutating</code> is <code>true</code>.</li> <li><code>merge</code>: function used to merge the record contents using the <code>merge</code> method, only available if <code>isMutating</code> is <code>true</code>.</li> </ul>"},{"location":"reference/self-id/modules/framework/#type-parameters_4","title":"Type parameters","text":"Name <code>ContentType</code>"},{"location":"reference/self-id/modules/framework/#functions","title":"Functions","text":""},{"location":"reference/self-id/modules/framework/#provider","title":"Provider","text":"<p>\u25b8 Provider&lt;<code>ModelTypes</code>&gt;(<code>props</code>): <code>JSX.Element</code></p> <p>Top-level provider component for using Self.ID's React APIs.</p>"},{"location":"reference/self-id/modules/framework/#type-parameters_5","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/framework/#parameters","title":"Parameters","text":"Name Type <code>props</code> <code>ProviderProps</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/modules/framework/#returns","title":"Returns","text":"<p><code>JSX.Element</code></p>"},{"location":"reference/self-id/modules/framework/#viewerconnectedcontainer","title":"ViewerConnectedContainer","text":"<p>\u25b8 ViewerConnectedContainer(<code>props</code>): <code>JSX.Element</code> | <code>null</code></p> <p>Container component for only rendering <code>children</code> when the viewer is connected.</p> <p>A <code>renderFallback</code> function can be provided to render elements when the viewer is not connected. The current <code>ViewerConnectionState</code> is injected as function argument.</p>"},{"location":"reference/self-id/modules/framework/#parameters_1","title":"Parameters","text":"Name Type <code>props</code> <code>ViewerConnectedContainerProps</code>"},{"location":"reference/self-id/modules/framework/#returns_1","title":"Returns","text":"<p><code>JSX.Element</code> | <code>null</code></p>"},{"location":"reference/self-id/modules/framework/#formatdid","title":"formatDID","text":"<p>\u25b8 formatDID(<code>did</code>, <code>maxLength?</code>): <code>string</code></p>"},{"location":"reference/self-id/modules/framework/#parameters_2","title":"Parameters","text":"Name Type Default value <code>did</code> <code>string</code> <code>undefined</code> <code>maxLength</code> <code>number</code> <code>20</code>"},{"location":"reference/self-id/modules/framework/#returns_2","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/self-id/modules/framework/#getimageurl","title":"getImageURL","text":"<p>\u25b8 getImageURL(<code>ipfsPrefix</code>, <code>sources</code>, <code>dimensions</code>): <code>string</code> | <code>undefined</code></p>"},{"location":"reference/self-id/modules/framework/#parameters_3","title":"Parameters","text":"Name Type <code>ipfsPrefix</code> <code>string</code> <code>sources</code> <code>undefined</code> | <code>ImageSources</code> <code>dimensions</code> <code>Dimensions</code>"},{"location":"reference/self-id/modules/framework/#returns_3","title":"Returns","text":"<p><code>string</code> | <code>undefined</code></p>"},{"location":"reference/self-id/modules/framework/#selectimagesource","title":"selectImageSource","text":"<p>\u25b8 selectImageSource(<code>sources</code>, <code>dimensions</code>, <code>mode?</code>): <code>ImageMetadata</code></p> <p>Select the best option from the given <code>sources</code> to match the wanted <code>dimensions</code> and <code>mode</code>.</p>"},{"location":"reference/self-id/modules/framework/#parameters_4","title":"Parameters","text":"Name Type <code>sources</code> <code>ImageSources</code> <code>dimensions</code> <code>Dimensions</code> <code>mode?</code> <code>SizeMode</code>"},{"location":"reference/self-id/modules/framework/#returns_4","title":"Returns","text":"<p><code>ImageMetadata</code></p>"},{"location":"reference/self-id/modules/framework/#uploadimage","title":"uploadImage","text":"<p>\u25b8 uploadImage(<code>url</code>, <code>file</code>, <code>sizes?</code>): <code>Promise</code>&lt;<code>ImageSources</code>&gt;</p> <p>Upload an image to IPFS, optionally with additional alternative <code>sizes</code>.</p>"},{"location":"reference/self-id/modules/framework/#parameters_5","title":"Parameters","text":"Name Type <code>url</code> <code>string</code> <code>file</code> <code>File</code> <code>sizes?</code> <code>Dimensions</code>[]"},{"location":"reference/self-id/modules/framework/#returns_5","title":"Returns","text":"<p><code>Promise</code>&lt;<code>ImageSources</code>&gt;</p>"},{"location":"reference/self-id/modules/framework/#useclient","title":"useClient","text":"<p>\u25b8 useClient&lt;<code>ModelTypes</code>&gt;(): <code>ReactClient</code>&lt;<code>ModelTypes</code>&gt;</p>"},{"location":"reference/self-id/modules/framework/#type-parameters_6","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/framework/#returns_6","title":"Returns","text":"<p><code>ReactClient</code>&lt;<code>ModelTypes</code>&gt;</p>"},{"location":"reference/self-id/modules/framework/#usepublicrecord","title":"usePublicRecord","text":"<p>\u25b8 usePublicRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>, <code>id</code>): <code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p> <p>Hook for accessing the <code>PublicRecord</code> for a given alias and account (DID or CAIP-10).</p>"},{"location":"reference/self-id/modules/framework/#type-parameters_7","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;"},{"location":"reference/self-id/modules/framework/#parameters_6","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code> <code>id</code> <code>string</code>"},{"location":"reference/self-id/modules/framework/#returns_7","title":"Returns","text":"<p><code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/framework/#useviewerconnection","title":"useViewerConnection","text":"<p>\u25b8 useViewerConnection&lt;<code>ModelTypes</code>&gt;(): [<code>ViewerConnectionState</code>&lt;<code>ModelTypes</code>&gt;, (<code>provider</code>: <code>EthereumAuthProvider</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p> <p>Hook for handling the viewer's connection lifecycle, returning the following elements:</p> <ol> <li>The current <code>ViewerConnectionState</code> object.</li> <li>A connection attempt function, taking an <code>EthereumAuthProvider</code> argument.</li> <li>A reset function, clearing the current <code>ViewerID</code>.</li> </ol>"},{"location":"reference/self-id/modules/framework/#type-parameters_8","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/framework/#returns_8","title":"Returns","text":"<p>[<code>ViewerConnectionState</code>&lt;<code>ModelTypes</code>&gt;, (<code>provider</code>: <code>EthereumAuthProvider</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>"},{"location":"reference/self-id/modules/framework/#useviewerid","title":"useViewerID","text":"<p>\u25b8 useViewerID&lt;<code>ModelTypes</code>&gt;(): <code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>"},{"location":"reference/self-id/modules/framework/#type-parameters_9","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/framework/#returns_9","title":"Returns","text":"<p><code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>"},{"location":"reference/self-id/modules/framework/#useviewerrecord","title":"useViewerRecord","text":"<p>\u25b8 useViewerRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>): <code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p> <p>Hook for accessing the <code>ViewerRecord</code> for a given alias.</p>"},{"location":"reference/self-id/modules/framework/#type-parameters_10","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;"},{"location":"reference/self-id/modules/framework/#parameters_7","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code>"},{"location":"reference/self-id/modules/framework/#returns_10","title":"Returns","text":"<p><code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/image_utils/","title":"Module: image-utils","text":"<p>Image utilities for Self.ID profiles.</p>"},{"location":"reference/self-id/modules/image_utils/#purpose","title":"Purpose","text":"<p>The <code>image-utils</code> module provides various utility functions for images, such as selecting the most suitable format among sources, resizing and uploading, and is mostly meant to be used in a Web browser context.</p>"},{"location":"reference/self-id/modules/image_utils/#installation","title":"Installation","text":"<pre><code>npm install @self.id/image-utils\n</code></pre>"},{"location":"reference/self-id/modules/image_utils/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/self-id/modules/image_utils/#resize-and-upload-an-image-to-multiple-dimensions","title":"Resize and upload an image to multiple dimensions","text":"<p>Using a <code>SelfID</code> instance from the <code>web</code> module.</p> <pre><code>import { uploadImage } from '@self.id/image-utils'\n\n// The `file` argument must implement the File interface from\n// https://developer.mozilla.org/en-US/docs/Web/API/File\nasync function setProfileImage(selfID, file) {\nconst imageSources = await uploadFile(\n'https://ipfs.infura.io:5001/api/v0',\nfile,\n[{ width: 60, height: 60 }, { width: 200, height: 200 }],\n)\n// Here `selfID` must be an instance of `SelfID` from the `web` module\nawait selfID.merge({ image: imageSources })\n}\n</code></pre>"},{"location":"reference/self-id/modules/image_utils/#get-the-most-suitable-image-source-for-given-dimensions","title":"Get the most suitable image source for given dimensions","text":"<p>Using a <code>Core</code> instance from the <code>core</code> module.</p> <pre><code>import { Core } from '@self.id/core'\nimport { selectImageSource } from '@self.id/image-utils'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n\nasync function getAvatarSource(did) {\nconst profile = await core.get('basicProfile', did)\nreturn profile?.image ? selectImageSource(profile.image, { width: 60, height: 60 }) : null\n}\n</code></pre>"},{"location":"reference/self-id/modules/image_utils/#type-aliases","title":"Type aliases","text":""},{"location":"reference/self-id/modules/image_utils/#dimensions","title":"Dimensions","text":"<p>\u01ac Dimensions: <code>Object</code></p>"},{"location":"reference/self-id/modules/image_utils/#type-declaration","title":"Type declaration","text":"Name Type <code>height</code> <code>number</code> <code>width</code> <code>number</code>"},{"location":"reference/self-id/modules/image_utils/#sizemode","title":"SizeMode","text":"<p>\u01ac SizeMode: <code>\"contain\"</code> | <code>\"cover\"</code></p> <p>Image size modes:</p> <ul> <li>\"contain\" = the image fits in the container</li> <li>\"cover\" = the image fills the container</li> </ul>"},{"location":"reference/self-id/modules/image_utils/#sizedimage","title":"SizedImage","text":"<p>\u01ac SizedImage: <code>Dimensions</code> &amp; { <code>blob</code>: <code>Blob</code>  }</p>"},{"location":"reference/self-id/modules/image_utils/#functions","title":"Functions","text":""},{"location":"reference/self-id/modules/image_utils/#loadimage","title":"loadImage","text":"<p>\u25b8 loadImage(<code>blob</code>): <code>Promise</code>&lt;<code>HTMLImageElement</code>&gt;</p> <p>Load a <code>blob</code> image to an HTML Image element.</p>"},{"location":"reference/self-id/modules/image_utils/#parameters","title":"Parameters","text":"Name Type <code>blob</code> <code>Blob</code>"},{"location":"reference/self-id/modules/image_utils/#returns","title":"Returns","text":"<p><code>Promise</code>&lt;<code>HTMLImageElement</code>&gt;</p>"},{"location":"reference/self-id/modules/image_utils/#selectimagesource","title":"selectImageSource","text":"<p>\u25b8 selectImageSource(<code>sources</code>, <code>dimensions</code>, <code>mode?</code>): <code>ImageMetadata</code></p> <p>Select the best option from the given <code>sources</code> to match the wanted <code>dimensions</code> and <code>mode</code>.</p>"},{"location":"reference/self-id/modules/image_utils/#parameters_1","title":"Parameters","text":"Name Type Default value <code>sources</code> <code>ImageSources</code> <code>undefined</code> <code>dimensions</code> <code>Dimensions</code> <code>undefined</code> <code>mode</code> <code>SizeMode</code> <code>'cover'</code>"},{"location":"reference/self-id/modules/image_utils/#returns_1","title":"Returns","text":"<p><code>ImageMetadata</code></p>"},{"location":"reference/self-id/modules/image_utils/#uploadfile","title":"uploadFile","text":"<p>\u25b8 uploadFile(<code>url</code>, <code>blob</code>, <code>fileName?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p> <p>Upload the <code>blob</code> file to the given IPFS server <code>url</code>, using the optionally given <code>fileName</code>.</p>"},{"location":"reference/self-id/modules/image_utils/#parameters_2","title":"Parameters","text":"Name Type <code>url</code> <code>string</code> <code>blob</code> <code>Blob</code> <code>fileName?</code> <code>string</code>"},{"location":"reference/self-id/modules/image_utils/#returns_2","title":"Returns","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>"},{"location":"reference/self-id/modules/image_utils/#uploadimage","title":"uploadImage","text":"<p>\u25b8 uploadImage(<code>url</code>, <code>file</code>, <code>sizes?</code>): <code>Promise</code>&lt;<code>ImageSources</code>&gt;</p> <p>Upload an image to IPFS, optionally with additional alternative <code>sizes</code>.</p>"},{"location":"reference/self-id/modules/image_utils/#parameters_3","title":"Parameters","text":"Name Type Default value <code>url</code> <code>string</code> <code>undefined</code> <code>file</code> <code>File</code> <code>undefined</code> <code>sizes</code> <code>Dimensions</code>[] <code>[]</code>"},{"location":"reference/self-id/modules/image_utils/#returns_3","title":"Returns","text":"<p><code>Promise</code>&lt;<code>ImageSources</code>&gt;</p>"},{"location":"reference/self-id/modules/image_utils/#uploadresizedimage","title":"uploadResizedImage","text":"<p>\u25b8 uploadResizedImage(<code>url</code>, <code>type</code>, <code>image</code>, <code>dimensions?</code>): <code>Promise</code>&lt;<code>ImageMetadata</code>&gt;</p> <p>Resize an image and upload it to IPFS.</p>"},{"location":"reference/self-id/modules/image_utils/#parameters_4","title":"Parameters","text":"Name Type <code>url</code> <code>string</code> <code>type</code> <code>string</code> <code>image</code> <code>HTMLImageElement</code> <code>dimensions?</code> <code>Dimensions</code>"},{"location":"reference/self-id/modules/image_utils/#returns_4","title":"Returns","text":"<p><code>Promise</code>&lt;<code>ImageMetadata</code>&gt;</p>"},{"location":"reference/self-id/modules/react/","title":"Module: react","text":"<p>React hooks and utilities for authentication and records interactions.</p>"},{"location":"reference/self-id/modules/react/#purpose","title":"Purpose","text":"<p>The <code>react</code> module provides React components, hooks and related utility functions to help manage authentication and interactions with records, similar to the <code>web</code> module but designed specifically to be used with React.</p>"},{"location":"reference/self-id/modules/react/#installation","title":"Installation","text":"<pre><code>npm install @self.id/react\n</code></pre>"},{"location":"reference/self-id/modules/react/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/self-id/modules/react/#configure-the-provider","title":"Configure the Provider","text":"<p>The <code>Provider</code> component must be added at the root of the application tree in order to use the hooks described below. It can be used to provide a custom configuration for the Self.ID clients and queries, as well as initial state.</p> <pre><code>import { Provider } from '@self.id/react'\n\nfunction App({ children }) {\nreturn &lt;Provider client={{ ceramic: 'testnet-clay' }}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre>"},{"location":"reference/self-id/modules/react/#authenticate-the-user","title":"Authenticate the user","text":"<p>The module provides a React hook to easily initiate an authentication flow for the Viewer (the \"current user\" of the app) using an <code>EthereumAuthProvider</code> instance, notably exported by the <code>web</code> module. Once authenticated, the Viewer's cookie is set to the authenticated DID and writing records associated to the Viewer becomes possible.</p> <pre><code>import { useViewerConnection } from '@self.id/react'\nimport { EthereumAuthProvider } from '@self.id/web'\n\nasync function createAuthProvider() {\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({ method: 'eth_requestAccounts' })\nreturn new EthereumAuthProvider(window.ethereum, addresses[0])\n}\n\n// A simple button to initiate the connection flow. A Provider must be present at a higher level\n// in the component tree for the `useViewerConnection()` hook to work.\nfunction ConnectButton() {\nconst [connection, connect, disconnect] = useViewerConnection()\n\nreturn connection.status === 'connected' ? (\n&lt;button\nonClick={() =&gt; {\ndisconnect()\n}}&gt;\nDisconnect ({connection.selfID.id})\n&lt;/button&gt;\n) : 'ethereum' in window ? (\n&lt;button\ndisabled={connection.status === 'connecting'}\nonClick={() =&gt; {\ncreateAuthProvider().then(connect)\n}}&gt;\nConnect\n&lt;/button&gt;\n) : (\n&lt;p&gt;\nAn injected Ethereum provider such as{' '}\n&lt;a href=\"https://metamask.io/\"&gt;MetaMask&lt;/a&gt; is needed to authenticate.\n&lt;/p&gt;\n)\n}\n</code></pre>"},{"location":"reference/self-id/modules/react/#auth-session-management","title":"Auth Session Management","text":"<p>Reference did-session for more examples of managing the session for a user. Following code expands on example above. </p> <pre><code>// ...\nconst [connection, connect, disconnect] = useViewerConnection()\n// ...\n// get session string you serialized and stored before, check if still valid (or how much longer)\nconst sessionStr = ...\nconst selfid = await connect(new EthereumAuthProvider(window.ethereum, accounts[0]), sessionStr)\n// ...\n// get session to serialize and store \nconst session = selfid.client.session //or connection.selfID.client.session\nsession.serialize()\n// ...\n</code></pre>"},{"location":"reference/self-id/modules/react/#read-a-viewer-record","title":"Read a viewer record","text":"<p>The <code>useViewerRecord</code> hook loads the record for a given definition in the index of the current viewer, with the following variants:</p> <ul> <li>If no viewer is set, no record can be loaded</li> <li>If the viewer is not authenticated, the record gets loaded but cannot be mutated</li> <li>If the viewer is authenticated, the record gets loaded and be mutated</li> </ul> <pre><code>import { useViewerRecord } from '@self.id/react'\n\nfunction ShowViewerName() {\nconst record = useViewerRecord('basicProfile')\n\nconst text = record.isLoading\n? 'Loading...'\n: record.content\n? `Hello ${record.content.name || 'stranger'}`\n: 'No profile to load'\nreturn &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>"},{"location":"reference/self-id/modules/react/#read-a-public-record","title":"Read a public record","text":"<p>The <code>usePublicRecord</code> hook is similar to the <code>useViewerRecord</code> hook described above, but reading from the index of an explicitly provided account rather than the viewer. Public records are read-only, <code>useViewerRecord</code> must be used in  case mutations are needed.</p> <pre><code>import { usePublicRecord } from '@self.id/react'\n\nfunction ShowProfileName({ did }) {\nconst record = usePublicRecord('basicProfile', did)\n\nconst text = record.isLoading\n? 'Loading...'\n: record.content\n? `Hello ${record.content.name || 'stranger'}`\n: 'No profile to load'\nreturn &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>"},{"location":"reference/self-id/modules/react/#upgrading-from-03x-to-04x","title":"Upgrading from 0.3.x to 0.4.x","text":"<p>Version <code>0.4.x</code> switched the default authentication method and libray from 3id-connect with 3ID DIDs to did-session with PKH DIDs. If you wish to upgrade and still use 3id-connect you can pass a flag and configure your provider as follows. There are no other changes in <code>v0.4.x</code>, making upgrading not required at the moment if you dont wish too change auth methods, but PKH DIDs will be the recommended account going forward. </p> <pre><code>import { Provider } from '@self.id/framework'\n\nfunction App({ children }) {\nreturn &lt;Provider client={{ ceramic: 'testnet-clay' }} threeidConnect={true}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre> <p>**Switching authentication methods with out consideration will change DIDs for users and result in any prior data not being resolved. **</p>"},{"location":"reference/self-id/modules/react/#server-side-prefetching","title":"Server-side prefetching","text":"<p>Server-side rendering can be used to improve the user experience for the first load of an app or page. The module exports a <code>RequestClient</code> class that can be used to fetch wanted records on the server in order to have them immediately available by the <code>usePublicRecord</code> and <code>useViewerRecord</code> hooks.</p> <p>The following example shows how this can be used in a Next.js page, using the <code>ShowViewerName</code> component created in the previous example:</p> <pre><code>import { Provider, RequestClient } from '@self.id/react'\n\nexport const getServerSideProps = async (ctx) =&gt; {\nconst client = new RequestClient({\nceramic: 'testnet-clay',\n// Inject the cookie from the request headers to parse the viewerID\ncookie: ctx.req.headers.cookie,\n})\nif (client.viewerID != null) {\n// If the viewerID is set, fetch its profile\nawait client.prefetch('basicProfile', client.viewerID)\n}\nreturn { props: { state: client.getState() } }\n}\n\n// Use the state prop injected by the server\nexport default function Home({ state }) {\nreturn (\n&lt;Provider state={state}&gt;\n&lt;ShowViewerName /&gt;\n&lt;/Provider&gt;\n)\n}\n</code></pre>"},{"location":"reference/self-id/modules/react/#classes","title":"Classes","text":"<ul> <li>ReactClient</li> <li>RequestClient</li> </ul>"},{"location":"reference/self-id/modules/react/#type-aliases","title":"Type aliases","text":""},{"location":"reference/self-id/modules/react/#providerprops","title":"ProviderProps","text":"<p>\u01ac ProviderProps&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>"},{"location":"reference/self-id/modules/react/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/react/#type-declaration","title":"Type declaration","text":"Name Type Description <code>children</code> <code>ReactNode</code> - <code>client?</code> <code>ReactClient</code>&lt;<code>ModelTypes</code>&gt; | <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt; An instance of <code>ReactClient</code> or <code>client configuration parameters</code>. <code>queryOptions?</code> <code>QueryObserverOptions</code> Custom options for the internal react-query configuration. <code>state?</code> <code>RequestState</code> <code>RequestState</code> emitted by a <code>RequestClient</code> instance."},{"location":"reference/self-id/modules/react/#publicrecord","title":"PublicRecord","text":"<p>\u01ac PublicRecord&lt;<code>ContentType</code>&gt;: <code>Object</code></p> <p>A PublicRecord provides an interface for interacting with record stored on Ceramic, associated to a given DID string.</p>"},{"location":"reference/self-id/modules/react/#type-parameters_1","title":"Type parameters","text":"Name <code>ContentType</code>"},{"location":"reference/self-id/modules/react/#type-declaration_1","title":"Type declaration","text":"Name Type Description <code>content?</code> <code>ContentType</code> Record contents, if loaded. <code>error?</code> <code>unknown</code> Possible error raised when attempting to load the record. <code>isError</code> <code>boolean</code> <code>true</code> when the record failed to load, <code>false</code> otherwise. <code>isLoading</code> <code>boolean</code> <code>true</code> when the record is being loaded, <code>false</code> otherwise."},{"location":"reference/self-id/modules/react/#requestclientparams","title":"RequestClientParams","text":"<p>\u01ac RequestClientParams&lt;<code>ModelTypes</code>&gt;: <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>cookie?</code>: <code>string</code>  }</p>"},{"location":"reference/self-id/modules/react/#type-parameters_2","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/react/#requeststate","title":"RequestState","text":"<p>\u01ac RequestState: <code>Object</code></p>"},{"location":"reference/self-id/modules/react/#type-declaration_2","title":"Type declaration","text":"Name Type Description <code>hydrate?</code> <code>DehydratedState</code> Serialized records to hydrate. <code>viewerID?</code> <code>string</code> | <code>null</code> Viewer ID extracted from cookie value."},{"location":"reference/self-id/modules/react/#viewerconnectedcontainerprops","title":"ViewerConnectedContainerProps","text":"<p>\u01ac ViewerConnectedContainerProps: <code>Object</code></p>"},{"location":"reference/self-id/modules/react/#type-declaration_3","title":"Type declaration","text":"Name Type <code>children</code> <code>ReactNode</code> <code>renderFallback?</code> (<code>connectionState</code>: <code>ViewerConnectionState</code>&lt;<code>ModelTypes</code>&gt;) =&gt; <code>null</code> | <code>Element</code>"},{"location":"reference/self-id/modules/react/#viewerconnectionstate","title":"ViewerConnectionState","text":"<p>\u01ac ViewerConnectionState&lt;<code>ModelTypes</code>&gt;: { <code>status</code>: <code>\"idle\"</code>  } | { <code>promise</code>: <code>Abortable</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt; ; <code>provider</code>: <code>EthereumAuthProvider</code> ; <code>status</code>: <code>\"connecting\"</code>  } | { <code>selfID</code>: <code>SelfID</code>&lt;<code>ModelTypes</code>&gt; ; <code>status</code>: <code>\"connected\"</code>  } | { <code>error</code>: <code>Error</code> ; <code>status</code>: <code>\"failed\"</code>  }</p> <p>The viewer connection can be in one of the following states, identified by <code>status</code>:</p> <ul> <li><code>idle</code>: no connection has been attempted.</li> <li><code>connecting</code>: attempting to connect using the attached <code>provider</code>. The attached <code>promise</code> can be used to track the connection attempt.</li> <li><code>connected</code>: successfully connected with the attached <code>selfID</code>.</li> <li><code>failed</code>: connection attempted failed with the attached <code>error</code>.</li> </ul>"},{"location":"reference/self-id/modules/react/#type-parameters_3","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/react/#viewerid","title":"ViewerID","text":"<p>\u01ac ViewerID&lt;<code>ModelTypes</code>&gt;: <code>PublicID</code>&lt;<code>ModelTypes</code>&gt; | <code>SelfID</code>&lt;<code>ModelTypes</code>&gt;</p> <p>A ViewerID can be either a <code>SelfID</code> or <code>PublicID</code> instance depending on the current <code>ViewerConnectionState</code>.</p>"},{"location":"reference/self-id/modules/react/#type-parameters_4","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>"},{"location":"reference/self-id/modules/react/#viewerrecord","title":"ViewerRecord","text":"<p>\u01ac ViewerRecord&lt;<code>ContentType</code>&gt;: { <code>content?</code>: <code>never</code> ; <code>error?</code>: <code>never</code> ; <code>isError</code>: <code>false</code> ; <code>isLoadable</code>: <code>false</code> ; <code>isLoading</code>: <code>false</code> ; <code>isMutable</code>: <code>false</code> ; <code>isMutating</code>: <code>false</code> ; <code>merge?</code>: <code>never</code> ; <code>set?</code>: <code>never</code>  } | { <code>content?</code>: <code>ContentType</code> ; <code>error?</code>: <code>unknown</code> ; <code>isError</code>: <code>boolean</code> ; <code>isLoadable</code>: <code>true</code> ; <code>isLoading</code>: <code>boolean</code> ; <code>isMutable</code>: <code>boolean</code> ; <code>isMutating</code>: <code>boolean</code> ; <code>merge</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt; ; <code>set</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt;  }</p> <p>A ViewerRecord provides an interface for interacting with record stored on Ceramic, depending on the current <code>ViewerID</code> value:</p> <ul> <li>If <code>null</code>, no interaction is possible with the record.</li> <li>If it is an instance of <code>PublicID</code>, only reads are possible.</li> <li>If it is an instance of <code>SelfID</code>, all interactions (reads and mutations) are possible.</li> </ul> <p>The ViewerRecord object contains the following properties:</p> <ul> <li><code>isLoadable</code>: <code>false</code> if the viewer ID is <code>null</code>, <code>true</code> otherwise.</li> <li><code>isLoading</code>: <code>true</code> when the record is being loaded, <code>false</code> otherwise.</li> <li><code>content</code>: the record contents, if loaded.</li> <li><code>isError</code>: <code>true</code> when the record failed to load, <code>false</code> otherwise.</li> <li><code>error</code>: possible error raised when attempting to load the record.</li> <li><code>isMutable</code>: <code>true</code> if the viewer ID is an instance of <code>SelfID</code>, <code>false</code> otherwise.</li> <li><code>isMutating</code>: <code>true</code> when the record is being mutated as the result of calling the ViewerRecord object <code>merge</code> or <code>set</code> function, <code>false</code> otherwise.</li> <li><code>set</code>: function used to replace the record contents using the <code>set</code> method, only available if <code>isMutating</code> is <code>true</code>.</li> <li><code>merge</code>: function used to merge the record contents using the <code>merge</code> method, only available if <code>isMutating</code> is <code>true</code>.</li> </ul>"},{"location":"reference/self-id/modules/react/#type-parameters_5","title":"Type parameters","text":"Name <code>ContentType</code>"},{"location":"reference/self-id/modules/react/#functions","title":"Functions","text":""},{"location":"reference/self-id/modules/react/#provider","title":"Provider","text":"<p>\u25b8 Provider&lt;<code>ModelTypes</code>&gt;(<code>props</code>): <code>JSX.Element</code></p> <p>Top-level provider component for using Self.ID's React APIs.</p>"},{"location":"reference/self-id/modules/react/#type-parameters_6","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/react/#parameters","title":"Parameters","text":"Name Type <code>props</code> <code>ProviderProps</code>&lt;<code>ModelTypes</code>&gt;"},{"location":"reference/self-id/modules/react/#returns","title":"Returns","text":"<p><code>JSX.Element</code></p>"},{"location":"reference/self-id/modules/react/#viewerconnectedcontainer","title":"ViewerConnectedContainer","text":"<p>\u25b8 ViewerConnectedContainer(<code>props</code>): <code>JSX.Element</code> | <code>null</code></p> <p>Container component for only rendering <code>children</code> when the viewer is connected.</p> <p>A <code>renderFallback</code> function can be provided to render elements when the viewer is not connected. The current <code>ViewerConnectionState</code> is injected as function argument.</p>"},{"location":"reference/self-id/modules/react/#parameters_1","title":"Parameters","text":"Name Type <code>props</code> <code>ViewerConnectedContainerProps</code>"},{"location":"reference/self-id/modules/react/#returns_1","title":"Returns","text":"<p><code>JSX.Element</code> | <code>null</code></p>"},{"location":"reference/self-id/modules/react/#getcookieviewerid","title":"getCookieViewerID","text":"<p>\u25b8 getCookieViewerID(<code>cookie?</code>): <code>string</code> | <code>null</code></p> <p>Extract the possible viewer ID value from the given cookie string value.</p>"},{"location":"reference/self-id/modules/react/#parameters_2","title":"Parameters","text":"Name Type <code>cookie?</code> <code>string</code>"},{"location":"reference/self-id/modules/react/#returns_2","title":"Returns","text":"<p><code>string</code> | <code>null</code></p>"},{"location":"reference/self-id/modules/react/#useclient","title":"useClient","text":"<p>\u25b8 useClient&lt;<code>ModelTypes</code>&gt;(): <code>ReactClient</code>&lt;<code>ModelTypes</code>&gt;</p>"},{"location":"reference/self-id/modules/react/#type-parameters_7","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/react/#returns_3","title":"Returns","text":"<p><code>ReactClient</code>&lt;<code>ModelTypes</code>&gt;</p>"},{"location":"reference/self-id/modules/react/#usepublicrecord","title":"usePublicRecord","text":"<p>\u25b8 usePublicRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>, <code>id</code>): <code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p> <p>Hook for accessing the <code>PublicRecord</code> for a given alias and account (DID or CAIP-10).</p>"},{"location":"reference/self-id/modules/react/#type-parameters_8","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;"},{"location":"reference/self-id/modules/react/#parameters_3","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code> <code>id</code> <code>string</code>"},{"location":"reference/self-id/modules/react/#returns_4","title":"Returns","text":"<p><code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/react/#useviewerconnection","title":"useViewerConnection","text":"<p>\u25b8 useViewerConnection&lt;<code>ModelTypes</code>&gt;(): [<code>ViewerConnectionState</code>&lt;<code>ModelTypes</code>&gt;, (<code>provider</code>: <code>EthereumAuthProvider</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p> <p>Hook for handling the viewer's connection lifecycle, returning the following elements:</p> <ol> <li>The current <code>ViewerConnectionState</code> object.</li> <li>A connection attempt function, taking an <code>EthereumAuthProvider</code> argument.</li> <li>A reset function, clearing the current <code>ViewerID</code>.</li> </ol>"},{"location":"reference/self-id/modules/react/#type-parameters_9","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/react/#returns_5","title":"Returns","text":"<p>[<code>ViewerConnectionState</code>&lt;<code>ModelTypes</code>&gt;, (<code>provider</code>: <code>EthereumAuthProvider</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>"},{"location":"reference/self-id/modules/react/#useviewerid","title":"useViewerID","text":"<p>\u25b8 useViewerID&lt;<code>ModelTypes</code>&gt;(): <code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>"},{"location":"reference/self-id/modules/react/#type-parameters_10","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>"},{"location":"reference/self-id/modules/react/#returns_6","title":"Returns","text":"<p><code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>"},{"location":"reference/self-id/modules/react/#useviewerrecord","title":"useViewerRecord","text":"<p>\u25b8 useViewerRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>): <code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p> <p>Hook for accessing the <code>ViewerRecord</code> for a given alias.</p>"},{"location":"reference/self-id/modules/react/#type-parameters_11","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code> <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;"},{"location":"reference/self-id/modules/react/#parameters_4","title":"Parameters","text":"Name Type <code>alias</code> <code>Alias</code>"},{"location":"reference/self-id/modules/react/#returns_7","title":"Returns","text":"<p><code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>"},{"location":"reference/self-id/modules/web/","title":"Module: web","text":"<p>Read and write records in browsers environments.</p>"},{"location":"reference/self-id/modules/web/#purpose","title":"Purpose","text":"<p>The <code>web</code> module of the Self.ID SDK exports the <code>WebClient</code> and <code>SelfID</code> classes to provide APIs for authenticating a DID to allow writing records, in addition to reading them.</p> <p>DID authentication leverages DID Session, which only works in browsers, therefore the <code>web</code> module can only be used in browsers. The <code>core</code> module can be used to read public records in browsers as well as Node environments.</p>"},{"location":"reference/self-id/modules/web/#installation","title":"Installation","text":"<pre><code>npm install @self.id/web\n</code></pre>"},{"location":"reference/self-id/modules/web/#common-use-cases","title":"Common use-cases","text":""},{"location":"reference/self-id/modules/web/#authenticate-and-write-a-record","title":"Authenticate and write a record","text":"<pre><code>import { EthereumAuthProvider, SelfID } from '@self.id/web'\n\nasync function createSelfID() {\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({ method: 'eth_requestAccounts' })\n\nreturn await SelfID.authenticate({\nauthProvider: new EthereumAuthProvider(window.ethereum, addresses[0]),\nceramic: 'testnet-clay',\n})\n}\n\nasync function setBasicProfile(selfID) {\n// Use the SelfID instance created by the `createSelfID()` function\nawait selfID.set('basicProfile', { name: 'Alice' })\n}\n</code></pre> <p>To use with 3id-connect instead of did-session you can pass a configuration flag and the 3id-connect network. It is recommended to use with did-session.</p> <pre><code>await SelfID.authenticate({\nauthProvider: new EthereumAuthProvider(window.ethereum, addresses[0]),\nceramic: 'testnet-clay',\n// Make sure the `ceramic` and `connectNetwork` parameter connect to the same network\nconnectNetwork: 'testnet-clay',\nthreeidConnect: true\n})\n</code></pre>"},{"location":"reference/self-id/modules/web/#re-exported-classes","title":"Re-exported classes","text":"<ul> <li><code>EthereumAuthProvider</code> from 3ID Connect</li> </ul>"},{"location":"reference/self-id/modules/web/#classes","title":"Classes","text":"<ul> <li>SelfID</li> <li>WebClient</li> </ul>"},{"location":"reference/self-id/modules/web/#type-aliases","title":"Type aliases","text":""},{"location":"reference/self-id/modules/web/#authenticateparams","title":"AuthenticateParams","text":"<p>\u01ac AuthenticateParams&lt;<code>ModelTypes</code>&gt;: <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>authProvider</code>: <code>EthereumAuthProvider</code>  }</p>"},{"location":"reference/self-id/modules/web/#type-parameters","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/web/#connectnetwork","title":"ConnectNetwork","text":"<p>\u01ac ConnectNetwork: <code>\"dev-unstable\"</code> | <code>\"mainnet\"</code> | <code>\"testnet-clay\"</code></p> <p>Ceramic networks supported by 3ID Connect.</p>"},{"location":"reference/self-id/modules/web/#selfidparams","title":"SelfIDParams","text":"<p>\u01ac SelfIDParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>"},{"location":"reference/self-id/modules/web/#type-parameters_1","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/self-id/modules/web/#type-declaration","title":"Type declaration","text":"Name Type Description <code>client</code> <code>WebClient</code>&lt;<code>ModelTypes</code>&gt; <code>WebClient</code> instance to use. It must have an authenticated DID attached to it."},{"location":"reference/self-id/modules/web/#webclientparams","title":"WebClientParams","text":"<p>\u01ac WebClientParams&lt;<code>ModelTypes</code>&gt;: <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>connectNetwork?</code>: <code>ConnectNetwork</code>  }</p>"},{"location":"reference/self-id/modules/web/#type-parameters_2","title":"Type parameters","text":"Name Type <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>"},{"location":"reference/stream-programs/caip10-link/","title":"CAIP-10 Link client","text":"<p>A CAIP-10 Link is a stream that stores a proof that links a blockchain address to a Ceramic account (DID), using the CAIP-10 standard to represent blockchain addresses.</p> <p>The <code>stream-caip10-link</code> module export a <code>Caip10Link</code> class used to link and unlink a DID to a CAIP-10 address using the CIP-7 \"CAIP-10 Link\" program.</p>"},{"location":"reference/stream-programs/caip10-link/#installation","title":"Installation","text":"<pre><code>npm install @ceramicnetwork/stream-caip10-link\n</code></pre>"},{"location":"reference/stream-programs/caip10-link/#additional-requirements","title":"Additional requirements","text":"<ul> <li>In order to load CAIP-10 Links, a Ceramic client instance must be available</li> <li>To add/remove links, the client must also have an authenticated DID</li> <li>An authentication provider is needed to sign the payload for the given CAIP-10 account, using the <code>blockchain-utils-linking</code> module that should be installed as needed:</li> </ul> <pre><code>npm install @ceramicnetwork/blockchain-utils-linking\n</code></pre>"},{"location":"reference/stream-programs/caip10-link/#common-usage","title":"Common usage","text":""},{"location":"reference/stream-programs/caip10-link/#load-a-link","title":"Load a link","text":"<p>In this example we load a Caip10Link for the account <code>0x054...7cb8</code> on the Ethereum mainnet blockchain (<code>eip155:1</code>).</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { Caip10Link } from '@ceramicnetwork/stream-caip10-link'\n\nconst ceramic = new CeramicClient()\n\nasync function getLinkedDID() {\n// Using the Ceramic client instance, we can load the link for a given CAIP-10 account\nconst link = await Caip10Link.fromAccount(\nceramic,\n'0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8@eip155:1',\n)\n// The `did` property of the loaded link will contain the DID string value if set\nreturn link.did\n}\n</code></pre>"},{"location":"reference/stream-programs/caip10-link/#create-a-link","title":"Create a link","text":"<p>Here we can see the full flow of getting a user's Ethereum address, creating a link, and adding the users' DID account.</p> <p>In this example we create a Caip10Link for the account <code>0x054...7cb8</code> on the Ethereum mainnet blockchain (<code>eip155:1</code>) and then associate it with the DID <code>did:3:k2t6...ydki</code>.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { Caip10Link } from '@ceramicnetwork/stream-caip10-link'\nimport { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'\n\nconst ceramic = new CeramicClient()\n\nasync function linkCurrentAddress() {\n// First, we need to create an EthereumAuthProvider with the account currently selected\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({\nmethod: 'eth_requestAccounts',\n})\nconst authProvider = new EthereumAuthProvider(window.ethereum, addresses[0])\n\n// Retrieve the CAIP-10 account from the EthereumAuthProvider instance\nconst accountId = await authProvider.accountId()\n\n// Load the account link based on the account ID\nconst accountLink = await Caip10Link.fromAccount(\nceramic,\naccountId.toString(),\n)\n\n// Finally, link the DID to the account using the EthereumAuthProvider instance\nawait accountLink.setDid(\n'did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki',\nauthProvider,\n)\n}\n</code></pre>"},{"location":"reference/stream-programs/caip10-link/#remove-a-link","title":"Remove a link","text":"<p>Removing a link involves a similar flow to setting the DID, but using the <code>clearDid</code> method instead of <code>setDid</code>:</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { Caip10Link } from '@ceramicnetwork/stream-caip10-link'\nimport { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'\n\nconst ceramic = new CeramicClient()\n\nasync function unlinkCurrentAddress() {\n// First, we need to create an EthereumAuthProvider with the account currently selected\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({\nmethod: 'eth_requestAccounts',\n})\nconst authProvider = new EthereumAuthProvider(window.ethereum, addresses[0])\n\n// Retrieve the CAIP-10 account from the EthereumAuthProvider instance\nconst accountId = await authProvider.accountId()\n\n// Load the account link based on the account ID\nconst accountLink = await Caip10Link.fromAccount(\nceramic,\naccountId.toString(),\n)\n\n// Finally, unlink the DID from the account using the EthereumAuthProvider instance\nawait accountLink.clearDid(authProvider)\n}\n</code></pre>"},{"location":"reference/stream-programs/tile-document/","title":"TileDocument client","text":"<p>The <code>stream-tile</code> module exports a <code>TileDocument</code> class used to store and load JSON documents using the CIP-8 \"Tile Document\" streamcode, as well a provide accessors to the contents and metadata of a given version of the stream.</p>"},{"location":"reference/stream-programs/tile-document/#installation","title":"Installation","text":"<pre><code>npm install @ceramicnetwork/stream-tile\n</code></pre>"},{"location":"reference/stream-programs/tile-document/#additional-requirements","title":"Additional requirements","text":"<ul> <li>In order to load Tile documents, a Ceramic client instance must be available</li> <li>To create/update documents, the client must have an authenticated DID</li> </ul>"},{"location":"reference/stream-programs/tile-document/#common-usage","title":"Common usage","text":""},{"location":"reference/stream-programs/tile-document/#load-a-document","title":"Load a document","text":"<pre><code>// Import the Ceramic and Tile document clients\nimport { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\n\n// Connect to a Ceramic node\nconst ceramic = new CeramicClient()\n\n// The `id` argument can be a stream ID (to load the latest version)\n// or a commit ID (to load a specific version)\nasync function load(id) {\nreturn await TileDocument.load(ceramic, id)\n}\n</code></pre>"},{"location":"reference/stream-programs/tile-document/#create-a-document","title":"Create a document","text":"<p>In order to create a document, an authenticated DID needs to be attached to the Ceramic client instance to enable transactions (signing commits).</p> <p>The following example uses the ed25519 Key DID provider for simplicity, but creating documents can be done using any supported DID provider.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\nconst provider = new Ed25519Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\n// Authenticate the DID with the provider\nawait did.authenticate()\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n\nasync function createDocument(content) {\n// The following call will fail if the Ceramic instance does not have an authenticated DID\nconst doc = await TileDocument.create(ceramic, content)\n// The stream ID of the created document can then be accessed as the `id` property\nreturn doc.id\n}\n</code></pre> <p>In addition to the stream <code>content</code>, the following <code>metadata</code> can be set</p>"},{"location":"reference/stream-programs/tile-document/#update-a-document","title":"Update a document","text":"<p>In order to update a document, an authenticated DID needs to be attached to the Ceramic client instance to enable transactions (signing commits).</p> <p>The following example uses the ed25519 Key DID provider for simplicity, but creating documents can be done using any supported DID provider.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\nconst provider = new Ed25519Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\n// Authenticate the DID with the provider\nawait did.authenticate()\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n\nasync function updateDocument(id, content) {\n// First, we need to load the document\nconst doc = await TileDocument.load(ceramic, id)\n// The following call will fail if the Ceramic instance does not have an authenticated DID\nawait doc.update(content)\n}\n</code></pre>"},{"location":"reference/stream-programs/tile-document/#use-json-schema-validation","title":"Use JSON schema validation","text":"<p>Ceramic nodes support validation of documents using JSON schemas. In order for a document to get validated, a Tile document containing the contents of the JSON schema must be created on the node and referenced in metadata.</p> <p>In this example, we use the <code>commitID</code> of the created schema document rather than the stream ID in order to get an immutable reference to the specific version on the schema. This is particularly useful when using schemas that are controlled by external entities, as using the latest version of the schema (using a stream ID as reference) could lead to breaking changes. For example, the schema document could be updated such as <code>name</code> would be replaced by <code>firstName</code> and <code>lastName</code>, but apps having logic implementing setting the <code>name</code> would no longer pass validation. By using the <code>commitID</code> of the schema document, apps are guaranteed that documents will be validated against this exact version of the schema.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\nconst provider = new Ed25519Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\n// Authenticate the DID with the provider\nawait did.authenticate()\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n\n// This function will create the schema document and return the commit ID of the schema,\n// providing an immutable reference to the created version of the schema\nasync function createSchemaDocument() {\n// The following call will fail if the Ceramic instance does not have an authenticated DID\nconst doc = await TileDocument.create(ceramic, {\n$schema: 'http://json-schema.org/draft-07/schema#',\ntitle: 'MySchema',\ntype: 'object',\nproperties: {\nname: {\ntype: 'string',\nmaxLength: 150,\n},\n},\nrequired: ['name'],\n})\n// The stream ID of the created document can then be accessed as the `id` property\nreturn doc.commitId\n}\n\nasync function createDocument(content, schema) {\n// The following call will fail if the Ceramic instance does not have an authenticated DID\nconst doc = await TileDocument.create(ceramic, content, { schema })\n// The stream ID of the created document can then be accessed as the `id` property\nreturn doc.id\n}\n\n// The following example flow creates the schema and the document using the schema with the same\n// DID, in practice it is likely the schemas are created by developers earlier in the development\n// flow and the commit IDs of the schemas are referenced by applications at runtime\nasync function run(seed) {\nawait authenticateCeramic(seed)\nconst schemaID = await createSchemaDocument()\nconst docID = await createDocument({ name: 'Alice' }, schemaID)\n}\n</code></pre>"},{"location":"reference/stream-programs/tile-document/#access-a-deterministic-document","title":"Access a deterministic document","text":"<p>Related standard</p> <p>The CIP-11 \"Identity Index\" (IDX) standard leverages deterministic documents to associate records to a DID and is implemented by the DID DataStore library.</p> <p>Ceramic allows the creation and load of documents based on their metadata. This is useful to identify documents based on their controller and family or tags rather than having to know their stream IDs.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\nconst provider = new Ed25519Provider(seed)\nconst did = new DID({ provider, resolver: getResolver() })\n// Authenticate the DID with the provider\nawait did.authenticate()\n// The Ceramic client can create and update streams using the authenticated DID\nceramic.did = did\n}\n\n// Load (or create) a determinitic document for a given controller\nasync function loadDocumentByController(controller) {\nreturn await TileDocument.deterministic(ceramic, {\n// A single controller must be provided to reference a deterministic document\ncontrollers: [controller],\n// A family or tag must be provided in addition to the controller\nfamily: 'myFamily',\ntags: ['foo'],\n})\n}\n\n// The following flow authenticates a DID based on the provided seed and create a deterministic\n// document associated to it\nasync function setMyDocument(seed) {\nawait authenticateCeramic(seed)\n// Load the document controlled the authenticated DID\nconst doc = await loadDocumentByController(ceramic.did.id)\n// The document has no content as it's created based on metadata only...\nif (doc.content == null) {\n// ... but it can be updated by its controller to set content like any other document\nawait doc.update({ hello: 'world' })\n}\n}\n</code></pre>"},{"location":"run/","title":"Run nodes","text":"<p>Ceramic node operators are responsible for hosting the various Ceramic networks. Ceramic clients need to connect to nodes in order to access the network.</p> <p>The guides below describe how to run a daemonized Ceramic node that can be used as a remote node by the JS HTTP Client or the Ceramic CLI.</p>"},{"location":"run/#launching-a-node","title":"Launching a node","text":"<p>When running a node it is best to start by connecting to the Clay testnet. When you are ready to move to mainnet, follow the steps here to authenticate to access mainnet.</p>"},{"location":"run/#run-ceramic-in-development","title":"Run Ceramic in development \u2192","text":"<p>Set up a local Ceramic node for development and testing purposes.</p>"},{"location":"run/#run-ceramic-in-production","title":"Run Ceramic in production \u2192","text":"<p>Run a reliable, performant Ceramic node in the cloud or on bare metal for use by production applications.</p>"},{"location":"run/cas/cas/","title":"Hosting an anchor service","text":"<p>This guide describes how to spin up and run a hosted Ceramic Anchor Service (CAS) in JavaScript that generates anchor commits for streams in batches. You can find the JavaScript CAS implementation here.</p> <p>It is currently not possible to run your own CAS. By default, every Ceramic node automatically uses a free community-operated CAS. You do not need any additional setup. In the future, nodes will be able to specify which CAS they use. Once that is enabled, documentation will be added to this page.</p>"},{"location":"run/cas/community-cas/","title":"Community CAS","text":"<p>This page contains a list of free Ceramic Anchor Services (CAS) hosted by 3Box Labs and made available for the community. The CAS referenced below are hardcoded into every Ceramic node and will be automatically used depending on the node's network configuration; no additional setup is needed.</p> <p>At this time it is not possible to run your own CAS, however this functionality will be available in the near future.</p>"},{"location":"run/cas/community-cas/#mainnet-cas","title":"Mainnet CAS","text":"<p>Nodes connected to Mainnet will automatically use this CAS which generates anchor commits using the Ethereum Mainnet blockchain (<code>eip155:1</code>) and communicates over the <code>/ceramic/mainnet</code> libp2p topic.</p> <p>ETH Mainnet Address:</p> <pre><code>0xaf65E45F4C0BD388F91EeB23cFCd52F4fCdd6Ee2\n</code></pre> <p>To view Mainnet CAS transactions, see Etherscan.</p>"},{"location":"run/cas/community-cas/#clay-testnet-cas","title":"Clay Testnet CAS","text":"<p>Nodes connected to Clay Testnet will automatically use this CAS which generates anchor commits using the Ethereum Ropsten blockchain and communicates over the <code>/ceramic/testnet-clay</code> libp2p topic.</p> <p>ETH Ropsten Address:</p> <pre><code>0x1C124c86f7fc22e67974337E889a513b16a5703f\n</code></pre> <p>To view Clay Testnet CAS transactions, see Etherscan.</p>"},{"location":"run/cas/community-cas/#dev-unstable-cas","title":"Dev Unstable CAS","text":"<p>Nodes connected to the Dev Unstable network will use this CAS which generates anchor commits using the Ethereum Rinkeby blockchain and communicates over the <code>/ceramic/dev-unstable</code> libp2p topic.</p> <p>ETH Rinkeby Address:</p> <pre><code>0x41Ee0C359D95970A83229D8e9801cc2672390217\n</code></pre> <p>To view Dev Unstable CAS transactions, see Etherscan.</p>"},{"location":"run/nodes/available/","title":"Ceramic Community Nodes","text":"<p>Community-operated nodes for testing and development.</p>"},{"location":"run/nodes/available/#timestamp-nodes","title":"Timestamp Nodes","text":"<p>3Box Labs runs timestamp nodes for the ecosystem. These nodes are hardcoded into every Ceramic node and used automatically; no additional setup is needed.</p> Network Implementation Endpoint Blockchain Address Host Mainnet JS CAS TBD ETH Mainnet: <code>0xaf65E45F4C0BD388F91EeB23cFCd52F4fCdd6Ee2</code> 3Box Labs Clay testnet JS CAS TBD ETH Gnosis Chain: <code>0x1C124c86f7fc22e67974337E889a513b16a5703f</code> 3Box Labs Dev unstable JS CAS TBD ETH Gnosis Chain: <code>0x41Ee0C359D95970A83229D8e9801cc2672390217</code> 3Box Labs"},{"location":"run/nodes/community-nodes/","title":"Community Nodes","text":"<p>3Box Labs no longer provides community nodes. To run your own node, follow the steps here.</p>"},{"location":"run/nodes/node-providers/","title":"Node Providers","text":"<p>This page will list third-party node hosting services that offer commercial-grade Ceramic nodes for developers - this is in process for fall 2021.</p>"},{"location":"run/nodes/node-providers/#providers","title":"Providers","text":"<p>If you're interested in being among the first to offer commercial-grade nodes for Ceramic developers and applications, please get in touch on Discord, or for more information on running nodes check out our Forum.</p>"},{"location":"run/nodes/nodes/","title":"Running Ceramic in production","text":"<p>This guide provides complete instructions and various tools for launching a well-connected, production-ready Ceramic node.</p>"},{"location":"run/nodes/nodes/#who-should-run-a-ceramic-node","title":"Who should run a Ceramic node?","text":"<p>To run your application on <code>mainnet</code> you'll need to run your own production-ready node or to use a community provider like hirenodes.</p>"},{"location":"run/nodes/nodes/#things-to-know","title":"Things to know","text":"<p>Ceramic networks \u2013 There are currently three Ceramic networks: <code>mainnet</code>, <code>testnet-clay</code>, and <code>dev-unstable</code>. Learn more about each network here. By default, Ceramic will connect to <code>testnet-clay</code> and a Ceramic Anchor Service running on Gnosis. When you are ready to get on Ceramic <code>mainnet</code>, check out this guide to get access to our <code>mainnet</code> anchor service.</p> <p>Running IPFS \u2013 Ceramic relies on a system called IPFS to connect to and share data in Ceramic networks. IPFS runs as a separate process from the Ceramic node itself, with each Ceramic node connected to a dedicated IPFS node over HTTP. The Ceramic Daemon can launch an IPFS process automatically (referred to as running IPFS in \"bundled\" mode in the Ceramic config file), which is designed for testing and local development only. For production deployments you should run your own IPFS process manually and point your Ceramic node at it (referred to as running ipfs in \"remote\" mode in the Ceramic config file). This allows for more configuration options for your IPFS node allowing for more controlled resource allocation, as well as improved maintenance, debugging and observability. Note that Ceramic only supports <code>go-ipfs</code> version 0.12 or later.</p> <p>The rest of this guide assumes you are running Ceramic with IPFS in \"remote\" mode.</p> <p>Process management, restarts and data persistence \u2013 Ceramic and IPFS will not automatically restart if they crash. You should configure your own restart mechanism, and you must ensure data persistence between restarts.</p>"},{"location":"run/nodes/nodes/#required-steps","title":"Required steps","text":"<p>Below are the steps required for running a Ceramic node in production. This guide will teach you how to:</p> <ol> <li>Install and run the Ceramic daemon</li> <li>Configure data persistence</li> <li>Get connected to the network</li> <li>Get observability data from your node (optional)</li> </ol>"},{"location":"run/nodes/nodes/#quick-start","title":"Quick start","text":""},{"location":"run/nodes/nodes/#run-ceramic-on-aws-ecs-with-terraform","title":"Run Ceramic on AWS ECS with Terraform \u2192","text":"<p>The 3Box Labs team has written a Terraform module that configures Ceramic and IPFS in AWS ECS using Fargate. Using this module is a fast and reliable way to run Ceramic in the cloud because it is set up for data persistence and auto-restarts. The module currently requires some common AWS resources to be pre-configured as well as Cloudflare. See an example of the module in use.</p> <p>We highly encourage the community to create Terraform modules or other templates for different infrastructure providers to further decentralize the Ceramic network.</p>"},{"location":"run/nodes/nodes/#running-the-daemon","title":"Running the daemon","text":"<p>The js-ceramic node is run as a daemon using Node.js or Docker.</p> <p>By default, the Ceramic daemon runs bundled with a go-ipfs node and connects to the Clay testnet and Gnosis Ceramic Anchor Service. In production, you should change these defaults to secure your data and accommodate your infrastructure setup.</p> <p>The Ceramic daemon can be configured with a JSON file which is created on start and located at <code>$HOME/.ceramic/daemon.config.json</code> by default (you can also point to a custom location for the config file using the <code>--config</code> flag when starting the Ceramic Daemon). See example daemon.config.json below. Configuration options can be viewed in the reference documentation for the DaemonConfig class.</p>"},{"location":"run/nodes/nodes/#run-with-docker-containers","title":"Run with Docker containers","text":"<p>Docker images to run Ceramic and IPFS are built from the source code of the js-ceramic and go-ipfs-daemon repositories respectively. Images built from the main branches are tagged with <code>latest</code> and the git commit hash from which the image was built. You can view the image builds of js-ceramic on DockerHub. The Docker image for <code>go-ipfs-daemon</code> pre-configures IPFS with plugins that make it easy to run on cloud infrastructure. You can view the image builds for go-ipfs-daemon on DockerHub.</p>"},{"location":"run/nodes/nodes/#run-outside-of-containers","title":"Run outside of containers","text":"<p>If you would like to run Ceramic and IPFS outside of containers or on bare metal, start by installing go-ipfs (version 0.12 or later). Depending on your infrastructure setup you may consider building <code>go-ipfs</code> with the healthcheck plugin and S3 datastore plugin. Once IPFS is installed, configure it to use pubsub, which Ceramic relies on for message passing. This can be done by running the IPFS daemon with the <code>--enable-pubsub-experiment</code> flag or modifying the configuration by running <code>ipfs config --json Pubsub.Enabled true</code> (learn more in the IPFS docs). Next you can run IPFS and install the Ceramic daemon with the js-ceramic CLI, which is available as a public NPM module. It is currently compatible with Node.js versions 14 and 16.</p>"},{"location":"run/nodes/nodes/#data-persistence","title":"Data Persistence","text":"<p>To run a Ceramic node in production, it is critical to persist the Ceramic state store and the IPFS datastore. The form of storage you choose should also be configured for disaster recovery with data redundancy, and some form of snapshotting and/or backups.</p> <p>Loss of this data can result in permanent loss of Ceramic streams and will cause your node to be in a corrupt state.</p> <p>The Ceramic state store and IPFS datastore are stored on your machine's filesystem by default. The Ceramic state store defaults to <code>$HOME/.ceramic/statestore</code>. The IPFS datastore defaults to <code>ipfs/blocks</code> located wherever you run IPFS.</p> <p>The fastest way to ensure data persistence is by mounting a persistent volume to your instances and configuring the Ceramic and IPFS nodes to write to the mount location. The mounted volume should be configured such that the data persists if the instance shuts down.</p> <p>You can also use AWS S3 for data storage which is supported for both Ceramic and IPFS. Examples of the configuration for both storage options are listed below.</p>"},{"location":"run/nodes/nodes/#ipfs-datastore","title":"IPFS Datastore","text":"<p>The IPFS datastore stores the raw IPFS blocks that make up Ceramic streams. To prevent data corruption, use environment variables written to your profile file, or otherwise injected into your environment on start so that the datastore location does not change between reboots.</p> <p>Note: Switching between data storage locations is an advanced feature and should be avoided. Depending on the sharding implementation you may need to do a data migration first. See https://github.com/ipfs/go-ipfs/blob/master/docs/config.md#datastorespec for more information.</p>"},{"location":"run/nodes/nodes/#ceramic-state-store","title":"Ceramic State Store","text":"<p>The Ceramic state store holds state for pinned streams and the acts as a cache for the Ceramic streams that your node creates or loads. To ensure that the data you create with your Ceramic node does not get lost you must pin streams you care about and you must ensure that the state store does not get deleted.</p>"},{"location":"run/nodes/nodes/#examples","title":"Examples","text":""},{"location":"run/nodes/nodes/#example-with-docker-containers","title":"Example with Docker containers","text":"<pre><code>docker pull ceramicnetwork/go-ipfs-daemon:latest\n\n# Use this snippet to keep the datastore in the volume\ndocker run \\\n-p 5001:5001 \\ # API port\n-p 8011:8011 \\ # Healthcheck port\n-v /path_on_volume_for_ipfs_repo:/data/ipfs \\\n--name ipfs \\\ngo-ipfs-daemon\n\n# Use this snippet to keep the datastore in S3\ndocker run \\\n-p 5001:5001 \\ # API port\n-p 8011:8011 \\ # Healthcheck port\n-v /path_on_volume_for_ipfs_repo:/data/ipfs \\\n-e IPFS_ENABLE_S3=true \\\n-e IPFS_S3_REGION=region \\\n-e IPFS_S3_BUCKET_NAME=bucket_name \\\n-e IPFS_S3_ROOT_DIRECTORY=root_directory \\\n-e IPFS_S3_ACCESS_KEY_ID=aws_access_key_id \\\n-e IPFS_S3_SECRET_ACCESS_KEY=aws_secret_access_key \\\n-e IPFS_S3_KEY_TRANSFORM=next-to-last/2 \\ # Sharding method\n--name ipfs \\\ngo-ipfs-daemon\n\n# Get the IP address\ndocker inspect -f \\\n'{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' \\\nipfs\n</code></pre> <p>Before running the Ceramic daemon, configure it to use IPFS in \"remote\" mode. See example daemon.config.json below.</p> <pre><code>docker pull ceramicnetwork/js-ceramic:latest\n\n# Use this snippet to keep the statestore in a volume\ndocker run -d \\\n-p 7007:7007 \\\n-v /path_on_volume_for_daemon_config:/root/.ceramic/daemon.config.json \\\n-v /path_on_volume_for_ceramic_logs:/root/.ceramic/logs \\\n-v /path_on_volume_for_ceramic_statestore:/root/.ceramic/statestore \\\n-e NODE_ENV=production \\\n--name js-ceramic \\\nceramicnetwork/js-ceramic:latest\n\n# Use this snippet to keep the statestore in S3\ndocker run -d \\\n-p 7007:7007 \\\n-v /path_for_daemon_config:/root/.ceramic/daemon.config.json \\\n-v /path_for_ceramic_logs:/root/.ceramic/logs \\\n-e NODE_ENV=production \\\n-e AWS_ACCESS_KEY_ID=s3_access_key_id \\\n-e AWS_SECRET_ACCESS_KEY=s3_secret_access_key \\\n--name js-ceramic \\\nceramicnetwork/js-ceramic:latest\n</code></pre>"},{"location":"run/nodes/nodes/#example-without-containers","title":"Example without containers","text":"<p>After installation, both daemons can be run from the command line</p> <pre><code>ipfs init\nipfs daemon\n</code></pre> <p>Before running the Ceramic daemon, configure it to use IPFS in \"remote\" mode. See example daemon.config.json below.</p> <pre><code>ceramic daemon\n</code></pre>"},{"location":"run/nodes/nodes/#example-daemonconfigjson","title":"Example daemon.config.json","text":"<pre><code>{\n\"anchor\": {\n\"ethereum-rpc-url\": \"https://eg_infura_endpoint\" // Replace with an Ethereum RPC endpoint to avoid rate limiting\n},\n\"http-api\": {\n\"cors-allowed-origins\": [\n\".*\"\n]\n},\n\"ipfs\": {\n\"mode\": \"remote\",\n\"host\": \"http://ipfs_ip_address:5001\"\n},\n\"logger\": {\n\"log-level\": 2, // 0 is most verbose\n\"log-to-files\": true\n},\n\"network\": {\n\"name\": \"mainnet\", // Connect to mainnet, testnet-clay, or dev-unstable\n},\n\"node\": {},\n\"state-store\": {\n\"mode\": \"s3\",\n\"s3-bucket\": \"bucket_name\"\n}\n}\n</code></pre> <p>To use volume storage for the statestore instead of S3</p> <pre><code>\"state-store\": {\n\"mode\": \"fs\",\n\"local-directory\": \"/path_for_ceramic_statestore\", // Defaults to $HOME/.ceramic/statestore\n}\n</code></pre>"},{"location":"run/nodes/nodes/#example-aws-s3-policies","title":"Example AWS S3 Policies","text":"<p>IPFS AWS S3 policy for the access key</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Action\": [\n\"s3:GetObject\",\n\"s3:ListBucket\",\n\"s3:PutObject\",\n\"s3:DeleteObject\"\n],\n\"Effect\": \"Allow\",\n\"Resource\": [\"ipfs_bucket_arn\", \"ipfs_bucket_arn/*\"]\n}\n]\n}\n</code></pre> <p>The S3 datastore is not available out-of-the-box in vanilla <code>go-ipfs</code>. In order to use it with minimal configuration, use the 3Box Labs go-ipfs-daemon.</p> <p>Ceramic state store AWS S3 policy for the access key</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Action\": [\n\"s3:ListBucket\",\n\"s3:GetObject\",\n\"s3:PutObject\",\n\"s3:DeleteObject\"\n],\n\"Effect\": \"Allow\",\n\"Resource\": [\"state_store_bucket_arn\", \"state_store_bucket_arn/*\"]\n}\n]\n}\n</code></pre>"},{"location":"run/nodes/nodes/#get-connected-to-the-network","title":"Get connected to the network","text":""},{"location":"run/nodes/nodes/#connecting-to-ceramic","title":"Connecting to Ceramic","text":"<p>The Ceramic daemon serves an HTTP API that clients use to interact with your Ceramic node. The default API port is <code>7007</code>. Make sure this port is available to all clients you plan to use for your application.</p> <p>Healthchecks can be run against the API endpoint <code>/api/v0/node/healthcheck</code>.</p>"},{"location":"run/nodes/nodes/#staying-connected-to-ipfs","title":"Staying connected to IPFS","text":"<p>Ceramic nodes rely on IPFS for networking. IPFS nodes connect to each other using a Libp2p module called \"switch\" (aka \"swarm\"). This module operates over a websocket, on port <code>4011</code> by default. The websocket port must be accessible to the internet so your Ceramic node can be connected to the network.</p> <p>Healthchecks can be run against the <code>HEALTHCHECK_PORT</code> (port <code>8011</code> by default) when <code>HEALTHCHECK_ENABLED</code> is <code>true</code>.</p> <p>Additionally, when running IPFS the IPFS API port must be accessible by the Ceramic node. The default API port is <code>5001</code>. The IPFS node address will then be passed to Ceramic with the <code>ipfs.host</code> option in the Ceramic daemon config file.</p>"},{"location":"run/nodes/nodes/#connect-to-the-mainnnet-anchor-service","title":"Connect to the mainnnet anchor service","text":"<p>For nodes that wish to connect to Ceramic mainnet, the node's IP address will have to be added to the allowlist for the Ceramic Anchor Service node operated by 3BoxLabs. Once you have fully configured your Ceramic node with this guide and have a way to persist its configuration and state, open an issue in the Ceramic Anchor Allowlist Repo with the public, static egress IP address for your Ceramic node, and a brief description of the data persistence setup for the multiaddress, Ceramic State Store, and IPFS Repo. Once your issue is closed, you will be connected to the Ceramic network and the Ceramic Anchor Service.</p> <p>Nodes that wish to connect to other Ceramic networks, such as the clay testnet, do not need to do anything special to gain access to the Ceramic Anchor Service.  The Anchor Service for the <code>testnet-clay</code> network is open to everyone and does not have an IP allowlist like the mainnet service does.</p> <p>Mainnet nodes will not run immediately after start up until your pull request is reviewed and your IP address is added to the allow list for the 3Box Labs hosted anchor service.</p>"},{"location":"run/nodes/nodes/#observability","title":"Observability","text":"<p>Ceramic has a debug mode that you can enable using the <code>--debug</code> flag. This will allow you to see all logs printed to your console, including debug logs, API requests, events, and errors.</p> <p>For observability, it is best to have these logs written to files to debug any issues and to generate metrics. Logging to files can be enabled with the <code>logger.log-to-files</code> config file option. The default location for logs is <code>~/.ceramic/logs</code> but this path can be configured with the <code>logger.log-directory</code> config file option. Even without debug mode enabled you will still get critical logs and metrics written to files.</p> <p>Request and event logs are written in logfmt. This makes them easy to import into Grafana dashboards using a log scraping agent like Promtail and a log aggregator like Loki, which can be used as a data source for Grafana. An example of such a setup can be found here.</p>"},{"location":"run/nodes/nodes/#next-steps","title":"Next steps","text":"<p>Congratulations! You have now set up a well-connected Ceramic node in the cloud which can receive HTTP requests from the local environment, the JS HTTP Client, or to simply serve as another node to replicate and pin streams. Please report any bugs as issues on the JS Ceramic GitHub.</p>"},{"location":"tools/overview/","title":"Tools","text":"<p>Various tools such as libraries, CLIs and services are created on top of Ceramic to provide abstractions and specific solutions to some common use-cases.</p>"},{"location":"tools/overview/#glaze","title":"Glaze","text":"<p>The Glaze umbrella includes projects providing low-level solutions on top of Ceramic. Each project focuses on a specific scope, using a restricted number of dependencies on top of Ceramic.</p> <p>Glaze overview</p>"},{"location":"tools/overview/#selfid","title":"Self.ID","text":"<p>Self.ID is both a reference application and a SDK providing higher-level abstractions to create user-centric Web applications. It leverages Glaze projects and DID Session to offer a simple way to help Web developers get started with the Ceramic ecosystem.</p> <p>Self.ID overview</p>"},{"location":"tools/overview/#identitylink","title":"IdentityLink","text":"<p>IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts.</p> <p>IdentityLink overview</p>"},{"location":"tools/glaze/datamodel/","title":"Aliasing data models","text":"<p>The Glaze DataModel library provides human-readable name aliasing for data models, making it easier to refer to and use data models with the DID DataStore API, and other places within your Ceramic application.</p>"},{"location":"tools/glaze/datamodel/#how-it-works","title":"How it works","text":"<p>The Glaze DataModel library requires an instance of Ceramic and a preexisting <code>aliases</code> object, which can be created during development using either the Glaze CLI or the Glaze DevTools library.</p> <p>The primary purpose of the DataModel library is to create a new <code>ModelAliases</code> object which contains human-friendly aliases for your data models that can be used at runtime to simplify development. This <code>ModelAliases</code> is defined by the following type:</p> <pre><code>type ModelAliases = {\nschemas: Record&lt;string, string&gt;\ndefinitions: Record&lt;string, string&gt;\ntiles: Record&lt;string, string&gt;\n}\n</code></pre> <p>In this object, the key of each record is your alias and the value is a reference to a stream, which for schemas is a commitURL and for definitions and other related tiles is a streamID.</p>"},{"location":"tools/glaze/datamodel/#getting-started-with-glaze-datamodel","title":"Getting started with Glaze DataModel","text":"<p>Visit the Glaze DataModel reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with the Glaze DataModel:</p>"},{"location":"tools/glaze/datamodel/#installation","title":"Installation","text":"<pre><code>npm install @glazed/datamodel\n</code></pre>"},{"location":"tools/glaze/datamodel/#usage","title":"Usage","text":"<p>After you have a <code>ModelAliases</code> object from the Glaze CLI or the DevTools library, the main purpose of the Glaze DataModel library is to abstract away the underlying machine-readable names of your schemas and data model definitions into something human-readable that simplifies application development:</p> <pre><code>import { DataModel } from '@glazed/datamodel'\n\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://mySchemaURL',\n},\ndefinitions: {\nmyDefinition: 'myDefinitionID',\n},\ntiles: {},\n}\n\nconst model = new DataModel({ ceramic, aliases })\n\nmodel.getSchemaURL('MySchema') // 'ceramic://mySchemaURL'\n</code></pre>"},{"location":"tools/glaze/datamodel/#next-steps-storing-and-retrieving-data","title":"Next steps: Storing and retrieving data","text":"<p>Your human-readable data model aliases can now be used with the DID DataStore module provided by Glaze suite, which is also included in the Self.ID SDK, to store and retrieve data from these data models.</p>"},{"location":"tools/glaze/deploy-from-cli/","title":"Deploying data models with the Glaze CLI","text":"<p>The Glaze CLI provide commands for common interactions with data models to help support your development workflow.</p> <p>The Glaze CLI is useful for basic data model management. For managing multiple models or more complex models, we recommend using the Glaze DevTools library.</p>"},{"location":"tools/glaze/deploy-from-cli/#getting-started-with-the-glaze-cli","title":"Getting started with the Glaze CLI","text":""},{"location":"tools/glaze/deploy-from-cli/#installation","title":"Installation","text":"<pre><code>npm install --global @glazed/cli\n</code></pre> <p>The CLI is then accessible as <code>glaze</code>.</p>"},{"location":"tools/glaze/deploy-from-cli/#usage","title":"Usage","text":"<p>Run <code>glaze help</code> to list the available commands. The commands for some common flows are described below.</p>"},{"location":"tools/glaze/deploy-from-cli/#set-up-your-developer-account","title":"Set up your developer account","text":"<p>In order to create streams that store the schemas and definitions for our data models, you'll need to use a Key DID account. If you don't already have one, you can use the <code>did:create</code> command. It will output a random hexademical <code>seed</code> that can be used as the <code>DID_KEY</code> environment variable or as the <code>--key</code> flag in the following commands.</p> <pre><code>glaze did:create\n</code></pre>"},{"location":"tools/glaze/deploy-from-cli/#creating-data-models","title":"Creating data models","text":"<p>Creating a local model can be done using the <code>model:create</code> command:</p> <pre><code>glaze model:create my-model\n</code></pre> <p>Schemas can be added to the model, either by using a stream already present on the given Ceramic node or by creating a new one:</p> Using an existing schemaCreating a new schema <pre><code>glaze model:add my-model schema MySchema schemaStreamReference\n</code></pre> <pre><code>glaze model:add my-model schema MySchema '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"MySchema\",\"type\":\"object\",\"properties\":{}}' --key=&lt;your key&gt;\n</code></pre> <p>The <code>model:add</code> command can be used in a similar way to add Definitions (<code>model:add my-model definition ...</code>) and Tiles (<code>model:add my-model tile ...</code>).</p>"},{"location":"tools/glaze/deploy-from-cli/#import-data-models","title":"Import data models","text":"<p>Existing models can be imported in a local model either using JSON files or locally installed packages (that can be imported by Node) using the <code>model:import</code> command:</p> Using a local fileUsing a package name <pre><code>glaze model:import my-model ./model-to-import.json\n</code></pre> <pre><code>glaze model:import my-model package-name-of-model\n</code></pre>"},{"location":"tools/glaze/deploy-from-cli/#export-data-models-as-json","title":"Export data models as JSON","text":"<p>A local model can also be exported to a JSON file using the <code>model:export</code> command:</p> <pre><code>glaze model:export my-model ./my-model.json\n</code></pre>"},{"location":"tools/glaze/deploy-from-cli/#deploy-to-ceramic","title":"Deploy to Ceramic","text":"<p>The <code>model:deploy</code> command can be used to deploy all the streams used by a given model:</p> Deploying a local modelDeploying a model fileDeploying a model package <pre><code>glaze model:deploy my-model\n</code></pre> <pre><code>glaze model:deploy ./my-model.json\n</code></pre> <pre><code>glaze model:deploy package-name-of-model\n</code></pre> <p>Optionally, a second argment can be provided to output the ModelAliases to a JSON file:</p> <pre><code>glaze model:deploy my-model ./deployed-model.json\n</code></pre>"},{"location":"tools/glaze/deploy-from-cli/#next-steps-using-models-in-your-app","title":"Next steps: Using models in your app","text":""},{"location":"tools/glaze/deploy-from-cli/#aliasing-your-data-models","title":"Aliasing your data models","text":"<p>Your output file can be used by the DataModel module contained in Glaze suite in order to give your model a friendly, human-readable name.</p>"},{"location":"tools/glaze/deploy-from-cli/#storing-and-retrieving-data","title":"Storing and retrieving data","text":"<p>Your data models are now available to be used by the DID DataStore module provided by Glaze suite, which is also included in the Self.ID framework, to store and retrieve data from these data models.</p>"},{"location":"tools/glaze/deploy-from-cli/#example","title":"Example","text":"<p>In this example, we will import and deploy popular Ceramic data models found in the Data Models Registry, defined by the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications.</p> <p>First, we need to install these data models from the Data Models Registry using npm:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <p>We can then import them when using the CLI in a folder where these npm packages can be resolved from, using the steps described above:</p> <pre><code>glaze model:create idx\nglaze model:import idx @datamodels/identity-profile-basic\nglaze model:import idx @datamodels/identity-accounts-crypto\nglaze model:import idx @datamodels/identity-accounts-web\nglaze model:deploy idx\n</code></pre>"},{"location":"tools/glaze/development/","title":"Deploy data models from JavaScript","text":"<p>The Glaze DevTools module provides JavaScript APIs that allow you to programmatically create, edit, and deploy the data models used by your Ceramic application using a script. As opposed to manually deploying data models with the Glaze CLI, DevTools makes it easy to manage more models or more complex models.</p>"},{"location":"tools/glaze/development/#how-it-works","title":"How it works","text":"<p>The DevTools module exports a <code>ModelManager</code> class, that can be used in scripts to programmatically manage a data model. The ModelManager object contains all data and metadata necessary to represent a Ceramic data model, and can be serialized to JSON.</p> <p>The ModelManager helps you to keep track of dependencies between streams that comprise your data models during development. For example, adding a data model definition to a model will also add the schema referenced by the definition, as both streams need to be present on your Ceramic node at runtime to work as expected.</p> <p>Additionally, data models promote reusability: a model can be created and edited on a local node and then deployed to the Ceramic testnet and mainnet with no change required in application code.</p>"},{"location":"tools/glaze/development/#getting-started-with-devtools","title":"Getting started with DevTools","text":"<p>Visit the Glaze DevTools reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application.</p>"},{"location":"tools/glaze/development/#installation","title":"Installation","text":"<pre><code>npm install --dev @glazed/devtools\n</code></pre>"},{"location":"tools/glaze/development/#setup","title":"Setup","text":"<p>The <code>ModelManager</code> constructor requires a Ceramic instance, that must be authenticated when calling the create methods: <code>createSchema()</code>, <code>createDefinition()</code> and <code>createTile()</code>.</p> <pre><code>import { ModelManager } from '@glazed/devtools'\n\nconst manager = new ModelManager({ ceramic })\n</code></pre>"},{"location":"tools/glaze/development/#constructing-your-model-manager","title":"Constructing your model manager","text":"<p>A model manager consists of various data models used by your application. Each data model consists of one or more schemas and a definition. You'll need to add those schemas and definitions to your model manager.</p>"},{"location":"tools/glaze/development/#adding-schemas","title":"Adding schemas","text":"<p>If the stream containing the schema you wish to use is already available on your Ceramic node, you can add it like this:</p> <pre><code>await manager.useDeployedSchema('MySchema', schemaStreamReference)\n</code></pre> <p>If the schema you wish to use is not available on your Ceramic node or has not been created yet, you can create it like this:</p> <pre><code>await manager.createSchema('MySchema', {\n$schema: 'http://json-schema.org/draft-07/schema#',\ntitle: 'MySchema',\ntype: 'object',\nproperties: {\n...\n},\n})\n</code></pre>"},{"location":"tools/glaze/development/#adding-definitions","title":"Adding definitions","text":"<p>Similar methods can be used to add data model definitions with <code>useDeployedDefinition()</code> and <code>createDefinition()</code> or Tiles with <code>useDeployedTile()</code> and <code>createTile()</code>.</p>"},{"location":"tools/glaze/development/#importexport-as-json","title":"Import/export as JSON","text":"<p>The ManagedModel used internally by a <code>ModelManager</code> can be exported and imported as JSON for easier portability and storage:</p> <pre><code>const model = manager.toJSON()\n\nconst clonedManager = ModelManager.fromJSON({ ceramic, model })\n</code></pre>"},{"location":"tools/glaze/development/#deploy-to-ceramic","title":"Deploy to Ceramic","text":"<p>The model can be deployed to your Ceramic node by calling the <code>deploy()</code> method:</p> <pre><code>const modelAliases = await manager.deploy()\n</code></pre>"},{"location":"tools/glaze/development/#example","title":"Example","text":"<p>In this example, we will import and deploy popular Ceramic data models found in the Data Models Registry, defined by the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications.</p> <p>First, install these data models from the Data Models Registry using npm:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <p>Now we can then use them in a script:</p> <pre><code>import { ModelManager } from '@glazed/devtools'\nimport { model as basicProfileModel } from '@datamodels/identity-profile-basic'\nimport { model as cryptoAccountsModel } from '@datamodels/identity-accounts-crypto'\nimport { model as webAccountsModel } from '@datamodels/identity-accounts-web'\n\nconst manager = new ModelManager({ ceramic })\nmanager.addJSONModel(basicProfileModel)\nmanager.addJSONModel(cryptoAccountsModel)\nmanager.addJSONModel(webAccountsModel)\n\nconst aliases = await manager.deploy()\n</code></pre>"},{"location":"tools/glaze/development/#cli","title":"CLI","text":""},{"location":"tools/glaze/development/#installation_1","title":"Installation","text":"<pre><code>npm install --global @glazed/cli\n</code></pre> <p>The CLI is then accessible as <code>glaze</code>.</p>"},{"location":"tools/glaze/development/#usage","title":"Usage","text":"<p>Run <code>glaze help</code> to list the available commands. The commands for some common flows are described below.</p>"},{"location":"tools/glaze/development/#creation-and-edition","title":"Creation and edition","text":"<p>In order to create streams, we need a Key DID. If you don't already have one, you can use the <code>did:create</code> command. It will output a random hexademical <code>seed</code> that can be used as the <code>DID_KEY</code> environment variable or as the <code>--key</code> flag in the following commands.</p> <pre><code>glaze did:create\n</code></pre> <p>Creating a local model can be done using the <code>model:create</code> command:</p> <pre><code>glaze model:create my-model\n</code></pre> <p>Schemas can be added to the model, either by using a Stream already present on the given Ceramic node:</p> Using an existing schemaCreating a new schema <pre><code>glaze model:add my-model schema MySchema schemaStreamReference\n</code></pre> <pre><code>glaze model:add my-model schema MySchema '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"MySchema\",\"type\":\"object\",\"properties\":{}}' --key=&lt;your key&gt;\n</code></pre> <p>The <code>model:add</code> command can be used in a similar way to add Definitions (<code>model:add my-model definition ...</code>) and Tiles (<code>model:add my-model tile ...</code>).</p>"},{"location":"tools/glaze/development/#import-and-export","title":"Import and export","text":"<p>Existing models can be imported in a local model either using JSON files or locally installed packages (that can be imported by Node) using the <code>model:import</code> command:</p> Using a local fileUsing a package name <pre><code>glaze model:import my-model ./model-to-import.json\n</code></pre> <pre><code>glaze model:import my-model package-name-of-model\n</code></pre> <p>A local model can also be exported to a JSON file using the <code>model:export</code> command:</p> <pre><code>glaze model:export my-model ./my-model.json\n</code></pre>"},{"location":"tools/glaze/development/#deployment","title":"Deployment","text":"<p>The <code>model:deploy</code> command can be used to deploy all the Streams used by a given model:</p> Deploying a local modelDeploying a model fileDeploying a model package <pre><code>glaze model:deploy my-model\n</code></pre> <pre><code>glaze model:deploy ./my-model.json\n</code></pre> <pre><code>glaze model:deploy package-name-of-model\n</code></pre> <p>Optionally, a second argment can be provided to output the ModelAliases to a JSON file:</p> <pre><code>glaze model:deploy my-model ./deployed-model.json\n</code></pre> <p>This output file can then be used by the DataModel runtime.</p>"},{"location":"tools/glaze/development/#creating-updating-and-querying-tiles","title":"Creating, Updating and Querying Tiles","text":"<p>Using the <code>tile:*</code> commands you can interact with any of the tile commands:</p> CreateCreate DeterministicUpdatesQuery <pre><code>glaze tile:create -b '{\"foo\":\"bar\"}'\n</code></pre> <pre><code>glaze tile:deterministic '{\"family\": \"CLI\"}'\n</code></pre> <pre><code>glaze tile:update &lt;STREAMID&gt; -b '{\"foo\":\"baz\"}'\n</code></pre> <pre><code>glaze tile:content &lt;STREAMID&gt;\n</code></pre>"},{"location":"tools/glaze/development/#stream-interactions","title":"Stream Interactions","text":"<p>The <code>stream:*</code> commands are used to interact with the history of your tiles. </p> CommitsState <pre><code>glaze stream:commits &lt;STREAMID&gt;\n</code></pre> <pre><code>glaze stream:state &lt;STREAMID&gt;\n</code></pre>"},{"location":"tools/glaze/development/#pinning-streams","title":"Pinning Streams","text":"<p>Pinning a stream is used to persist the data that you're creating, the <code>pin:*</code> commands are used to add, remove or list pins.</p> AddRemoveList <pre><code>glaze pin:add &lt;STREAMID&gt;\n</code></pre> <pre><code>glaze pin:rm &lt;STREAMID&gt;\n</code></pre> <pre><code>glaze pin:ls\n</code></pre>"},{"location":"tools/glaze/development/#example-using-idx-models","title":"Example: using IDX models","text":"<p>In this example, we will import and deploy the datamodels defined by the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications.</p> <p>First, we need to install these datamodels using npm:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <p>We can then import them when using the CLI in a folder where these npm packages can be resolved from, using the steps described above:</p> <pre><code>glaze model:create idx\nglaze model:import idx @datamodels/identity-profile-basic\nglaze model:import idx @datamodels/identity-accounts-crypto\nglaze model:import idx @datamodels/identity-accounts-web\nglaze model:deploy idx\n</code></pre>"},{"location":"tools/glaze/did-datastore/","title":"DID DataStore","text":"<p>DID DataStore is a runtime library that allows any application to store and retrieve data from a Ceramic account's personal datastore, with support for public and private data. The DID DataStore API is based on data models; when multiple applications reuse the same data model, they reuse the same underlying data. As such, DID DataStore is core to how Ceramic delivers user-centric data composability across applications.</p>"},{"location":"tools/glaze/did-datastore/#how-it-works","title":"How it works","text":"<p>The DID DataStore is an implementation of the Identity Index (IDX) protocol, allowing to associate records to a DID. To learn more about the IDX protocol, see its reference documentation.</p> <p></p>"},{"location":"tools/glaze/did-datastore/#getting-started-with-did-datastore","title":"Getting started with DID DataStore","text":"<p>Visit the DID DataStore reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with DID DataStore:</p>"},{"location":"tools/glaze/did-datastore/#installation","title":"Installation","text":"<pre><code>npm install @glazed/did-datastore\n</code></pre>"},{"location":"tools/glaze/did-datastore/#usage","title":"Usage","text":"<p>The DID DataStore requires a Ceramic instance and either a DataModel instance or PublishedModel object provided by the Glaze DataModel library:</p> Using a DataModel instanceUsing model aliases directly <pre><code>import { DataModel } from '@glazed/datamodel'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://mySchemaURL',\n},\ndefinitions: {\nmyDefinition: 'myDefinitionID',\n},\ntiles: {},\n}\n\nconst model = new DataModel({ ceramic, aliases })\nconst dataStore = new DIDDataStore({ ceramic, model })\n</code></pre> <pre><code>import { DIDDataStore } from '@glazed/did-datastore'\n\nconst aliases = {\nschemas: {\nMySchema: 'ceramic://mySchemaURL',\n},\ndefinitions: {\nmyDefinition: 'myDefinitionID',\n},\ntiles: {},\n}\n\nconst dataStore = new DIDDataStore({ ceramic, model: aliases })\n</code></pre>"},{"location":"tools/glaze/did-datastore/#readwrite-data","title":"Read/Write Data","text":"<p>It is then possible to read and write with data in the user's DataStore:</p> <pre><code>await dataStore.set('myDefinition', { record: 'content' })\n\nawait dataStore.get('myDefinition') // { record: 'content' }\n</code></pre>"},{"location":"tools/glaze/example/","title":"Glaze example","text":""},{"location":"tools/glaze/example/#1-prerequisites","title":"1. Prerequisites","text":"<p>In this example, we'll create a DataModel for a simple text note that can be associated to a DID, and an associated script to interact with this model.</p> <p>First, we will need to install the following runtime packages:</p> <pre><code>npm install @ceramicnetwork/http-client @glazed/datamodel @glazed/did-datastore dids key-did-provider-ed25519 key-did-resolver uint8arrays\n</code></pre> <p>The following steps will present two ways of going through the development flow: creating a custom script (recommended option for complex models) or using the Glaze CLI (simpler option for basic models):</p> Using a scriptUsing the CLI <pre><code>npm install --dev @glazed/devtools\n</code></pre> <pre><code>npm install --global @glazed/cli\n</code></pre>"},{"location":"tools/glaze/example/#2-local-setup","title":"2. Local setup","text":"ScriptCLI <p>In order to create a DataModel, we need a Ceramic instance with an authenticated DID. DataModels only support DIDs using the <code>did:key</code> method, so we'll <code>key-did-provider-ed25519</code> in this example.</p> <p>Let's create a <code>create-model.mjs</code> file with the following contents:</p> <pre><code>import { writeFile } from 'node:fs/promises'\nimport { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\nimport { fromString } from 'uint8arrays'\n\n// The key must be provided as an environment variable\nconst key = fromString(process.env.DID_KEY, 'base16')\n// Create and authenticate the DID\nconst did = new DID({\nprovider: new Ed25519Provider(key),\nresolver: getResolver(),\n})\nawait did.authenticate()\n\n// Connect to the local Ceramic node\nconst ceramic = new CeramicClient('http://localhost:7007')\nceramic.did = did\n\n// Create a manager for the model\nconst manager = new ModelManager({ ceramic })\n</code></pre> <p>Creating a local DataModel using the CLI simply requires to run the <code>model:create</code> command with a name to identify the model:</p> <pre><code>glaze model:create simple-note\n</code></pre> <p>Let's also create a DID if you don't already have one:</p> <pre><code>glaze did:create\n</code></pre> <p>You can then set the displayed key as the <code>DID_KEY</code> environment variable when running other commands, or make sure to provide it using the <code>--key</code> flag, as used in the following steps.</p>"},{"location":"tools/glaze/example/#3-datamodel-creation","title":"3. DataModel creation","text":""},{"location":"tools/glaze/example/#simplenote-schema","title":"SimpleNote schema","text":"<p>We'll first create a JSON schema for an object containing a <code>text</code> property.</p> ScriptCLI <pre><code>const noteSchemaID = await manager.createSchema('SimpleNote', {\n$schema: 'http://json-schema.org/draft-07/schema#',\ntitle: 'SimpleNote',\ntype: 'object',\nproperties: {\ntext: {\ntype: 'string',\ntitle: 'text',\nmaxLength: 4000,\n},\n},\n})\n</code></pre> <p>Here we will use the <code>model:add</code> command, that takes the following 4 arguments:</p> <ol> <li>The local model name</li> <li>The type to add, here a <code>schema</code></li> <li>The alias for this schema, here <code>SimpleNote</code></li> <li>The schema contents, as a JSON-encoded string</li> </ol> <pre><code>glaze model:add simple-note schema SimpleNote '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"SimpleNote\",\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\",\"title\":\"text\",\"maxLength\":4000}}}' --key=&lt;your key&gt;\n</code></pre> <p>Now that we have a schema, we can use it as reference in the following steps.</p>"},{"location":"tools/glaze/example/#mynote-definition","title":"myNote definition","text":"<p>Definitions need to reference a specific version of a schema using a commit ID in URL form (starting with <code>ceramic://</code>).</p> ScriptCLI <p>Using the manager, schema URLs should be accessed using the <code>getSchemaURL()</code> method:</p> <pre><code>// Create the definition using the created schema ID\nawait manager.createDefinition('myNote', {\nname: 'My note',\ndescription: 'A simple text note',\nschema: manager.getSchemaURL(noteSchemaID),\n})\n</code></pre> <p>Before we can create a definition, we need to inspect the model to retrieve the commit ID of our schema, identified by the <code>version</code>:</p> <pre><code>glaze model:inspect simple-note\n</code></pre> <p>We can then copy the <code>version</code> associated to the <code>SimpleNote</code> schema to the following command:</p> <pre><code>glaze model:add simple-note definition myNote '{\"name\":\"My note\",\"description\":\"A simple text note\",\"schema\":\"ceramic://&lt;SimpleNote schema version ID&gt;\"}' --key=&lt;your key&gt;\n</code></pre>"},{"location":"tools/glaze/example/#examplenote-tile","title":"exampleNote tile","text":"<p>Creating a tile is similar to a definition, except for the <code>schema</code> reference that needs to be provided as metadata rather than in the content:</p> ScriptCLI <pre><code>// Create a tile using the created schema ID\nawait manager.createTile('exampleNote',\n{ text: 'A simple note' },\n{ schema: manager.getSchemaURL(noteSchemaID) },\n)\n</code></pre> <pre><code>glaze model:add simple-note tile exampleNote '{\"text\":\"A simple note\"}' --schema='ceramic://&lt;SimpleNote schema version ID&gt;' --key=&lt;your key&gt;\n</code></pre>"},{"location":"tools/glaze/example/#4-deployment-for-runtime","title":"4. Deployment for runtime","text":"<p>In this example, we are creating streams on the local Ceramic node, so we know they are already present and accessible at runtime. There are various cases however when we can't make assumptions about the presence of the necessary streams, for example on a testnet or CI node.</p> <p>The deployment process consists in publishing all the necessary streams potentially used by our DataModel at runtime to a given Ceramic node, in order to ensure their availability. The deployed model is then written to the <code>model.json</code> file, that will simply contain mappings for our aliases to stream references, for example:</p> <pre><code>{\n\"definitions\": {\n\"myNote\": \"kjzl6cwe1jw145a8rcoo8y9c1jtwa71cc33vvz7gqah1tg4dvoxkd62u8mzbz4d\"\n},\n\"schemas\": {\n\"SimpleNote\": \"ceramic://k3y52l7qbv1frxtwv4ip9pdwe6vh3dh13rs0ynh4pwwqo7usnudlsvgm8w2gl4xz4\"\n},\n\"tiles\": {\n\"exampleNote\": \"kjzl6cwe1jw149ymdkfpkmf0ighksbfxfgt6bm4ut45mapn87a4wm9nkf7xouzg\"\n}\n}\n</code></pre> ScriptCLI <p>We can add the following code at the end of our <code>create-model.mjs</code> script:</p> <pre><code>// Deploy model to Ceramic node\nconst model = await manager.deploy()\n\n// Write deployed model aliases to JSON file\nawait writeFile('./model.json', JSON.stringify(model))\n</code></pre> <p>We can use the <code>model:deploy</code> command to deploy a model, optionally with a second argument to output the deployed model aliases to a JSON file:</p> <pre><code>glaze model:deploy simple-note ./model.json\n</code></pre>"},{"location":"tools/glaze/example/#5-runtime-usage","title":"5. Runtime usage","text":""},{"location":"tools/glaze/example/#runtime-setup","title":"Runtime setup","text":"<p>Let's create a <code>run.mjs</code> file containing the following code:</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\nimport { DIDDataStore } from '@glazed/did-datastore'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\nimport { fromString } from 'uint8arrays'\n\n// Import the model aliases created during development time\nimport modelAliases from './model.json'\n\n// The key must be provided as an environment variable\nconst key = fromString(process.env.DID_KEY, 'base16')\n// Create and authenticate the DID\nconst did = new DID({\nprovider: new Ed25519Provider(key),\nresolver: getResolver(),\n})\nawait did.authenticate()\n\n// Create the Ceramic instance and inject the DID\nconst ceramic = new CeramicClient('http://localhost:7007')\nceramic.did = did\n\n// Create the model and store\nconst model = new DataModel({ ceramic, aliases: modelAliases })\nconst store = new DIDDataStore({ ceramic, model })\n</code></pre> <p>This setup can then be used to perform any of the following use-cases.</p>"},{"location":"tools/glaze/example/#known-note-loading","title":"Known note loading","text":"<p>We can now load the <code>exampleNote</code> tile using its alias:</p> <pre><code>const exampleNote = await model.loadTile('exampleNote')\n</code></pre>"},{"location":"tools/glaze/example/#new-note-creation","title":"New note creation","text":"<p>Using the <code>DataModel</code> runtime, it is also possible to create new notes using the schema alias:</p> <pre><code>const newNote = await model.createTile('SimpleNote', { text: 'My new note' })\n</code></pre>"},{"location":"tools/glaze/example/#note-associated-to-a-did","title":"Note associated to a DID","text":"<p>Finally, using the DID DataStore, we can interact with the <code>myNote</code> record associated to a given DID:</p> <pre><code>await store.set('myNote', { text: 'This is my note' })\n\nawait store.get('myNote') // { text: 'This is my note' }\n</code></pre>"},{"location":"tools/glaze/glossary/","title":"Glaze Glossary","text":"<p>Common terms used in Glaze packages and tools.</p>"},{"location":"tools/glaze/glossary/#schema","title":"Schema","text":"<p>A Ceramic TileDocument storing a JSON schema as contents. Schemas are the basis of most Glaze packages and tools functionalities.</p>"},{"location":"tools/glaze/glossary/#definition","title":"Definition","text":"<p>A TileDocument matching the Definition spec from CIP-11. Definitions are used in the Index of the DID DataStore.</p>"},{"location":"tools/glaze/glossary/#tile","title":"Tile","text":"<p>In the context of Glaze packages, a Tile refers to a TileDocument with an associated Schema.</p>"},{"location":"tools/glaze/glossary/#model","title":"Model","text":"<p>A Glaze DataModel, containing a set of Schemas and potentially related Definitions and/or Tiles.</p>"},{"location":"tools/glaze/glossary/#index","title":"Index","text":"<p>A TileDocument matching the IdentityIndex spec from CIP-11, used by the DID DataStore to associate Definition IDs to Record IDs.</p>"},{"location":"tools/glaze/glossary/#record","title":"Record","text":"<p>Data associated to a DID for a given Definition in the DID DataStore. All records are validated using the Schema declared in the record's Definition.</p>"},{"location":"tools/glaze/overview/","title":"Glaze","text":""},{"location":"tools/glaze/tile-loader/","title":"Caching Ceramic data with Tile Loader","text":"<p>The Glaze Tile Loader library improves application performance by providing batching and caching for tile document streams on the Ceramic network, reducing wait times for retrieving Ceramic data inside your application.</p>"},{"location":"tools/glaze/tile-loader/#how-it-works","title":"How it works","text":"<p>Tile loader provides a thin abstraction on top of the <code>TileDocument</code> stream client to add the following performance improvements:</p> <ul> <li>Batching \u2013 groups concurrent loading of multiple streams in a single call</li> <li>Caching \u2013 stores already loaded streams client-side to avoid making repeated requests to the network</li> </ul> <p>The <code>TileLoader</code> class provided by the library extends the <code>DataLoader</code> class from the dataloader library to leverage its capabilities, and provides extra methods to support additional use cases for Ceramic.</p>"},{"location":"tools/glaze/tile-loader/#getting-started-with-tile-loader","title":"Getting started with Tile Loader","text":"<p>Visit the Glaze Tile Loader reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with tile loader:</p>"},{"location":"tools/glaze/tile-loader/#batching","title":"Batching","text":"<p>Batching combines multiple concurrent queries to a Ceramic node into a single query.</p> <p>Without tile loader, a Ceramic client will retrieve two tile document streams from the network by performing two separate network requests:</p> <pre><code>import { TileDocument } from '@ceramicnetwork/stream-tile'\n\nconst [stream1, stream2] = await Promise.all([\nTileDocument.load(ceramic, 'streamID1'),\nTileDocument.load(ceramic, 'streamID2'),\n])\n</code></pre> <p>When using the <code>loader</code> instance, the two streams will now be loaded with a single network request:</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic })\nconst [stream1, stream2] = await Promise.all([\nloader.load('streamID1'),\nloader.load('streamID2'),\n])\n</code></pre>"},{"location":"tools/glaze/tile-loader/#caching","title":"Caching","text":"<p>Caching allows your application to keep track of streams client-side that have been previously retrieved from the network.</p> <p> Caching is disabled by default and may not be suited for your use-cases, make sure you carefully consider the trade-offs before enabling it.</p> <p>Streams loaded from cache may be out of sync with the current state found on the network, so applications should be designed accordingly!</p> <p>Without tile loader, the Ceramic client will perform two network requests to get the state of the stream at two different times:</p> <pre><code>import { TileDocument } from '@ceramicnetwork/stream-tile'\n\n// Load the stream at some point in your app\nconst stream = await TileDocument.load(ceramic, 'streamID')\n// Maybe the same stream needs to be loaded at a different time or in another part of your app\nconst streamAgain = await TileDocument.load(ceramic, 'streamID')\n</code></pre> <p>When using the <code>loader</code> instance, the second call will be resolved directly from the loader's internal cache rather than making a second network request:</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic, cache: true })\n\n// Load the stream at some point in your app\nconst stream = await loader.load('streamID')\n// Maybe the same stream needs to be loaded at a different time or in another part of your app\nconst streamAgain = await loader.load('streamID')\n</code></pre>"},{"location":"tools/glaze/tile-loader/#customizing-your-cache","title":"Customizing your cache","text":"<p>When setting the <code>cache</code> option to <code>true</code> in the loader constructor, the cache will live as long as the loader instance. This means that any stream will only ever get loaded from the network once, and persist in memory until the loader instance is deleted.</p> <p>It is possible to provide a custom cache implementation in the loader constructor to customize this behavior, for example in order to limit memory usage by restricting the number of streams kept in the cache, or discarding loaded streams after a given period of time.</p> <p>A custom cache must implement a subset of the Map interface, defined by the TileCache interface.</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\n// The cache must implement a subset of the Map interface\nconst cache = new Map()\nconst loader = new TileLoader({ ceramic, cache })\n\n// The loader will cache the request as soon as the load() method is called, so the stored value is a Promise of a TileDocument\nloader.load('streamID')\ncache.get('streamID') // Promise&lt;TileDocument&gt;\n</code></pre>"},{"location":"tools/glaze/tile-loader/#additional-apis","title":"Additional APIs","text":"<p>In addition to the <code>DataLoader APIs</code>, the <code>TileLoader</code> class provides the following methods specific to Ceramic's use-cases.</p>"},{"location":"tools/glaze/tile-loader/#create-tile-documents","title":"Create tile documents","text":"<p>The <code>create()</code> method wraps a <code>TileDocument.create()</code> call to add the created stream to the internal cache of the loader. This has no effect if the cache is disabled.</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic, cache: true })\nconst stream = await loader.create({ hello: world })\n// The following call will returne the stream from the cache\nawait loader.load(stream.id)\n</code></pre>"},{"location":"tools/glaze/tile-loader/#retrieve-deterministic-tiles","title":"Retrieve deterministic tiles","text":"<p>In Ceramic, streams can be loaded using their metadata rather than a stream ID if they are created as determinitic streams.</p> <p>Using the <code>deterministic()</code> method of a loader instance allows to load such streams while benefiting from the batching and caching functionalities of the loader.</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic })\n// The following call will load the latest version of the stream based on its metadata, if such stream exists\nconst stream = await loader.deterministic({\ncontrollers: ['did:key:...'],\nfamily: 'test',\n})\n</code></pre>"},{"location":"tools/identitylink/overview/","title":"IdentityLink","text":"<p>IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts. Once issued these claims can be stored anywhere, however it is recommended to store them in a user's Identity Index (IDX) under the Also Known As definition.</p>"},{"location":"tools/identitylink/overview/#compatibility","title":"Compatibility","text":""},{"location":"tools/identitylink/overview/#did-methods","title":"DID Methods","text":"<p>IdentityLink works with all DID methods.</p>"},{"location":"tools/identitylink/overview/#web2-platforms","title":"Web2 Platforms","text":"<p>IdentityLink currently supports:</p> <ul> <li>Twitter</li> <li>Github</li> <li>Discord</li> <li>Discourse</li> <li>Telegram</li> <li>Instagram (coming soon)</li> </ul>"},{"location":"tools/identitylink/overview/#how-it-works","title":"How it works","text":""},{"location":"tools/identitylink/overview/#public-dns","title":"Public DNS","text":"<p>For platforms that allow users to post content to public DNS endpoints (i.e. Twitter, Github):</p>"},{"location":"tools/identitylink/overview/#private-servers","title":"Private servers","text":"<p>For platforms that restrict messages to private servers (i.e. Telegram, Discord):</p>"},{"location":"tools/identitylink/overview/#usage","title":"Usage","text":""},{"location":"tools/identitylink/overview/#use-the-identitylink-service-hosted-by-3box-labs","title":"Use the IdentityLink service hosted by 3Box Labs","text":"<p>Add more about how to add it to your project.</p>"},{"location":"tools/identitylink/overview/#run-your-own-identitylink-service","title":"Run your own IdentityLink service","text":"<p>Point to the relevant instructions on how to run it yourself.</p>"},{"location":"tools/identitylink/overview/#learn-more","title":"Learn more","text":"<p>Visit the IdentityLink repository on Github for full documentation.</p>"},{"location":"tools/self-id/configuration/","title":"Self.ID SDK configuration","text":"<p>The Self.ID SDK requires minimum configuration. In this guide you will learn how to:</p> <ul> <li>Connect the SDK to a Ceramic node</li> <li>Configure your data models</li> </ul>"},{"location":"tools/self-id/configuration/#connect-to-a-ceramic-node","title":"Connect to a Ceramic node","text":"<p>In all Self.ID modules, you'll need to specify which Ceramic node to use. This endpoint can be the URL of any known Ceramic node, <code>http://localhost:7007</code>, or one of the following preconfigured options:</p> Preconfigurations Network Permissions Implementation Host <code>local</code> Local Read/Write JS Ceramic Local <code>testnet-clay</code> Clay testnet Read/Write JS Ceramic 3Box Labs <code>testnet-clay-gateway</code> Clay testnet Read-only JS Ceramic 3Box Labs <code>mainnet-gateway</code> Mainnet Read-only JS Ceramic 3Box Labs <p>When using localhost, ensure your local Ceramic node is running</p>"},{"location":"tools/self-id/configuration/#configure-your-data-models","title":"Configure your data models","text":"<p>Self.ID APIs are built on top of data models. By default, the SDK supports interacting with the following data models without further configuration:</p> Data model Alias Description <code>identity-profile-basic</code> (CIP-19) <code>basicProfile</code> Stores a user's profile <code>identity-accounts-web</code> (CIP-23) <code>alsoKnownAs</code> Stores verifiable credentials that link a user's Web2 accounts to their Ceramic account. <code>identity-accounts-crypto</code> (CIP-21) <code>cryptoAccounts</code> Stores a list of CAIP-10 Links that link a user's Web3 accounts to their Ceramic account. <pre><code>import { Core } from '@self.id/core'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n\nconst profile = await core.get('basicProfile', id)\n</code></pre>"},{"location":"tools/self-id/configuration/#using-additional-data-models","title":"Using additional data models","text":"<p>It is possible to provide alternative models for use in the Self.ID <code>Core</code> module, or any Self.ID module that extends it, including <code>Web</code>, <code>React</code>, and <code>Framework</code>.</p> <pre><code>import { Core } from '@self.id/core'\n\nconst aliases = {\ndefinitions: {\nprofile: 'kjzl6cwe1jw145cjbeko9kil8g9bxszjhyde21ob8epxuxkaon1izyqsu8wgcic',\n},\nschemas: {\nProfile:\n'ceramic://k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio',\n},\ntiles: {},\n}\n\nconst core = new Core({ ceramic: 'testnet-clay', aliases })\n\nconst profile = await core.get('profile', id)\n</code></pre> <p>You can learn more about creating and using DataModels in the dedicated page.</p>"},{"location":"tools/self-id/framework/","title":"Self.ID Framework","text":"<p><code>@self.id/framework</code> is the highest-level abstraction provided by the Self.ID SDK, designed to easily power React applications with React components, hooks, and utility functions for user authentication, data storage, and retrieval.</p> <p>Native support for React \u2013 React components, hooks and related utility functions to help manage user authentication, storage, and retrieval on Ceramic.</p> <p>Authentication hook \u2013 React hook to easily initiate a Ceramic sign-in flow where users are authenticated client-side with their Ethereum or other EVM-compatible wallet.</p> <p>User data management hook \u2013 Data storage and retrieval APIs are primarily based on the concept of a viewer, aka the current user of the app, which can be the currently-authenticated user or the last known authenticated user (for example when using a cookie for persistence). APIs are read-only if the viewer is not authenticated, but support reads and writes if they're authenticated.</p>"},{"location":"tools/self-id/framework/#getting-started-with-framework","title":"Getting started with Framework","text":"<p>Visit the Self.ID Framework reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with the Self.ID Framework:</p>"},{"location":"tools/self-id/framework/#installation","title":"Installation","text":"<p>Install <code>@self.id/framework</code> from npm:</p> <pre><code>npm install @self.id/framework\n</code></pre>"},{"location":"tools/self-id/framework/#setup-and-configuration","title":"Setup and configuration","text":"<p>The <code>Provider</code> component must be added at the root of the application tree in order to use the React hooks described below. It can be used to provide a custom configuration for the Self.ID clients, authentication, state and UI options.</p> <pre><code>import { Provider } from '@self.id/framework'\n\nfunction App({ children }) {\nreturn &lt;Provider client={{ ceramic: 'testnet-clay' }}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre>"},{"location":"tools/self-id/framework/#user-authentication","title":"User authentication","text":"<p>The <code>useViewerConnection</code> hook provides a way for applications to access the current authentication state, initiate the authentication flow, and reset the authentication state.</p> <pre><code>import { useViewerConnection } from '@self.id/framework'\n\nfunction ConnectButton() {\nconst [connection, connect, disconnect] = useViewerConnection()\n\nreturn connection.status === 'connected' ? (\n&lt;button\nonClick={() =&gt; {\ndisconnect()\n}}&gt;\nDisconnect ({connection.selfID.id})\n&lt;/button&gt;\n) : 'ethereum' in window ? (\n&lt;button\ndisabled={connection.status === 'connecting'}\nonClick={async () =&gt; {\nconst accounts = await window.ethereum.request({\nmethod: 'eth_requestAccounts',\n})\nawait connect(new EthereumAuthProvider(window.ethereum, accounts[0]))\n}}&gt;\nConnect\n&lt;/button&gt;\n) : (\n&lt;p&gt;\nAn injected Ethereum provider such as{' '}\n&lt;a href=\"https://metamask.io/\"&gt;MetaMask&lt;/a&gt; is needed to authenticate.\n&lt;/p&gt;\n)\n}\n</code></pre> <p>The user authentication flow consists of the following steps:</p> <ol> <li>An Ethereum authentication provider is created using the Ethereum provider</li> <li>The auth flow with 3ID Connect starts, using the Ethereum authentication provider</li> <li>A <code>SelfID</code> instance is created and stored in application state</li> </ol> <p>Once this flow is completed, the viewer's cookie is set to the authenticated user and storing data with the user becomes possible.</p>"},{"location":"tools/self-id/framework/#auth-session-management","title":"Auth Session Management","text":"<p>Reference did-session for more examples of managing the session for a user. Following code expands on example above. </p> <pre><code>// ...\nconst [connection, connect, disconnect] = useViewerConnection()\n// ...\n// get session string you serialized and stored before, check if still valid (or how much longer)\nconst sessionStr = ...\nconst selfid = await connect(new EthereumAuthProvider(window.ethereum, accounts[0]), sessionStr)\n// ...\n// get session to serialize and store \nconst session = selfid.client.session //or connection.selfID.client.session\nsession.serialize()\n// ...\n</code></pre>"},{"location":"tools/self-id/framework/#data-management","title":"Data management","text":"<p>The <code>useViewerRecord</code> hook loads the viewer's data for a given data model (definition), with the following variants:</p> <ul> <li>If no viewer is set, no data can be loaded</li> <li>If the viewer is not authenticated, the data gets loaded but cannot be modified</li> <li>If the viewer is authenticated, the data gets loaded and can be modified</li> </ul> <pre><code>import { useViewerRecord } from '@self.id/framework'\n\nfunction ShowViewerName() {\nconst record = useViewerRecord('basicProfile')\n\nconst text = record.isLoading\n? 'Loading...'\n: record.content\n? `Hello ${record.content.name || 'stranger'}`\n: 'No profile to load'\nreturn &lt;p&gt;{text}&lt;/p&gt;\n}\n\nfunction SetViewerName() {\nconst record = useViewerRecord('basicProfile')\n\nreturn (\n&lt;button\ndisabled={!record.isMutable || record.isMutating}\nonClick={async () =&gt; {\nawait record.merge({ name: 'Alice' })\n}}&gt;\nSet name\n&lt;/button&gt;\n)\n}\n</code></pre> <p>The <code>usePublicRecord</code> hook is similar to the <code>useViewerRecord</code> hook described above, but is used to read public data from an explicitly provided account rather than the viewer. This hook is read-only and can be used, for example, to retrieve the public data for other users of your application to display in a UI.</p> <pre><code>import { usePublicRecord } from '@self.id/framework'\n\nfunction ShowProfileName({ did }) {\nconst record = usePublicRecord('basicProfile', did)\n\nconst text = record.isLoading\n? 'Loading...'\n: record.content\n? `Hello ${record.content.name || 'stranger'}`\n: 'No profile to load'\nreturn &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>"},{"location":"tools/self-id/framework/#upgrading-from-03x-to-04x","title":"Upgrading from 0.3.x to 0.4.x","text":"<p>Version <code>0.4.x</code> switched the default authentication method and libray from 3id-connect with 3ID DIDs to did-session with PKH DIDs. If you wish to upgrade and still use 3id-connect you can pass a flag and configure your provider as follows. There are no other changes in <code>v0.4.x</code>, making upgrading not required at the moment if you dont wish too change auth methods, but PKH DIDs will be the recommended account going forward. </p> <pre><code>import { Provider } from '@self.id/framework'\n\nfunction App({ children }) {\nreturn &lt;Provider client={{ ceramic: 'testnet-clay' }} threeidConnect={true}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre> <p>**Switching authentication methods with out consideration will change DIDs for users and result in any prior data not being resolved. **</p>"},{"location":"tools/self-id/framework/#advanced","title":"Advanced","text":""},{"location":"tools/self-id/framework/#server-side-rendering","title":"Server-side rendering","text":"<p>Server-side rendering can be used to improve the user experience for the first load of an app or page. The Self.ID Framework exports a <code>RequestClient</code> class that can be used to fetch data on a server in order to have it immediately available to the <code>usePublicRecord</code> and <code>useViewerRecord</code> hooks.</p> <p>This example shows how server-side rendering can be used in a Next.js page, using the <code>ShowViewerName</code> component from the <code>useViewerRecord</code> hook example:</p> <pre><code>import { Provider, RequestClient } from '@self.id/framework'\n\nexport const getServerSideProps = async (ctx) =&gt; {\nconst client = new RequestClient({\nceramic: 'testnet-clay',\n// Inject the cookie from the request headers to parse the viewerID\ncookie: ctx.req.headers.cookie,\n})\nif (client.viewerID != null) {\n// If the viewerID is set, fetch its profile\nawait client.prefetch('basicProfile', client.viewerID)\n}\nreturn { props: { state: client.getState() } }\n}\n\n// Use the state prop injected by the server\nexport default function Home({ state }) {\nreturn (\n&lt;Provider state={state}&gt;\n&lt;ShowViewerName /&gt;\n&lt;/Provider&gt;\n)\n}\n</code></pre>"},{"location":"tools/self-id/overview/","title":"Self.ID","text":""},{"location":"tools/self-id/read/","title":"Self.ID Core","text":"<p>The <code>@self.id/core</code> module provides read-only user data APIs for Node and browser-based applications.</p> <p>If you need user data storage, use Self.ID Framework for React or Self.ID Web for web.</p>"},{"location":"tools/self-id/read/#getting-started-with-selfid-core","title":"Getting started with Self.ID Core","text":"<p>Visit the Self.ID Core reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with Self.ID Core:</p>"},{"location":"tools/self-id/read/#installation","title":"Installation","text":"<p>Install <code>@self.id/core</code> from npm:</p> <pre><code>npm install @self.id/core\n</code></pre>"},{"location":"tools/self-id/read/#setup-and-configuration","title":"Setup and configuration","text":"<p>Before using the Self.ID Core APIs, make sure you have configured your setup including your node and data models.</p>"},{"location":"tools/self-id/read/#connect-to-a-ceramic-node","title":"Connect to a Ceramic node","text":"<p>The Self.ID <code>Core</code> instance generates a Ceramic client that needs to connect to a Ceramic node:</p> <pre><code>import { Core } from '@self.id/core'\n\n// connect to a known URL\nconst core = new Core({ ceramic: 'http://localhost:7007' })\n// or use one of the preconfigured option\nconst core = new Core({ ceramic: 'testnet-clay' })\n</code></pre> <p>This Ceramic endpoint can be the URL of any known node, <code>http://localhost:7007</code>, or one of Self.ID's preconfigured node options.</p>"},{"location":"tools/self-id/read/#configure-data-models","title":"Configure data models","text":"<p>Self.ID core is pre-configured with a few popular data models that you can use to retrieve data from the network. You can read about those data models, and learn how to add additional data models, in the data models configuration page.</p>"},{"location":"tools/self-id/read/#retrieving-user-data","title":"Retrieving user data","text":""},{"location":"tools/self-id/read/#using-the-core-instance","title":"Using the core instance","text":"<p>The Self.ID <code>Core</code> instance can be used directly to read user data from Ceramic, using the <code>get()</code> method with a data model (definition) alias as the first argument and the user's Ceramic account as the second argument:</p> <pre><code>import { Core } from '@self.id/core'\n\nconst core = new Core(...)\n\nconst profile = await core.get('basicProfile', 'did:3:...')\n</code></pre>"},{"location":"tools/self-id/read/#using-the-publicid-class","title":"Using the PublicID class","text":"<p>For use-cases when it is helpful to keep track of a specific account and possibly retrieve its data multiple times, the <code>PublicID</code> class can be used to wrap a Ceramic account:</p> <pre><code>import { Core, PublicID } from '@self.id/core'\n\nconst core = new Core(...)\nconst aliceID = 'did:3:123...'\n\n// rather than using the Core instance directly as followed...\nconst [profile, accounts] = await Promise.all([\ncore.get('basicProfile', aliceID),\ncore.get('cryptoAccounts', aliceID),\n])\n\n// ... a PublicID instance can be used:\nconst alice = new PublicID({ core, id: aliceID })\nconst [profile, accounts] = await Promise.all([\nalice.get('basicProfile'),\nalice.get('cryptoAccounts'),\n])\n</code></pre>"},{"location":"tools/self-id/sample-applications/","title":"Self.ID Sample Apps","text":"<p>This page contains sample applications built with the Self.ID SDK that you can use and dig through their code.</p>"},{"location":"tools/self-id/sample-applications/#profile-applications","title":"Profile applications","text":"<p>These reference applications use the Self.ID SDK to allow users to create a Web3 profile attached to their Ceramic account and Ethereum wallet.</p> <p>Create a Web3 profile on Ceramic mainnet \u2192</p> <p>Create a Web3 profile on Ceramic testnet \u2192</p>"},{"location":"tools/self-id/utilities/","title":"Application utilities","text":""},{"location":"tools/self-id/utilities/#image-utilities","title":"Image utilities \u2192","text":"<p>The <code>@self.id/image-utils</code> module provides various utility functions for managing images on Web3 and is mostly meant to be used in a Web browser environment:</p> <ul> <li>Multi-sizing \u2013 Automatically convert an image into multiple sizes</li> <li>IPFS upload \u2013 Upload all image sizes to IPFS as a linked data structure</li> <li>Smart selection \u2013 Retrieve the most suitable image size based on your use case. For example, you might want to load profile image thumnails for a social UI or leaderboard, and load a larger resolution image for a single user profile page.</li> </ul>"},{"location":"tools/self-id/write/","title":"Self.ID Web","text":"<p>The <code>@self.id/web</code> module provides user authentication, data storage, and retrieval for browser-based web applications.</p> <p>If you're building with React, we recommend using Self.ID Framework instead.</p>"},{"location":"tools/self-id/write/#getting-started-with-selfid-web","title":"Getting started with Self.ID Web","text":"<p>Visit the Self.ID Web reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with Self.ID Web:</p>"},{"location":"tools/self-id/write/#installation","title":"Installation","text":"<p>Install <code>@self.id/web</code> from npm:</p> <pre><code>npm install @self.id/web\n</code></pre>"},{"location":"tools/self-id/write/#user-authentication","title":"User authentication","text":"<p>The Self.ID web module exports the <code>SelfID</code> and <code>WebClient</code> classes. Either can be used for user authentication via an Ethereum or EVM-comppatible wallet:</p>"},{"location":"tools/self-id/write/#using-the-selfid-class","title":"Using the SelfID class","text":"<p>The process of creating all instances needed by your web application (<code>WebClient</code>, <code>DID</code> and <code>SelfID</code>) can be reduced to using the <code>SelfID.authenticate()</code> static authentication method:</p> <pre><code>import { EthereumAuthProvider, SelfID } from '@self.id/web'\n\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({\nmethod: 'eth_requestAccounts',\n})\n\n// The following configuration assumes your local node is connected to the Clay testnet\nconst self = await SelfID.authenticate({\nauthProvider: new EthereumAuthProvider(window.ethereum, addresses[0]),\nceramic: 'local',\nconnectNetwork: 'testnet-clay',\n})\n</code></pre>"},{"location":"tools/self-id/write/#using-the-webclient-class","title":"Using the WebClient class","text":"<p>The <code>WebClient</code> class extends <code>Core</code> from the <code>@self.id/core</code> package with the additional <code>connectNetwork</code> parameter to specify the Ceramic network that should be used by 3ID Connect:</p> <pre><code>import { EthereumAuthProvider, SelfID, WebClient } from '@self.id/web'\n\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({\nmethod: 'eth_requestAccounts',\n})\nconst authProvider = new EthereumAuthProvider(window.ethereum, addresses[0])\n\n// The following configuration assumes your local node is connected to the Clay testnet\nconst client = new WebClientSession({\nceramic: 'local',\n})\n\n// If authentication is successful, a DID instance is attached to the Ceramic instance\nawait client.authenticate(authProvider)\n\n// A SelfID instance can only be created with an authenticated Ceramic instance\nconst self = new SelfID({ client })\n</code></pre> <p>To use with 3id-connect instead of did-session you would use the <code>WebClient</code> instead. It is recommended to use with did-session.</p> <pre><code>const client = new WebClient({\nceramic: 'local',\nconnectNetwork: 'testnet-clay',\n})\n</code></pre>"},{"location":"tools/self-id/write/#data-management","title":"Data management","text":"<p>After authenticating the user with either of the above methods, your application can perform data storage and retrieval interactions with the user based on a data model (definition):</p> <pre><code>await self.set('basicProfile', { name: 'Alice' })\n</code></pre>"},{"location":"tools/self-id/write/#auth-session-management","title":"Auth Session Management","text":"<p>Reference did-session for more examples of managing the session for a user. </p> <pre><code>// get sessionStr for storage \nawait client.authenticate(authProvider, true, sessionStr)\nconst self = new SelfID({ client })\n// get session to serialize and store \nconst session = self.client.session // store session str\nsession.serialize()\n</code></pre>"}]}